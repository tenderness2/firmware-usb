// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef PROTOBUF_types_2eproto__INCLUDED
#define PROTOBUF_types_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_types_2eproto();
void protobuf_AssignDesc_types_2eproto();
void protobuf_ShutdownFile_types_2eproto();

class HDNodeType;
class HDNodePathType;
class CoinType;
class MultisigRedeemScriptType;
class TxInputType;
class TxOutputType;
class TxOutputBinType;
class TransactionType;
class TxRequestDetailsType;
class TxRequestSerializedType;
class IdentityType;
class AccountLabelsType;
class AccountLabelType;

enum FailureType {
  Failure_UnexpectedMessage = 1,
  Failure_ButtonExpected = 2,
  Failure_SyntaxError = 3,
  Failure_ActionCancelled = 4,
  Failure_PinExpected = 5,
  Failure_PinCancelled = 6,
  Failure_PinInvalid = 7,
  Failure_InvalidSignature = 8,
  Failure_Other = 9,
  Failure_NotEnoughFunds = 10,
  Failure_NotInitialized = 11,
  Failure_FirmwareError = 99
};
bool FailureType_IsValid(int value);
const FailureType FailureType_MIN = Failure_UnexpectedMessage;
const FailureType FailureType_MAX = Failure_FirmwareError;
const int FailureType_ARRAYSIZE = FailureType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FailureType_descriptor();
inline const ::std::string& FailureType_Name(FailureType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FailureType_descriptor(), value);
}
inline bool FailureType_Parse(
    const ::std::string& name, FailureType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FailureType>(
    FailureType_descriptor(), name, value);
}
enum OutputScriptType {
  PAYTOADDRESS = 0,
  PAYTOSCRIPTHASH = 1,
  PAYTOMULTISIG = 2,
  PAYTOOPRETURN = 3
};
bool OutputScriptType_IsValid(int value);
const OutputScriptType OutputScriptType_MIN = PAYTOADDRESS;
const OutputScriptType OutputScriptType_MAX = PAYTOOPRETURN;
const int OutputScriptType_ARRAYSIZE = OutputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OutputScriptType_descriptor();
inline const ::std::string& OutputScriptType_Name(OutputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OutputScriptType_descriptor(), value);
}
inline bool OutputScriptType_Parse(
    const ::std::string& name, OutputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OutputScriptType>(
    OutputScriptType_descriptor(), name, value);
}
enum InputScriptType {
  SPENDADDRESS = 0,
  SPENDMULTISIG = 1
};
bool InputScriptType_IsValid(int value);
const InputScriptType InputScriptType_MIN = SPENDADDRESS;
const InputScriptType InputScriptType_MAX = SPENDMULTISIG;
const int InputScriptType_ARRAYSIZE = InputScriptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor();
inline const ::std::string& InputScriptType_Name(InputScriptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    InputScriptType_descriptor(), value);
}
inline bool InputScriptType_Parse(
    const ::std::string& name, InputScriptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InputScriptType>(
    InputScriptType_descriptor(), name, value);
}
enum RequestType {
  TXINPUT = 0,
  TXOUTPUT = 1,
  TXMETA = 2,
  TXFINISHED = 3
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = TXINPUT;
const RequestType RequestType_MAX = TXFINISHED;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum ButtonRequestType {
  ButtonRequest_Other = 1,
  ButtonRequest_FeeOverThreshold = 2,
  ButtonRequest_ConfirmOutput = 3,
  ButtonRequest_ResetDevice = 4,
  ButtonRequest_ConfirmWord = 5,
  ButtonRequest_WipeDevice = 6,
  ButtonRequest_ProtectCall = 7,
  ButtonRequest_SignTx = 8,
  ButtonRequest_FirmwareCheck = 9,
  ButtonRequest_Address = 10
};
bool ButtonRequestType_IsValid(int value);
const ButtonRequestType ButtonRequestType_MIN = ButtonRequest_Other;
const ButtonRequestType ButtonRequestType_MAX = ButtonRequest_Address;
const int ButtonRequestType_ARRAYSIZE = ButtonRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ButtonRequestType_descriptor();
inline const ::std::string& ButtonRequestType_Name(ButtonRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ButtonRequestType_descriptor(), value);
}
inline bool ButtonRequestType_Parse(
    const ::std::string& name, ButtonRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ButtonRequestType>(
    ButtonRequestType_descriptor(), name, value);
}
enum PinMatrixRequestType {
  PinMatrixRequestType_Current = 1,
  PinMatrixRequestType_NewFirst = 2,
  PinMatrixRequestType_NewSecond = 3
};
bool PinMatrixRequestType_IsValid(int value);
const PinMatrixRequestType PinMatrixRequestType_MIN = PinMatrixRequestType_Current;
const PinMatrixRequestType PinMatrixRequestType_MAX = PinMatrixRequestType_NewSecond;
const int PinMatrixRequestType_ARRAYSIZE = PinMatrixRequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PinMatrixRequestType_descriptor();
inline const ::std::string& PinMatrixRequestType_Name(PinMatrixRequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PinMatrixRequestType_descriptor(), value);
}
inline bool PinMatrixRequestType_Parse(
    const ::std::string& name, PinMatrixRequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PinMatrixRequestType>(
    PinMatrixRequestType_descriptor(), name, value);
}
// ===================================================================

class HDNodeType : public ::google::protobuf::Message {
 public:
  HDNodeType();
  virtual ~HDNodeType();

  HDNodeType(const HDNodeType& from);

  inline HDNodeType& operator=(const HDNodeType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HDNodeType& default_instance();

  void Swap(HDNodeType* other);

  // implements Message ----------------------------------------------

  HDNodeType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HDNodeType& from);
  void MergeFrom(const HDNodeType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 depth = 1;
  inline bool has_depth() const;
  inline void clear_depth();
  static const int kDepthFieldNumber = 1;
  inline ::google::protobuf::uint32 depth() const;
  inline void set_depth(::google::protobuf::uint32 value);

  // required uint32 fingerprint = 2;
  inline bool has_fingerprint() const;
  inline void clear_fingerprint();
  static const int kFingerprintFieldNumber = 2;
  inline ::google::protobuf::uint32 fingerprint() const;
  inline void set_fingerprint(::google::protobuf::uint32 value);

  // required uint32 child_num = 3;
  inline bool has_child_num() const;
  inline void clear_child_num();
  static const int kChildNumFieldNumber = 3;
  inline ::google::protobuf::uint32 child_num() const;
  inline void set_child_num(::google::protobuf::uint32 value);

  // required bytes chain_code = 4;
  inline bool has_chain_code() const;
  inline void clear_chain_code();
  static const int kChainCodeFieldNumber = 4;
  inline const ::std::string& chain_code() const;
  inline void set_chain_code(const ::std::string& value);
  inline void set_chain_code(const char* value);
  inline void set_chain_code(const void* value, size_t size);
  inline ::std::string* mutable_chain_code();
  inline ::std::string* release_chain_code();
  inline void set_allocated_chain_code(::std::string* chain_code);

  // optional bytes private_key = 5;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 5;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  inline ::std::string* release_private_key();
  inline void set_allocated_private_key(::std::string* private_key);

  // optional bytes public_key = 6;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 6;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  inline ::std::string* release_public_key();
  inline void set_allocated_public_key(::std::string* public_key);

  // @@protoc_insertion_point(class_scope:HDNodeType)
 private:
  inline void set_has_depth();
  inline void clear_has_depth();
  inline void set_has_fingerprint();
  inline void clear_has_fingerprint();
  inline void set_has_child_num();
  inline void clear_has_child_num();
  inline void set_has_chain_code();
  inline void clear_has_chain_code();
  inline void set_has_private_key();
  inline void clear_has_private_key();
  inline void set_has_public_key();
  inline void clear_has_public_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 depth_;
  ::google::protobuf::uint32 fingerprint_;
  ::std::string* chain_code_;
  ::std::string* private_key_;
  ::std::string* public_key_;
  ::google::protobuf::uint32 child_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static HDNodeType* default_instance_;
};
// -------------------------------------------------------------------

class HDNodePathType : public ::google::protobuf::Message {
 public:
  HDNodePathType();
  virtual ~HDNodePathType();

  HDNodePathType(const HDNodePathType& from);

  inline HDNodePathType& operator=(const HDNodePathType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HDNodePathType& default_instance();

  void Swap(HDNodePathType* other);

  // implements Message ----------------------------------------------

  HDNodePathType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HDNodePathType& from);
  void MergeFrom(const HDNodePathType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HDNodeType node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // @@protoc_insertion_point(class_scope:HDNodePathType)
 private:
  inline void set_has_node();
  inline void clear_has_node();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HDNodeType* node_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static HDNodePathType* default_instance_;
};
// -------------------------------------------------------------------

class CoinType : public ::google::protobuf::Message {
 public:
  CoinType();
  virtual ~CoinType();

  CoinType(const CoinType& from);

  inline CoinType& operator=(const CoinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinType& default_instance();

  void Swap(CoinType* other);

  // implements Message ----------------------------------------------

  CoinType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CoinType& from);
  void MergeFrom(const CoinType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coin_name = 1;
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 1;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional string coin_shortcut = 2;
  inline bool has_coin_shortcut() const;
  inline void clear_coin_shortcut();
  static const int kCoinShortcutFieldNumber = 2;
  inline const ::std::string& coin_shortcut() const;
  inline void set_coin_shortcut(const ::std::string& value);
  inline void set_coin_shortcut(const char* value);
  inline void set_coin_shortcut(const char* value, size_t size);
  inline ::std::string* mutable_coin_shortcut();
  inline ::std::string* release_coin_shortcut();
  inline void set_allocated_coin_shortcut(::std::string* coin_shortcut);

  // optional uint32 address_type = 3 [default = 0];
  inline bool has_address_type() const;
  inline void clear_address_type();
  static const int kAddressTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 address_type() const;
  inline void set_address_type(::google::protobuf::uint32 value);

  // optional uint64 maxfee_kb = 4;
  inline bool has_maxfee_kb() const;
  inline void clear_maxfee_kb();
  static const int kMaxfeeKbFieldNumber = 4;
  inline ::google::protobuf::uint64 maxfee_kb() const;
  inline void set_maxfee_kb(::google::protobuf::uint64 value);

  // optional uint32 address_type_p2sh = 5 [default = 5];
  inline bool has_address_type_p2sh() const;
  inline void clear_address_type_p2sh();
  static const int kAddressTypeP2ShFieldNumber = 5;
  inline ::google::protobuf::uint32 address_type_p2sh() const;
  inline void set_address_type_p2sh(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:CoinType)
 private:
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_coin_shortcut();
  inline void clear_has_coin_shortcut();
  inline void set_has_address_type();
  inline void clear_has_address_type();
  inline void set_has_maxfee_kb();
  inline void clear_has_maxfee_kb();
  inline void set_has_address_type_p2sh();
  inline void clear_has_address_type_p2sh();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* coin_name_;
  ::std::string* coin_shortcut_;
  ::google::protobuf::uint64 maxfee_kb_;
  ::google::protobuf::uint32 address_type_;
  ::google::protobuf::uint32 address_type_p2sh_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static CoinType* default_instance_;
};
// -------------------------------------------------------------------

class MultisigRedeemScriptType : public ::google::protobuf::Message {
 public:
  MultisigRedeemScriptType();
  virtual ~MultisigRedeemScriptType();

  MultisigRedeemScriptType(const MultisigRedeemScriptType& from);

  inline MultisigRedeemScriptType& operator=(const MultisigRedeemScriptType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultisigRedeemScriptType& default_instance();

  void Swap(MultisigRedeemScriptType* other);

  // implements Message ----------------------------------------------

  MultisigRedeemScriptType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MultisigRedeemScriptType& from);
  void MergeFrom(const MultisigRedeemScriptType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .HDNodePathType pubkeys = 1;
  inline int pubkeys_size() const;
  inline void clear_pubkeys();
  static const int kPubkeysFieldNumber = 1;
  inline const ::HDNodePathType& pubkeys(int index) const;
  inline ::HDNodePathType* mutable_pubkeys(int index);
  inline ::HDNodePathType* add_pubkeys();
  inline const ::google::protobuf::RepeatedPtrField< ::HDNodePathType >&
      pubkeys() const;
  inline ::google::protobuf::RepeatedPtrField< ::HDNodePathType >*
      mutable_pubkeys();

  // repeated bytes signatures = 2;
  inline int signatures_size() const;
  inline void clear_signatures();
  static const int kSignaturesFieldNumber = 2;
  inline const ::std::string& signatures(int index) const;
  inline ::std::string* mutable_signatures(int index);
  inline void set_signatures(int index, const ::std::string& value);
  inline void set_signatures(int index, const char* value);
  inline void set_signatures(int index, const void* value, size_t size);
  inline ::std::string* add_signatures();
  inline void add_signatures(const ::std::string& value);
  inline void add_signatures(const char* value);
  inline void add_signatures(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& signatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signatures();

  // optional uint32 m = 3;
  inline bool has_m() const;
  inline void clear_m();
  static const int kMFieldNumber = 3;
  inline ::google::protobuf::uint32 m() const;
  inline void set_m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MultisigRedeemScriptType)
 private:
  inline void set_has_m();
  inline void clear_has_m();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::HDNodePathType > pubkeys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signatures_;
  ::google::protobuf::uint32 m_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static MultisigRedeemScriptType* default_instance_;
};
// -------------------------------------------------------------------

class TxInputType : public ::google::protobuf::Message {
 public:
  TxInputType();
  virtual ~TxInputType();

  TxInputType(const TxInputType& from);

  inline TxInputType& operator=(const TxInputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxInputType& default_instance();

  void Swap(TxInputType* other);

  // implements Message ----------------------------------------------

  TxInputType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxInputType& from);
  void MergeFrom(const TxInputType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes prev_hash = 2;
  inline bool has_prev_hash() const;
  inline void clear_prev_hash();
  static const int kPrevHashFieldNumber = 2;
  inline const ::std::string& prev_hash() const;
  inline void set_prev_hash(const ::std::string& value);
  inline void set_prev_hash(const char* value);
  inline void set_prev_hash(const void* value, size_t size);
  inline ::std::string* mutable_prev_hash();
  inline ::std::string* release_prev_hash();
  inline void set_allocated_prev_hash(::std::string* prev_hash);

  // required uint32 prev_index = 3;
  inline bool has_prev_index() const;
  inline void clear_prev_index();
  static const int kPrevIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 prev_index() const;
  inline void set_prev_index(::google::protobuf::uint32 value);

  // optional bytes script_sig = 4;
  inline bool has_script_sig() const;
  inline void clear_script_sig();
  static const int kScriptSigFieldNumber = 4;
  inline const ::std::string& script_sig() const;
  inline void set_script_sig(const ::std::string& value);
  inline void set_script_sig(const char* value);
  inline void set_script_sig(const void* value, size_t size);
  inline ::std::string* mutable_script_sig();
  inline ::std::string* release_script_sig();
  inline void set_allocated_script_sig(::std::string* script_sig);

  // optional uint32 sequence = 5 [default = 4294967295];
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 6;
  inline ::InputScriptType script_type() const;
  inline void set_script_type(::InputScriptType value);

  // optional .MultisigRedeemScriptType multisig = 7;
  inline bool has_multisig() const;
  inline void clear_multisig();
  static const int kMultisigFieldNumber = 7;
  inline const ::MultisigRedeemScriptType& multisig() const;
  inline ::MultisigRedeemScriptType* mutable_multisig();
  inline ::MultisigRedeemScriptType* release_multisig();
  inline void set_allocated_multisig(::MultisigRedeemScriptType* multisig);

  // @@protoc_insertion_point(class_scope:TxInputType)
 private:
  inline void set_has_prev_hash();
  inline void clear_has_prev_hash();
  inline void set_has_prev_index();
  inline void clear_has_prev_index();
  inline void set_has_script_sig();
  inline void clear_has_script_sig();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_script_type();
  inline void clear_has_script_type();
  inline void set_has_multisig();
  inline void clear_has_multisig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* prev_hash_;
  ::std::string* script_sig_;
  ::google::protobuf::uint32 prev_index_;
  ::google::protobuf::uint32 sequence_;
  ::MultisigRedeemScriptType* multisig_;
  int script_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TxInputType* default_instance_;
};
// -------------------------------------------------------------------

class TxOutputType : public ::google::protobuf::Message {
 public:
  TxOutputType();
  virtual ~TxOutputType();

  TxOutputType(const TxOutputType& from);

  inline TxOutputType& operator=(const TxOutputType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutputType& default_instance();

  void Swap(TxOutputType* other);

  // implements Message ----------------------------------------------

  TxOutputType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxOutputType& from);
  void MergeFrom(const TxOutputType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // repeated uint32 address_n = 2;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 2;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required uint64 amount = 3;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 3;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required .OutputScriptType script_type = 4;
  inline bool has_script_type() const;
  inline void clear_script_type();
  static const int kScriptTypeFieldNumber = 4;
  inline ::OutputScriptType script_type() const;
  inline void set_script_type(::OutputScriptType value);

  // optional .MultisigRedeemScriptType multisig = 5;
  inline bool has_multisig() const;
  inline void clear_multisig();
  static const int kMultisigFieldNumber = 5;
  inline const ::MultisigRedeemScriptType& multisig() const;
  inline ::MultisigRedeemScriptType* mutable_multisig();
  inline ::MultisigRedeemScriptType* release_multisig();
  inline void set_allocated_multisig(::MultisigRedeemScriptType* multisig);

  // optional bytes op_return_data = 6;
  inline bool has_op_return_data() const;
  inline void clear_op_return_data();
  static const int kOpReturnDataFieldNumber = 6;
  inline const ::std::string& op_return_data() const;
  inline void set_op_return_data(const ::std::string& value);
  inline void set_op_return_data(const char* value);
  inline void set_op_return_data(const void* value, size_t size);
  inline ::std::string* mutable_op_return_data();
  inline ::std::string* release_op_return_data();
  inline void set_allocated_op_return_data(::std::string* op_return_data);

  // @@protoc_insertion_point(class_scope:TxOutputType)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_type();
  inline void clear_has_script_type();
  inline void set_has_multisig();
  inline void clear_has_multisig();
  inline void set_has_op_return_data();
  inline void clear_has_op_return_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::google::protobuf::uint64 amount_;
  ::MultisigRedeemScriptType* multisig_;
  ::std::string* op_return_data_;
  int script_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TxOutputType* default_instance_;
};
// -------------------------------------------------------------------

class TxOutputBinType : public ::google::protobuf::Message {
 public:
  TxOutputBinType();
  virtual ~TxOutputBinType();

  TxOutputBinType(const TxOutputBinType& from);

  inline TxOutputBinType& operator=(const TxOutputBinType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxOutputBinType& default_instance();

  void Swap(TxOutputBinType* other);

  // implements Message ----------------------------------------------

  TxOutputBinType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxOutputBinType& from);
  void MergeFrom(const TxOutputBinType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 amount = 1;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 1;
  inline ::google::protobuf::uint64 amount() const;
  inline void set_amount(::google::protobuf::uint64 value);

  // required bytes script_pubkey = 2;
  inline bool has_script_pubkey() const;
  inline void clear_script_pubkey();
  static const int kScriptPubkeyFieldNumber = 2;
  inline const ::std::string& script_pubkey() const;
  inline void set_script_pubkey(const ::std::string& value);
  inline void set_script_pubkey(const char* value);
  inline void set_script_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_script_pubkey();
  inline ::std::string* release_script_pubkey();
  inline void set_allocated_script_pubkey(::std::string* script_pubkey);

  // @@protoc_insertion_point(class_scope:TxOutputBinType)
 private:
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_script_pubkey();
  inline void clear_has_script_pubkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 amount_;
  ::std::string* script_pubkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TxOutputBinType* default_instance_;
};
// -------------------------------------------------------------------

class TransactionType : public ::google::protobuf::Message {
 public:
  TransactionType();
  virtual ~TransactionType();

  TransactionType(const TransactionType& from);

  inline TransactionType& operator=(const TransactionType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionType& default_instance();

  void Swap(TransactionType* other);

  // implements Message ----------------------------------------------

  TransactionType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionType& from);
  void MergeFrom(const TransactionType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // repeated .TxInputType inputs = 2;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 2;
  inline const ::TxInputType& inputs(int index) const;
  inline ::TxInputType* mutable_inputs(int index);
  inline ::TxInputType* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxInputType >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxInputType >*
      mutable_inputs();

  // repeated .TxOutputBinType bin_outputs = 3;
  inline int bin_outputs_size() const;
  inline void clear_bin_outputs();
  static const int kBinOutputsFieldNumber = 3;
  inline const ::TxOutputBinType& bin_outputs(int index) const;
  inline ::TxOutputBinType* mutable_bin_outputs(int index);
  inline ::TxOutputBinType* add_bin_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxOutputBinType >&
      bin_outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxOutputBinType >*
      mutable_bin_outputs();

  // repeated .TxOutputType outputs = 5;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 5;
  inline const ::TxOutputType& outputs(int index) const;
  inline ::TxOutputType* mutable_outputs(int index);
  inline ::TxOutputType* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxOutputType >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxOutputType >*
      mutable_outputs();

  // optional uint32 lock_time = 4;
  inline bool has_lock_time() const;
  inline void clear_lock_time();
  static const int kLockTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 lock_time() const;
  inline void set_lock_time(::google::protobuf::uint32 value);

  // optional uint32 inputs_cnt = 6;
  inline bool has_inputs_cnt() const;
  inline void clear_inputs_cnt();
  static const int kInputsCntFieldNumber = 6;
  inline ::google::protobuf::uint32 inputs_cnt() const;
  inline void set_inputs_cnt(::google::protobuf::uint32 value);

  // optional uint32 outputs_cnt = 7;
  inline bool has_outputs_cnt() const;
  inline void clear_outputs_cnt();
  static const int kOutputsCntFieldNumber = 7;
  inline ::google::protobuf::uint32 outputs_cnt() const;
  inline void set_outputs_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TransactionType)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_lock_time();
  inline void clear_has_lock_time();
  inline void set_has_inputs_cnt();
  inline void clear_has_inputs_cnt();
  inline void set_has_outputs_cnt();
  inline void clear_has_outputs_cnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TxOutputBinType > bin_outputs_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 lock_time_;
  ::google::protobuf::RepeatedPtrField< ::TxOutputType > outputs_;
  ::google::protobuf::uint32 inputs_cnt_;
  ::google::protobuf::uint32 outputs_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TransactionType* default_instance_;
};
// -------------------------------------------------------------------

class TxRequestDetailsType : public ::google::protobuf::Message {
 public:
  TxRequestDetailsType();
  virtual ~TxRequestDetailsType();

  TxRequestDetailsType(const TxRequestDetailsType& from);

  inline TxRequestDetailsType& operator=(const TxRequestDetailsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequestDetailsType& default_instance();

  void Swap(TxRequestDetailsType* other);

  // implements Message ----------------------------------------------

  TxRequestDetailsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequestDetailsType& from);
  void MergeFrom(const TxRequestDetailsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 request_index = 1;
  inline bool has_request_index() const;
  inline void clear_request_index();
  static const int kRequestIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 request_index() const;
  inline void set_request_index(::google::protobuf::uint32 value);

  // optional bytes tx_hash = 2;
  inline bool has_tx_hash() const;
  inline void clear_tx_hash();
  static const int kTxHashFieldNumber = 2;
  inline const ::std::string& tx_hash() const;
  inline void set_tx_hash(const ::std::string& value);
  inline void set_tx_hash(const char* value);
  inline void set_tx_hash(const void* value, size_t size);
  inline ::std::string* mutable_tx_hash();
  inline ::std::string* release_tx_hash();
  inline void set_allocated_tx_hash(::std::string* tx_hash);

  // @@protoc_insertion_point(class_scope:TxRequestDetailsType)
 private:
  inline void set_has_request_index();
  inline void clear_has_request_index();
  inline void set_has_tx_hash();
  inline void clear_has_tx_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* tx_hash_;
  ::google::protobuf::uint32 request_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TxRequestDetailsType* default_instance_;
};
// -------------------------------------------------------------------

class TxRequestSerializedType : public ::google::protobuf::Message {
 public:
  TxRequestSerializedType();
  virtual ~TxRequestSerializedType();

  TxRequestSerializedType(const TxRequestSerializedType& from);

  inline TxRequestSerializedType& operator=(const TxRequestSerializedType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequestSerializedType& default_instance();

  void Swap(TxRequestSerializedType* other);

  // implements Message ----------------------------------------------

  TxRequestSerializedType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequestSerializedType& from);
  void MergeFrom(const TxRequestSerializedType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 signature_index = 1;
  inline bool has_signature_index() const;
  inline void clear_signature_index();
  static const int kSignatureIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 signature_index() const;
  inline void set_signature_index(::google::protobuf::uint32 value);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes serialized_tx = 3;
  inline bool has_serialized_tx() const;
  inline void clear_serialized_tx();
  static const int kSerializedTxFieldNumber = 3;
  inline const ::std::string& serialized_tx() const;
  inline void set_serialized_tx(const ::std::string& value);
  inline void set_serialized_tx(const char* value);
  inline void set_serialized_tx(const void* value, size_t size);
  inline ::std::string* mutable_serialized_tx();
  inline ::std::string* release_serialized_tx();
  inline void set_allocated_serialized_tx(::std::string* serialized_tx);

  // @@protoc_insertion_point(class_scope:TxRequestSerializedType)
 private:
  inline void set_has_signature_index();
  inline void clear_has_signature_index();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_serialized_tx();
  inline void clear_has_serialized_tx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* signature_;
  ::std::string* serialized_tx_;
  ::google::protobuf::uint32 signature_index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static TxRequestSerializedType* default_instance_;
};
// -------------------------------------------------------------------

class IdentityType : public ::google::protobuf::Message {
 public:
  IdentityType();
  virtual ~IdentityType();

  IdentityType(const IdentityType& from);

  inline IdentityType& operator=(const IdentityType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IdentityType& default_instance();

  void Swap(IdentityType* other);

  // implements Message ----------------------------------------------

  IdentityType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IdentityType& from);
  void MergeFrom(const IdentityType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string proto = 1;
  inline bool has_proto() const;
  inline void clear_proto();
  static const int kProtoFieldNumber = 1;
  inline const ::std::string& proto() const;
  inline void set_proto(const ::std::string& value);
  inline void set_proto(const char* value);
  inline void set_proto(const char* value, size_t size);
  inline ::std::string* mutable_proto();
  inline ::std::string* release_proto();
  inline void set_allocated_proto(::std::string* proto);

  // optional string user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // optional string host = 3;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 3;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string port = 4;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 4;
  inline const ::std::string& port() const;
  inline void set_port(const ::std::string& value);
  inline void set_port(const char* value);
  inline void set_port(const char* value, size_t size);
  inline ::std::string* mutable_port();
  inline ::std::string* release_port();
  inline void set_allocated_port(::std::string* port);

  // optional string path = 5;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 5;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional uint32 index = 6 [default = 0];
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IdentityType)
 private:
  inline void set_has_proto();
  inline void clear_has_proto();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* proto_;
  ::std::string* user_;
  ::std::string* host_;
  ::std::string* port_;
  ::std::string* path_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static IdentityType* default_instance_;
};
// -------------------------------------------------------------------

class AccountLabelsType : public ::google::protobuf::Message {
 public:
  AccountLabelsType();
  virtual ~AccountLabelsType();

  AccountLabelsType(const AccountLabelsType& from);

  inline AccountLabelsType& operator=(const AccountLabelsType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLabelsType& default_instance();

  void Swap(AccountLabelsType* other);

  // implements Message ----------------------------------------------

  AccountLabelsType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLabelsType& from);
  void MergeFrom(const AccountLabelsType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // repeated .AccountLabelType labels = 2;
  inline int labels_size() const;
  inline void clear_labels();
  static const int kLabelsFieldNumber = 2;
  inline const ::AccountLabelType& labels(int index) const;
  inline ::AccountLabelType* mutable_labels(int index);
  inline ::AccountLabelType* add_labels();
  inline const ::google::protobuf::RepeatedPtrField< ::AccountLabelType >&
      labels() const;
  inline ::google::protobuf::RepeatedPtrField< ::AccountLabelType >*
      mutable_labels();

  // @@protoc_insertion_point(class_scope:AccountLabelsType)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::AccountLabelType > labels_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static AccountLabelsType* default_instance_;
};
// -------------------------------------------------------------------

class AccountLabelType : public ::google::protobuf::Message {
 public:
  AccountLabelType();
  virtual ~AccountLabelType();

  AccountLabelType(const AccountLabelType& from);

  inline AccountLabelType& operator=(const AccountLabelType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountLabelType& default_instance();

  void Swap(AccountLabelType* other);

  // implements Message ----------------------------------------------

  AccountLabelType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountLabelType& from);
  void MergeFrom(const AccountLabelType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:AccountLabelType)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* label_;
  ::google::protobuf::uint32 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_types_2eproto();
  friend void protobuf_AssignDesc_types_2eproto();
  friend void protobuf_ShutdownFile_types_2eproto();

  void InitAsDefaultInstance();
  static AccountLabelType* default_instance_;
};
// ===================================================================

static const int kWireInFieldNumber = 50002;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_in;
static const int kWireOutFieldNumber = 50003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_out;
static const int kWireDebugInFieldNumber = 50004;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_in;
static const int kWireDebugOutFieldNumber = 50005;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_out;

// ===================================================================

// HDNodeType

// required uint32 depth = 1;
inline bool HDNodeType::has_depth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HDNodeType::set_has_depth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HDNodeType::clear_has_depth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HDNodeType::clear_depth() {
  depth_ = 0u;
  clear_has_depth();
}
inline ::google::protobuf::uint32 HDNodeType::depth() const {
  return depth_;
}
inline void HDNodeType::set_depth(::google::protobuf::uint32 value) {
  set_has_depth();
  depth_ = value;
}

// required uint32 fingerprint = 2;
inline bool HDNodeType::has_fingerprint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HDNodeType::set_has_fingerprint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HDNodeType::clear_has_fingerprint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HDNodeType::clear_fingerprint() {
  fingerprint_ = 0u;
  clear_has_fingerprint();
}
inline ::google::protobuf::uint32 HDNodeType::fingerprint() const {
  return fingerprint_;
}
inline void HDNodeType::set_fingerprint(::google::protobuf::uint32 value) {
  set_has_fingerprint();
  fingerprint_ = value;
}

// required uint32 child_num = 3;
inline bool HDNodeType::has_child_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HDNodeType::set_has_child_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HDNodeType::clear_has_child_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HDNodeType::clear_child_num() {
  child_num_ = 0u;
  clear_has_child_num();
}
inline ::google::protobuf::uint32 HDNodeType::child_num() const {
  return child_num_;
}
inline void HDNodeType::set_child_num(::google::protobuf::uint32 value) {
  set_has_child_num();
  child_num_ = value;
}

// required bytes chain_code = 4;
inline bool HDNodeType::has_chain_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HDNodeType::set_has_chain_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HDNodeType::clear_has_chain_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HDNodeType::clear_chain_code() {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    chain_code_->clear();
  }
  clear_has_chain_code();
}
inline const ::std::string& HDNodeType::chain_code() const {
  return *chain_code_;
}
inline void HDNodeType::set_chain_code(const ::std::string& value) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(value);
}
inline void HDNodeType::set_chain_code(const char* value) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(value);
}
inline void HDNodeType::set_chain_code(const void* value, size_t size) {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  chain_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HDNodeType::mutable_chain_code() {
  set_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    chain_code_ = new ::std::string;
  }
  return chain_code_;
}
inline ::std::string* HDNodeType::release_chain_code() {
  clear_has_chain_code();
  if (chain_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chain_code_;
    chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HDNodeType::set_allocated_chain_code(::std::string* chain_code) {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    delete chain_code_;
  }
  if (chain_code) {
    set_has_chain_code();
    chain_code_ = chain_code;
  } else {
    clear_has_chain_code();
    chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes private_key = 5;
inline bool HDNodeType::has_private_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HDNodeType::set_has_private_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HDNodeType::clear_has_private_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HDNodeType::clear_private_key() {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    private_key_->clear();
  }
  clear_has_private_key();
}
inline const ::std::string& HDNodeType::private_key() const {
  return *private_key_;
}
inline void HDNodeType::set_private_key(const ::std::string& value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void HDNodeType::set_private_key(const char* value) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void HDNodeType::set_private_key(const void* value, size_t size) {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HDNodeType::mutable_private_key() {
  set_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}
inline ::std::string* HDNodeType::release_private_key() {
  clear_has_private_key();
  if (private_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = private_key_;
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HDNodeType::set_allocated_private_key(::std::string* private_key) {
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (private_key) {
    set_has_private_key();
    private_key_ = private_key;
  } else {
    clear_has_private_key();
    private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes public_key = 6;
inline bool HDNodeType::has_public_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HDNodeType::set_has_public_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HDNodeType::clear_has_public_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HDNodeType::clear_public_key() {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    public_key_->clear();
  }
  clear_has_public_key();
}
inline const ::std::string& HDNodeType::public_key() const {
  return *public_key_;
}
inline void HDNodeType::set_public_key(const ::std::string& value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void HDNodeType::set_public_key(const char* value) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void HDNodeType::set_public_key(const void* value, size_t size) {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HDNodeType::mutable_public_key() {
  set_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}
inline ::std::string* HDNodeType::release_public_key() {
  clear_has_public_key();
  if (public_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = public_key_;
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void HDNodeType::set_allocated_public_key(::std::string* public_key) {
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (public_key) {
    set_has_public_key();
    public_key_ = public_key;
  } else {
    clear_has_public_key();
    public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// HDNodePathType

// required .HDNodeType node = 1;
inline bool HDNodePathType::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HDNodePathType::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HDNodePathType::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HDNodePathType::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& HDNodePathType::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* HDNodePathType::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  return node_;
}
inline ::HDNodeType* HDNodePathType::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void HDNodePathType::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// repeated uint32 address_n = 2;
inline int HDNodePathType::address_n_size() const {
  return address_n_.size();
}
inline void HDNodePathType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 HDNodePathType::address_n(int index) const {
  return address_n_.Get(index);
}
inline void HDNodePathType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void HDNodePathType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HDNodePathType::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HDNodePathType::mutable_address_n() {
  return &address_n_;
}

// -------------------------------------------------------------------

// CoinType

// optional string coin_name = 1;
inline bool CoinType::has_coin_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinType::set_has_coin_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinType::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinType::clear_coin_name() {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    coin_name_->clear();
  }
  clear_has_coin_name();
}
inline const ::std::string& CoinType::coin_name() const {
  return *coin_name_;
}
inline void CoinType::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void CoinType::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void CoinType::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinType::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    coin_name_ = new ::std::string;
  }
  return coin_name_;
}
inline ::std::string* CoinType::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinType::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string coin_shortcut = 2;
inline bool CoinType::has_coin_shortcut() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinType::set_has_coin_shortcut() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinType::clear_has_coin_shortcut() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinType::clear_coin_shortcut() {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_->clear();
  }
  clear_has_coin_shortcut();
}
inline const ::std::string& CoinType::coin_shortcut() const {
  return *coin_shortcut_;
}
inline void CoinType::set_coin_shortcut(const ::std::string& value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void CoinType::set_coin_shortcut(const char* value) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(value);
}
inline void CoinType::set_coin_shortcut(const char* value, size_t size) {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  coin_shortcut_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinType::mutable_coin_shortcut() {
  set_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    coin_shortcut_ = new ::std::string;
  }
  return coin_shortcut_;
}
inline ::std::string* CoinType::release_coin_shortcut() {
  clear_has_coin_shortcut();
  if (coin_shortcut_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = coin_shortcut_;
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinType::set_allocated_coin_shortcut(::std::string* coin_shortcut) {
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (coin_shortcut) {
    set_has_coin_shortcut();
    coin_shortcut_ = coin_shortcut;
  } else {
    clear_has_coin_shortcut();
    coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 address_type = 3 [default = 0];
inline bool CoinType::has_address_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinType::set_has_address_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinType::clear_has_address_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinType::clear_address_type() {
  address_type_ = 0u;
  clear_has_address_type();
}
inline ::google::protobuf::uint32 CoinType::address_type() const {
  return address_type_;
}
inline void CoinType::set_address_type(::google::protobuf::uint32 value) {
  set_has_address_type();
  address_type_ = value;
}

// optional uint64 maxfee_kb = 4;
inline bool CoinType::has_maxfee_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinType::set_has_maxfee_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinType::clear_has_maxfee_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinType::clear_maxfee_kb() {
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  clear_has_maxfee_kb();
}
inline ::google::protobuf::uint64 CoinType::maxfee_kb() const {
  return maxfee_kb_;
}
inline void CoinType::set_maxfee_kb(::google::protobuf::uint64 value) {
  set_has_maxfee_kb();
  maxfee_kb_ = value;
}

// optional uint32 address_type_p2sh = 5 [default = 5];
inline bool CoinType::has_address_type_p2sh() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CoinType::set_has_address_type_p2sh() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CoinType::clear_has_address_type_p2sh() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CoinType::clear_address_type_p2sh() {
  address_type_p2sh_ = 5u;
  clear_has_address_type_p2sh();
}
inline ::google::protobuf::uint32 CoinType::address_type_p2sh() const {
  return address_type_p2sh_;
}
inline void CoinType::set_address_type_p2sh(::google::protobuf::uint32 value) {
  set_has_address_type_p2sh();
  address_type_p2sh_ = value;
}

// -------------------------------------------------------------------

// MultisigRedeemScriptType

// repeated .HDNodePathType pubkeys = 1;
inline int MultisigRedeemScriptType::pubkeys_size() const {
  return pubkeys_.size();
}
inline void MultisigRedeemScriptType::clear_pubkeys() {
  pubkeys_.Clear();
}
inline const ::HDNodePathType& MultisigRedeemScriptType::pubkeys(int index) const {
  return pubkeys_.Get(index);
}
inline ::HDNodePathType* MultisigRedeemScriptType::mutable_pubkeys(int index) {
  return pubkeys_.Mutable(index);
}
inline ::HDNodePathType* MultisigRedeemScriptType::add_pubkeys() {
  return pubkeys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HDNodePathType >&
MultisigRedeemScriptType::pubkeys() const {
  return pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField< ::HDNodePathType >*
MultisigRedeemScriptType::mutable_pubkeys() {
  return &pubkeys_;
}

// repeated bytes signatures = 2;
inline int MultisigRedeemScriptType::signatures_size() const {
  return signatures_.size();
}
inline void MultisigRedeemScriptType::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& MultisigRedeemScriptType::signatures(int index) const {
  return signatures_.Get(index);
}
inline ::std::string* MultisigRedeemScriptType::mutable_signatures(int index) {
  return signatures_.Mutable(index);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const ::std::string& value) {
  signatures_.Mutable(index)->assign(value);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const char* value) {
  signatures_.Mutable(index)->assign(value);
}
inline void MultisigRedeemScriptType::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MultisigRedeemScriptType::add_signatures() {
  return signatures_.Add();
}
inline void MultisigRedeemScriptType::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
}
inline void MultisigRedeemScriptType::add_signatures(const char* value) {
  signatures_.Add()->assign(value);
}
inline void MultisigRedeemScriptType::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultisigRedeemScriptType::signatures() const {
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultisigRedeemScriptType::mutable_signatures() {
  return &signatures_;
}

// optional uint32 m = 3;
inline bool MultisigRedeemScriptType::has_m() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultisigRedeemScriptType::set_has_m() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultisigRedeemScriptType::clear_has_m() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultisigRedeemScriptType::clear_m() {
  m_ = 0u;
  clear_has_m();
}
inline ::google::protobuf::uint32 MultisigRedeemScriptType::m() const {
  return m_;
}
inline void MultisigRedeemScriptType::set_m(::google::protobuf::uint32 value) {
  set_has_m();
  m_ = value;
}

// -------------------------------------------------------------------

// TxInputType

// repeated uint32 address_n = 1;
inline int TxInputType::address_n_size() const {
  return address_n_.size();
}
inline void TxInputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxInputType::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxInputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxInputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxInputType::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxInputType::mutable_address_n() {
  return &address_n_;
}

// required bytes prev_hash = 2;
inline bool TxInputType::has_prev_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxInputType::set_has_prev_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxInputType::clear_has_prev_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxInputType::clear_prev_hash() {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    prev_hash_->clear();
  }
  clear_has_prev_hash();
}
inline const ::std::string& TxInputType::prev_hash() const {
  return *prev_hash_;
}
inline void TxInputType::set_prev_hash(const ::std::string& value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInputType::set_prev_hash(const char* value) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(value);
}
inline void TxInputType::set_prev_hash(const void* value, size_t size) {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  prev_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInputType::mutable_prev_hash() {
  set_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    prev_hash_ = new ::std::string;
  }
  return prev_hash_;
}
inline ::std::string* TxInputType::release_prev_hash() {
  clear_has_prev_hash();
  if (prev_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prev_hash_;
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxInputType::set_allocated_prev_hash(::std::string* prev_hash) {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_hash_;
  }
  if (prev_hash) {
    set_has_prev_hash();
    prev_hash_ = prev_hash;
  } else {
    clear_has_prev_hash();
    prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 prev_index = 3;
inline bool TxInputType::has_prev_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxInputType::set_has_prev_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxInputType::clear_has_prev_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxInputType::clear_prev_index() {
  prev_index_ = 0u;
  clear_has_prev_index();
}
inline ::google::protobuf::uint32 TxInputType::prev_index() const {
  return prev_index_;
}
inline void TxInputType::set_prev_index(::google::protobuf::uint32 value) {
  set_has_prev_index();
  prev_index_ = value;
}

// optional bytes script_sig = 4;
inline bool TxInputType::has_script_sig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxInputType::set_has_script_sig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxInputType::clear_has_script_sig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxInputType::clear_script_sig() {
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    script_sig_->clear();
  }
  clear_has_script_sig();
}
inline const ::std::string& TxInputType::script_sig() const {
  return *script_sig_;
}
inline void TxInputType::set_script_sig(const ::std::string& value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInputType::set_script_sig(const char* value) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(value);
}
inline void TxInputType::set_script_sig(const void* value, size_t size) {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  script_sig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxInputType::mutable_script_sig() {
  set_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    script_sig_ = new ::std::string;
  }
  return script_sig_;
}
inline ::std::string* TxInputType::release_script_sig() {
  clear_has_script_sig();
  if (script_sig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_sig_;
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxInputType::set_allocated_script_sig(::std::string* script_sig) {
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    delete script_sig_;
  }
  if (script_sig) {
    set_has_script_sig();
    script_sig_ = script_sig;
  } else {
    clear_has_script_sig();
    script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sequence = 5 [default = 4294967295];
inline bool TxInputType::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxInputType::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxInputType::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxInputType::clear_sequence() {
  sequence_ = 4294967295u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 TxInputType::sequence() const {
  return sequence_;
}
inline void TxInputType::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
inline bool TxInputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxInputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxInputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxInputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::InputScriptType TxInputType::script_type() const {
  return static_cast< ::InputScriptType >(script_type_);
}
inline void TxInputType::set_script_type(::InputScriptType value) {
  assert(::InputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
}

// optional .MultisigRedeemScriptType multisig = 7;
inline bool TxInputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TxInputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TxInputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TxInputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::MultisigRedeemScriptType& TxInputType::multisig() const {
  return multisig_ != NULL ? *multisig_ : *default_instance_->multisig_;
}
inline ::MultisigRedeemScriptType* TxInputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) multisig_ = new ::MultisigRedeemScriptType;
  return multisig_;
}
inline ::MultisigRedeemScriptType* TxInputType::release_multisig() {
  clear_has_multisig();
  ::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxInputType::set_allocated_multisig(::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
}

// -------------------------------------------------------------------

// TxOutputType

// optional string address = 1;
inline bool TxOutputType::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutputType::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutputType::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutputType::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& TxOutputType::address() const {
  return *address_;
}
inline void TxOutputType::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutputType::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void TxOutputType::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutputType::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* TxOutputType::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxOutputType::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 address_n = 2;
inline int TxOutputType::address_n_size() const {
  return address_n_.size();
}
inline void TxOutputType::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 TxOutputType::address_n(int index) const {
  return address_n_.Get(index);
}
inline void TxOutputType::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void TxOutputType::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TxOutputType::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TxOutputType::mutable_address_n() {
  return &address_n_;
}

// required uint64 amount = 3;
inline bool TxOutputType::has_amount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxOutputType::set_has_amount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxOutputType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxOutputType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutputType::amount() const {
  return amount_;
}
inline void TxOutputType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required .OutputScriptType script_type = 4;
inline bool TxOutputType::has_script_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TxOutputType::set_has_script_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TxOutputType::clear_has_script_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TxOutputType::clear_script_type() {
  script_type_ = 0;
  clear_has_script_type();
}
inline ::OutputScriptType TxOutputType::script_type() const {
  return static_cast< ::OutputScriptType >(script_type_);
}
inline void TxOutputType::set_script_type(::OutputScriptType value) {
  assert(::OutputScriptType_IsValid(value));
  set_has_script_type();
  script_type_ = value;
}

// optional .MultisigRedeemScriptType multisig = 5;
inline bool TxOutputType::has_multisig() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TxOutputType::set_has_multisig() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TxOutputType::clear_has_multisig() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TxOutputType::clear_multisig() {
  if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
  clear_has_multisig();
}
inline const ::MultisigRedeemScriptType& TxOutputType::multisig() const {
  return multisig_ != NULL ? *multisig_ : *default_instance_->multisig_;
}
inline ::MultisigRedeemScriptType* TxOutputType::mutable_multisig() {
  set_has_multisig();
  if (multisig_ == NULL) multisig_ = new ::MultisigRedeemScriptType;
  return multisig_;
}
inline ::MultisigRedeemScriptType* TxOutputType::release_multisig() {
  clear_has_multisig();
  ::MultisigRedeemScriptType* temp = multisig_;
  multisig_ = NULL;
  return temp;
}
inline void TxOutputType::set_allocated_multisig(::MultisigRedeemScriptType* multisig) {
  delete multisig_;
  multisig_ = multisig;
  if (multisig) {
    set_has_multisig();
  } else {
    clear_has_multisig();
  }
}

// optional bytes op_return_data = 6;
inline bool TxOutputType::has_op_return_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TxOutputType::set_has_op_return_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TxOutputType::clear_has_op_return_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TxOutputType::clear_op_return_data() {
  if (op_return_data_ != &::google::protobuf::internal::kEmptyString) {
    op_return_data_->clear();
  }
  clear_has_op_return_data();
}
inline const ::std::string& TxOutputType::op_return_data() const {
  return *op_return_data_;
}
inline void TxOutputType::set_op_return_data(const ::std::string& value) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::kEmptyString) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(value);
}
inline void TxOutputType::set_op_return_data(const char* value) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::kEmptyString) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(value);
}
inline void TxOutputType::set_op_return_data(const void* value, size_t size) {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::kEmptyString) {
    op_return_data_ = new ::std::string;
  }
  op_return_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutputType::mutable_op_return_data() {
  set_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::kEmptyString) {
    op_return_data_ = new ::std::string;
  }
  return op_return_data_;
}
inline ::std::string* TxOutputType::release_op_return_data() {
  clear_has_op_return_data();
  if (op_return_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = op_return_data_;
    op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxOutputType::set_allocated_op_return_data(::std::string* op_return_data) {
  if (op_return_data_ != &::google::protobuf::internal::kEmptyString) {
    delete op_return_data_;
  }
  if (op_return_data) {
    set_has_op_return_data();
    op_return_data_ = op_return_data;
  } else {
    clear_has_op_return_data();
    op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxOutputBinType

// required uint64 amount = 1;
inline bool TxOutputBinType::has_amount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxOutputBinType::set_has_amount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxOutputBinType::clear_has_amount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxOutputBinType::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
  clear_has_amount();
}
inline ::google::protobuf::uint64 TxOutputBinType::amount() const {
  return amount_;
}
inline void TxOutputBinType::set_amount(::google::protobuf::uint64 value) {
  set_has_amount();
  amount_ = value;
}

// required bytes script_pubkey = 2;
inline bool TxOutputBinType::has_script_pubkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxOutputBinType::set_has_script_pubkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxOutputBinType::clear_has_script_pubkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxOutputBinType::clear_script_pubkey() {
  if (script_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    script_pubkey_->clear();
  }
  clear_has_script_pubkey();
}
inline const ::std::string& TxOutputBinType::script_pubkey() const {
  return *script_pubkey_;
}
inline void TxOutputBinType::set_script_pubkey(const ::std::string& value) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(value);
}
inline void TxOutputBinType::set_script_pubkey(const char* value) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(value);
}
inline void TxOutputBinType::set_script_pubkey(const void* value, size_t size) {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    script_pubkey_ = new ::std::string;
  }
  script_pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxOutputBinType::mutable_script_pubkey() {
  set_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    script_pubkey_ = new ::std::string;
  }
  return script_pubkey_;
}
inline ::std::string* TxOutputBinType::release_script_pubkey() {
  clear_has_script_pubkey();
  if (script_pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_pubkey_;
    script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxOutputBinType::set_allocated_script_pubkey(::std::string* script_pubkey) {
  if (script_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete script_pubkey_;
  }
  if (script_pubkey) {
    set_has_script_pubkey();
    script_pubkey_ = script_pubkey;
  } else {
    clear_has_script_pubkey();
    script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TransactionType

// optional uint32 version = 1;
inline bool TransactionType::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionType::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionType::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionType::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 TransactionType::version() const {
  return version_;
}
inline void TransactionType::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// repeated .TxInputType inputs = 2;
inline int TransactionType::inputs_size() const {
  return inputs_.size();
}
inline void TransactionType::clear_inputs() {
  inputs_.Clear();
}
inline const ::TxInputType& TransactionType::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::TxInputType* TransactionType::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::TxInputType* TransactionType::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxInputType >&
TransactionType::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxInputType >*
TransactionType::mutable_inputs() {
  return &inputs_;
}

// repeated .TxOutputBinType bin_outputs = 3;
inline int TransactionType::bin_outputs_size() const {
  return bin_outputs_.size();
}
inline void TransactionType::clear_bin_outputs() {
  bin_outputs_.Clear();
}
inline const ::TxOutputBinType& TransactionType::bin_outputs(int index) const {
  return bin_outputs_.Get(index);
}
inline ::TxOutputBinType* TransactionType::mutable_bin_outputs(int index) {
  return bin_outputs_.Mutable(index);
}
inline ::TxOutputBinType* TransactionType::add_bin_outputs() {
  return bin_outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxOutputBinType >&
TransactionType::bin_outputs() const {
  return bin_outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxOutputBinType >*
TransactionType::mutable_bin_outputs() {
  return &bin_outputs_;
}

// repeated .TxOutputType outputs = 5;
inline int TransactionType::outputs_size() const {
  return outputs_.size();
}
inline void TransactionType::clear_outputs() {
  outputs_.Clear();
}
inline const ::TxOutputType& TransactionType::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::TxOutputType* TransactionType::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::TxOutputType* TransactionType::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxOutputType >&
TransactionType::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxOutputType >*
TransactionType::mutable_outputs() {
  return &outputs_;
}

// optional uint32 lock_time = 4;
inline bool TransactionType::has_lock_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransactionType::set_has_lock_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransactionType::clear_has_lock_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransactionType::clear_lock_time() {
  lock_time_ = 0u;
  clear_has_lock_time();
}
inline ::google::protobuf::uint32 TransactionType::lock_time() const {
  return lock_time_;
}
inline void TransactionType::set_lock_time(::google::protobuf::uint32 value) {
  set_has_lock_time();
  lock_time_ = value;
}

// optional uint32 inputs_cnt = 6;
inline bool TransactionType::has_inputs_cnt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransactionType::set_has_inputs_cnt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransactionType::clear_has_inputs_cnt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransactionType::clear_inputs_cnt() {
  inputs_cnt_ = 0u;
  clear_has_inputs_cnt();
}
inline ::google::protobuf::uint32 TransactionType::inputs_cnt() const {
  return inputs_cnt_;
}
inline void TransactionType::set_inputs_cnt(::google::protobuf::uint32 value) {
  set_has_inputs_cnt();
  inputs_cnt_ = value;
}

// optional uint32 outputs_cnt = 7;
inline bool TransactionType::has_outputs_cnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransactionType::set_has_outputs_cnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransactionType::clear_has_outputs_cnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransactionType::clear_outputs_cnt() {
  outputs_cnt_ = 0u;
  clear_has_outputs_cnt();
}
inline ::google::protobuf::uint32 TransactionType::outputs_cnt() const {
  return outputs_cnt_;
}
inline void TransactionType::set_outputs_cnt(::google::protobuf::uint32 value) {
  set_has_outputs_cnt();
  outputs_cnt_ = value;
}

// -------------------------------------------------------------------

// TxRequestDetailsType

// optional uint32 request_index = 1;
inline bool TxRequestDetailsType::has_request_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequestDetailsType::set_has_request_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequestDetailsType::clear_has_request_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequestDetailsType::clear_request_index() {
  request_index_ = 0u;
  clear_has_request_index();
}
inline ::google::protobuf::uint32 TxRequestDetailsType::request_index() const {
  return request_index_;
}
inline void TxRequestDetailsType::set_request_index(::google::protobuf::uint32 value) {
  set_has_request_index();
  request_index_ = value;
}

// optional bytes tx_hash = 2;
inline bool TxRequestDetailsType::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequestDetailsType::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequestDetailsType::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequestDetailsType::clear_tx_hash() {
  if (tx_hash_ != &::google::protobuf::internal::kEmptyString) {
    tx_hash_->clear();
  }
  clear_has_tx_hash();
}
inline const ::std::string& TxRequestDetailsType::tx_hash() const {
  return *tx_hash_;
}
inline void TxRequestDetailsType::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::kEmptyString) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
}
inline void TxRequestDetailsType::set_tx_hash(const char* value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::kEmptyString) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
}
inline void TxRequestDetailsType::set_tx_hash(const void* value, size_t size) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::kEmptyString) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequestDetailsType::mutable_tx_hash() {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::kEmptyString) {
    tx_hash_ = new ::std::string;
  }
  return tx_hash_;
}
inline ::std::string* TxRequestDetailsType::release_tx_hash() {
  clear_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tx_hash_;
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxRequestDetailsType::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete tx_hash_;
  }
  if (tx_hash) {
    set_has_tx_hash();
    tx_hash_ = tx_hash;
  } else {
    clear_has_tx_hash();
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TxRequestSerializedType

// optional uint32 signature_index = 1;
inline bool TxRequestSerializedType::has_signature_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequestSerializedType::set_has_signature_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequestSerializedType::clear_has_signature_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequestSerializedType::clear_signature_index() {
  signature_index_ = 0u;
  clear_has_signature_index();
}
inline ::google::protobuf::uint32 TxRequestSerializedType::signature_index() const {
  return signature_index_;
}
inline void TxRequestSerializedType::set_signature_index(::google::protobuf::uint32 value) {
  set_has_signature_index();
  signature_index_ = value;
}

// optional bytes signature = 2;
inline bool TxRequestSerializedType::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequestSerializedType::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequestSerializedType::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequestSerializedType::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& TxRequestSerializedType::signature() const {
  return *signature_;
}
inline void TxRequestSerializedType::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequestSerializedType::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void TxRequestSerializedType::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequestSerializedType::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* TxRequestSerializedType::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxRequestSerializedType::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes serialized_tx = 3;
inline bool TxRequestSerializedType::has_serialized_tx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequestSerializedType::set_has_serialized_tx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequestSerializedType::clear_has_serialized_tx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequestSerializedType::clear_serialized_tx() {
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    serialized_tx_->clear();
  }
  clear_has_serialized_tx();
}
inline const ::std::string& TxRequestSerializedType::serialized_tx() const {
  return *serialized_tx_;
}
inline void TxRequestSerializedType::set_serialized_tx(const ::std::string& value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequestSerializedType::set_serialized_tx(const char* value) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(value);
}
inline void TxRequestSerializedType::set_serialized_tx(const void* value, size_t size) {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  serialized_tx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TxRequestSerializedType::mutable_serialized_tx() {
  set_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    serialized_tx_ = new ::std::string;
  }
  return serialized_tx_;
}
inline ::std::string* TxRequestSerializedType::release_serialized_tx() {
  clear_has_serialized_tx();
  if (serialized_tx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialized_tx_;
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TxRequestSerializedType::set_allocated_serialized_tx(::std::string* serialized_tx) {
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_tx_;
  }
  if (serialized_tx) {
    set_has_serialized_tx();
    serialized_tx_ = serialized_tx;
  } else {
    clear_has_serialized_tx();
    serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IdentityType

// optional string proto = 1;
inline bool IdentityType::has_proto() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IdentityType::set_has_proto() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IdentityType::clear_has_proto() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IdentityType::clear_proto() {
  if (proto_ != &::google::protobuf::internal::kEmptyString) {
    proto_->clear();
  }
  clear_has_proto();
}
inline const ::std::string& IdentityType::proto() const {
  return *proto_;
}
inline void IdentityType::set_proto(const ::std::string& value) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(value);
}
inline void IdentityType::set_proto(const char* value) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(value);
}
inline void IdentityType::set_proto(const char* value, size_t size) {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  proto_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityType::mutable_proto() {
  set_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    proto_ = new ::std::string;
  }
  return proto_;
}
inline ::std::string* IdentityType::release_proto() {
  clear_has_proto();
  if (proto_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proto_;
    proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityType::set_allocated_proto(::std::string* proto) {
  if (proto_ != &::google::protobuf::internal::kEmptyString) {
    delete proto_;
  }
  if (proto) {
    set_has_proto();
    proto_ = proto;
  } else {
    clear_has_proto();
    proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string user = 2;
inline bool IdentityType::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IdentityType::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IdentityType::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IdentityType::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& IdentityType::user() const {
  return *user_;
}
inline void IdentityType::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void IdentityType::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void IdentityType::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityType::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* IdentityType::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityType::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 3;
inline bool IdentityType::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IdentityType::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IdentityType::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IdentityType::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& IdentityType::host() const {
  return *host_;
}
inline void IdentityType::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void IdentityType::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void IdentityType::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityType::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* IdentityType::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityType::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string port = 4;
inline bool IdentityType::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IdentityType::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IdentityType::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IdentityType::clear_port() {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    port_->clear();
  }
  clear_has_port();
}
inline const ::std::string& IdentityType::port() const {
  return *port_;
}
inline void IdentityType::set_port(const ::std::string& value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void IdentityType::set_port(const char* value) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(value);
}
inline void IdentityType::set_port(const char* value, size_t size) {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  port_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityType::mutable_port() {
  set_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    port_ = new ::std::string;
  }
  return port_;
}
inline ::std::string* IdentityType::release_port() {
  clear_has_port();
  if (port_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = port_;
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityType::set_allocated_port(::std::string* port) {
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    delete port_;
  }
  if (port) {
    set_has_port();
    port_ = port;
  } else {
    clear_has_port();
    port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 5;
inline bool IdentityType::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IdentityType::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IdentityType::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IdentityType::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& IdentityType::path() const {
  return *path_;
}
inline void IdentityType::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void IdentityType::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void IdentityType::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IdentityType::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* IdentityType::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IdentityType::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 6 [default = 0];
inline bool IdentityType::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IdentityType::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IdentityType::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IdentityType::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 IdentityType::index() const {
  return index_;
}
inline void IdentityType::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// AccountLabelsType

// required uint32 count = 1;
inline bool AccountLabelsType::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLabelsType::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLabelsType::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLabelsType::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 AccountLabelsType::count() const {
  return count_;
}
inline void AccountLabelsType::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// repeated .AccountLabelType labels = 2;
inline int AccountLabelsType::labels_size() const {
  return labels_.size();
}
inline void AccountLabelsType::clear_labels() {
  labels_.Clear();
}
inline const ::AccountLabelType& AccountLabelsType::labels(int index) const {
  return labels_.Get(index);
}
inline ::AccountLabelType* AccountLabelsType::mutable_labels(int index) {
  return labels_.Mutable(index);
}
inline ::AccountLabelType* AccountLabelsType::add_labels() {
  return labels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AccountLabelType >&
AccountLabelsType::labels() const {
  return labels_;
}
inline ::google::protobuf::RepeatedPtrField< ::AccountLabelType >*
AccountLabelsType::mutable_labels() {
  return &labels_;
}

// -------------------------------------------------------------------

// AccountLabelType

// required uint32 index = 1;
inline bool AccountLabelType::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountLabelType::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountLabelType::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountLabelType::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 AccountLabelType::index() const {
  return index_;
}
inline void AccountLabelType::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required string label = 2;
inline bool AccountLabelType::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountLabelType::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountLabelType::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountLabelType::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& AccountLabelType::label() const {
  return *label_;
}
inline void AccountLabelType::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void AccountLabelType::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void AccountLabelType::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountLabelType::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* AccountLabelType::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountLabelType::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::FailureType>() {
  return ::FailureType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OutputScriptType>() {
  return ::OutputScriptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::InputScriptType>() {
  return ::InputScriptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RequestType>() {
  return ::RequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ButtonRequestType>() {
  return ::ButtonRequestType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PinMatrixRequestType>() {
  return ::PinMatrixRequestType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_types_2eproto__INCLUDED
