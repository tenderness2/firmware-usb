// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "types.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* HDNodeType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HDNodeType_reflection_ = NULL;
const ::google::protobuf::Descriptor* HDNodePathType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HDNodePathType_reflection_ = NULL;
const ::google::protobuf::Descriptor* CoinType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CoinType_reflection_ = NULL;
const ::google::protobuf::Descriptor* MultisigRedeemScriptType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MultisigRedeemScriptType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxInputType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxInputType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxOutputType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxOutputType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxOutputBinType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxOutputBinType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TransactionType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TransactionType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequestDetailsType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequestDetailsType_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequestSerializedType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequestSerializedType_reflection_ = NULL;
const ::google::protobuf::Descriptor* IdentityType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IdentityType_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountLabelsType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountLabelsType_reflection_ = NULL;
const ::google::protobuf::Descriptor* AccountLabelType_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AccountLabelType_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FailureType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* OutputScriptType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RequestType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ButtonRequestType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PinMatrixRequestType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_types_2eproto() {
  protobuf_AddDesc_types_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "types.proto");
  GOOGLE_CHECK(file != NULL);
  HDNodeType_descriptor_ = file->message_type(0);
  static const int HDNodeType_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, depth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, fingerprint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, child_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, chain_code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, public_key_),
  };
  HDNodeType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HDNodeType_descriptor_,
      HDNodeType::default_instance_,
      HDNodeType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodeType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HDNodeType));
  HDNodePathType_descriptor_ = file->message_type(1);
  static const int HDNodePathType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodePathType, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodePathType, address_n_),
  };
  HDNodePathType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HDNodePathType_descriptor_,
      HDNodePathType::default_instance_,
      HDNodePathType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodePathType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HDNodePathType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HDNodePathType));
  CoinType_descriptor_ = file->message_type(2);
  static const int CoinType_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, coin_shortcut_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, address_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, maxfee_kb_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, address_type_p2sh_),
  };
  CoinType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CoinType_descriptor_,
      CoinType::default_instance_,
      CoinType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CoinType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CoinType));
  MultisigRedeemScriptType_descriptor_ = file->message_type(3);
  static const int MultisigRedeemScriptType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, pubkeys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, signatures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, m_),
  };
  MultisigRedeemScriptType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MultisigRedeemScriptType_descriptor_,
      MultisigRedeemScriptType::default_instance_,
      MultisigRedeemScriptType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MultisigRedeemScriptType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MultisigRedeemScriptType));
  TxInputType_descriptor_ = file->message_type(4);
  static const int TxInputType_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, prev_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, prev_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, script_sig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, sequence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, script_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, multisig_),
  };
  TxInputType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxInputType_descriptor_,
      TxInputType::default_instance_,
      TxInputType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxInputType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxInputType));
  TxOutputType_descriptor_ = file->message_type(5);
  static const int TxOutputType_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, script_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, multisig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, op_return_data_),
  };
  TxOutputType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxOutputType_descriptor_,
      TxOutputType::default_instance_,
      TxOutputType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxOutputType));
  TxOutputBinType_descriptor_ = file->message_type(6);
  static const int TxOutputBinType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputBinType, amount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputBinType, script_pubkey_),
  };
  TxOutputBinType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxOutputBinType_descriptor_,
      TxOutputBinType::default_instance_,
      TxOutputBinType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputBinType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxOutputBinType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxOutputBinType));
  TransactionType_descriptor_ = file->message_type(7);
  static const int TransactionType_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, bin_outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, lock_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, inputs_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, outputs_cnt_),
  };
  TransactionType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TransactionType_descriptor_,
      TransactionType::default_instance_,
      TransactionType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TransactionType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TransactionType));
  TxRequestDetailsType_descriptor_ = file->message_type(8);
  static const int TxRequestDetailsType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestDetailsType, request_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestDetailsType, tx_hash_),
  };
  TxRequestDetailsType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequestDetailsType_descriptor_,
      TxRequestDetailsType::default_instance_,
      TxRequestDetailsType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestDetailsType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestDetailsType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequestDetailsType));
  TxRequestSerializedType_descriptor_ = file->message_type(9);
  static const int TxRequestSerializedType_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestSerializedType, signature_index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestSerializedType, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestSerializedType, serialized_tx_),
  };
  TxRequestSerializedType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequestSerializedType_descriptor_,
      TxRequestSerializedType::default_instance_,
      TxRequestSerializedType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestSerializedType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequestSerializedType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequestSerializedType));
  IdentityType_descriptor_ = file->message_type(10);
  static const int IdentityType_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, proto_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, host_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, index_),
  };
  IdentityType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      IdentityType_descriptor_,
      IdentityType::default_instance_,
      IdentityType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IdentityType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(IdentityType));
  AccountLabelsType_descriptor_ = file->message_type(11);
  static const int AccountLabelsType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelsType, count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelsType, labels_),
  };
  AccountLabelsType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountLabelsType_descriptor_,
      AccountLabelsType::default_instance_,
      AccountLabelsType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelsType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelsType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountLabelsType));
  AccountLabelType_descriptor_ = file->message_type(12);
  static const int AccountLabelType_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelType, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelType, label_),
  };
  AccountLabelType_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AccountLabelType_descriptor_,
      AccountLabelType::default_instance_,
      AccountLabelType_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelType, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AccountLabelType, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AccountLabelType));
  FailureType_descriptor_ = file->enum_type(0);
  OutputScriptType_descriptor_ = file->enum_type(1);
  InputScriptType_descriptor_ = file->enum_type(2);
  RequestType_descriptor_ = file->enum_type(3);
  ButtonRequestType_descriptor_ = file->enum_type(4);
  PinMatrixRequestType_descriptor_ = file->enum_type(5);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_types_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HDNodeType_descriptor_, &HDNodeType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HDNodePathType_descriptor_, &HDNodePathType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CoinType_descriptor_, &CoinType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MultisigRedeemScriptType_descriptor_, &MultisigRedeemScriptType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxInputType_descriptor_, &TxInputType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxOutputType_descriptor_, &TxOutputType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxOutputBinType_descriptor_, &TxOutputBinType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TransactionType_descriptor_, &TransactionType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequestDetailsType_descriptor_, &TxRequestDetailsType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequestSerializedType_descriptor_, &TxRequestSerializedType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    IdentityType_descriptor_, &IdentityType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountLabelsType_descriptor_, &AccountLabelsType::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AccountLabelType_descriptor_, &AccountLabelType::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_types_2eproto() {
  delete HDNodeType::default_instance_;
  delete HDNodeType_reflection_;
  delete HDNodePathType::default_instance_;
  delete HDNodePathType_reflection_;
  delete CoinType::default_instance_;
  delete CoinType_reflection_;
  delete MultisigRedeemScriptType::default_instance_;
  delete MultisigRedeemScriptType_reflection_;
  delete TxInputType::default_instance_;
  delete TxInputType_reflection_;
  delete TxOutputType::default_instance_;
  delete TxOutputType_reflection_;
  delete TxOutputBinType::default_instance_;
  delete TxOutputBinType_reflection_;
  delete TransactionType::default_instance_;
  delete TransactionType_reflection_;
  delete TxRequestDetailsType::default_instance_;
  delete TxRequestDetailsType_reflection_;
  delete TxRequestSerializedType::default_instance_;
  delete TxRequestSerializedType_reflection_;
  delete IdentityType::default_instance_;
  delete IdentityType_reflection_;
  delete AccountLabelsType::default_instance_;
  delete AccountLabelsType_reflection_;
  delete AccountLabelType::default_instance_;
  delete AccountLabelType_reflection_;
}

void protobuf_AddDesc_types_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::protobuf_AddDesc_google_2fprotobuf_2fdescriptor_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013types.proto\032 google/protobuf/descripto"
    "r.proto\"\200\001\n\nHDNodeType\022\r\n\005depth\030\001 \002(\r\022\023\n"
    "\013fingerprint\030\002 \002(\r\022\021\n\tchild_num\030\003 \002(\r\022\022\n"
    "\nchain_code\030\004 \002(\014\022\023\n\013private_key\030\005 \001(\014\022\022"
    "\n\npublic_key\030\006 \001(\014\">\n\016HDNodePathType\022\031\n\004"
    "node\030\001 \002(\0132\013.HDNodeType\022\021\n\taddress_n\030\002 \003"
    "(\r\"~\n\010CoinType\022\021\n\tcoin_name\030\001 \001(\t\022\025\n\rcoi"
    "n_shortcut\030\002 \001(\t\022\027\n\014address_type\030\003 \001(\r:\001"
    "0\022\021\n\tmaxfee_kb\030\004 \001(\004\022\034\n\021address_type_p2s"
    "h\030\005 \001(\r:\0015\"[\n\030MultisigRedeemScriptType\022 "
    "\n\007pubkeys\030\001 \003(\0132\017.HDNodePathType\022\022\n\nsign"
    "atures\030\002 \003(\014\022\t\n\001m\030\003 \001(\r\"\333\001\n\013TxInputType\022"
    "\021\n\taddress_n\030\001 \003(\r\022\021\n\tprev_hash\030\002 \002(\014\022\022\n"
    "\nprev_index\030\003 \002(\r\022\022\n\nscript_sig\030\004 \001(\014\022\034\n"
    "\010sequence\030\005 \001(\r:\n4294967295\0223\n\013script_ty"
    "pe\030\006 \001(\0162\020.InputScriptType:\014SPENDADDRESS"
    "\022+\n\010multisig\030\007 \001(\0132\031.MultisigRedeemScrip"
    "tType\"\257\001\n\014TxOutputType\022\017\n\007address\030\001 \001(\t\022"
    "\021\n\taddress_n\030\002 \003(\r\022\016\n\006amount\030\003 \002(\004\022&\n\013sc"
    "ript_type\030\004 \002(\0162\021.OutputScriptType\022+\n\010mu"
    "ltisig\030\005 \001(\0132\031.MultisigRedeemScriptType\022"
    "\026\n\016op_return_data\030\006 \001(\014\"8\n\017TxOutputBinTy"
    "pe\022\016\n\006amount\030\001 \002(\004\022\025\n\rscript_pubkey\030\002 \002("
    "\014\"\303\001\n\017TransactionType\022\017\n\007version\030\001 \001(\r\022\034"
    "\n\006inputs\030\002 \003(\0132\014.TxInputType\022%\n\013bin_outp"
    "uts\030\003 \003(\0132\020.TxOutputBinType\022\036\n\007outputs\030\005"
    " \003(\0132\r.TxOutputType\022\021\n\tlock_time\030\004 \001(\r\022\022"
    "\n\ninputs_cnt\030\006 \001(\r\022\023\n\013outputs_cnt\030\007 \001(\r\""
    ">\n\024TxRequestDetailsType\022\025\n\rrequest_index"
    "\030\001 \001(\r\022\017\n\007tx_hash\030\002 \001(\014\"\\\n\027TxRequestSeri"
    "alizedType\022\027\n\017signature_index\030\001 \001(\r\022\021\n\ts"
    "ignature\030\002 \001(\014\022\025\n\rserialized_tx\030\003 \001(\014\"g\n"
    "\014IdentityType\022\r\n\005proto\030\001 \001(\t\022\014\n\004user\030\002 \001"
    "(\t\022\014\n\004host\030\003 \001(\t\022\014\n\004port\030\004 \001(\t\022\014\n\004path\030\005"
    " \001(\t\022\020\n\005index\030\006 \001(\r:\0010\"E\n\021AccountLabelsT"
    "ype\022\r\n\005count\030\001 \002(\r\022!\n\006labels\030\002 \003(\0132\021.Acc"
    "ountLabelType\"0\n\020AccountLabelType\022\r\n\005ind"
    "ex\030\001 \002(\r\022\r\n\005label\030\002 \002(\t*\315\002\n\013FailureType\022"
    "\035\n\031Failure_UnexpectedMessage\020\001\022\032\n\026Failur"
    "e_ButtonExpected\020\002\022\027\n\023Failure_SyntaxErro"
    "r\020\003\022\033\n\027Failure_ActionCancelled\020\004\022\027\n\023Fail"
    "ure_PinExpected\020\005\022\030\n\024Failure_PinCancelle"
    "d\020\006\022\026\n\022Failure_PinInvalid\020\007\022\034\n\030Failure_I"
    "nvalidSignature\020\010\022\021\n\rFailure_Other\020\t\022\032\n\026"
    "Failure_NotEnoughFunds\020\n\022\032\n\026Failure_NotI"
    "nitialized\020\013\022\031\n\025Failure_FirmwareError\020c*"
    "_\n\020OutputScriptType\022\020\n\014PAYTOADDRESS\020\000\022\023\n"
    "\017PAYTOSCRIPTHASH\020\001\022\021\n\rPAYTOMULTISIG\020\002\022\021\n"
    "\rPAYTOOPRETURN\020\003*6\n\017InputScriptType\022\020\n\014S"
    "PENDADDRESS\020\000\022\021\n\rSPENDMULTISIG\020\001*D\n\013Requ"
    "estType\022\013\n\007TXINPUT\020\000\022\014\n\010TXOUTPUT\020\001\022\n\n\006TX"
    "META\020\002\022\016\n\nTXFINISHED\020\003*\302\002\n\021ButtonRequest"
    "Type\022\027\n\023ButtonRequest_Other\020\001\022\"\n\036ButtonR"
    "equest_FeeOverThreshold\020\002\022\037\n\033ButtonReque"
    "st_ConfirmOutput\020\003\022\035\n\031ButtonRequest_Rese"
    "tDevice\020\004\022\035\n\031ButtonRequest_ConfirmWord\020\005"
    "\022\034\n\030ButtonRequest_WipeDevice\020\006\022\035\n\031Button"
    "Request_ProtectCall\020\007\022\030\n\024ButtonRequest_S"
    "ignTx\020\010\022\037\n\033ButtonRequest_FirmwareCheck\020\t"
    "\022\031\n\025ButtonRequest_Address\020\n*\177\n\024PinMatrix"
    "RequestType\022 \n\034PinMatrixRequestType_Curr"
    "ent\020\001\022!\n\035PinMatrixRequestType_NewFirst\020\002"
    "\022\"\n\036PinMatrixRequestType_NewSecond\020\003:4\n\007"
    "wire_in\022!.google.protobuf.EnumValueOptio"
    "ns\030\322\206\003 \001(\010:5\n\010wire_out\022!.google.protobuf"
    ".EnumValueOptions\030\323\206\003 \001(\010::\n\rwire_debug_"
    "in\022!.google.protobuf.EnumValueOptions\030\324\206"
    "\003 \001(\010:;\n\016wire_debug_out\022!.google.protobu"
    "f.EnumValueOptions\030\325\206\003 \001(\010B\'\n\030com.bdx.bw"
    "allet.protobufB\013BWalletType", 2787);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "types.proto", &protobuf_RegisterTypes);
  HDNodeType::default_instance_ = new HDNodeType();
  HDNodePathType::default_instance_ = new HDNodePathType();
  CoinType::default_instance_ = new CoinType();
  MultisigRedeemScriptType::default_instance_ = new MultisigRedeemScriptType();
  TxInputType::default_instance_ = new TxInputType();
  TxOutputType::default_instance_ = new TxOutputType();
  TxOutputBinType::default_instance_ = new TxOutputBinType();
  TransactionType::default_instance_ = new TransactionType();
  TxRequestDetailsType::default_instance_ = new TxRequestDetailsType();
  TxRequestSerializedType::default_instance_ = new TxRequestSerializedType();
  IdentityType::default_instance_ = new IdentityType();
  AccountLabelsType::default_instance_ = new AccountLabelsType();
  AccountLabelType::default_instance_ = new AccountLabelType();
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::google::protobuf::EnumValueOptions::default_instance(),
    50002, 8, false, false);
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::google::protobuf::EnumValueOptions::default_instance(),
    50003, 8, false, false);
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::google::protobuf::EnumValueOptions::default_instance(),
    50004, 8, false, false);
  ::google::protobuf::internal::ExtensionSet::RegisterExtension(
    &::google::protobuf::EnumValueOptions::default_instance(),
    50005, 8, false, false);
  HDNodeType::default_instance_->InitAsDefaultInstance();
  HDNodePathType::default_instance_->InitAsDefaultInstance();
  CoinType::default_instance_->InitAsDefaultInstance();
  MultisigRedeemScriptType::default_instance_->InitAsDefaultInstance();
  TxInputType::default_instance_->InitAsDefaultInstance();
  TxOutputType::default_instance_->InitAsDefaultInstance();
  TxOutputBinType::default_instance_->InitAsDefaultInstance();
  TransactionType::default_instance_->InitAsDefaultInstance();
  TxRequestDetailsType::default_instance_->InitAsDefaultInstance();
  TxRequestSerializedType::default_instance_->InitAsDefaultInstance();
  IdentityType::default_instance_->InitAsDefaultInstance();
  AccountLabelsType::default_instance_->InitAsDefaultInstance();
  AccountLabelType::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_types_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_types_2eproto {
  StaticDescriptorInitializer_types_2eproto() {
    protobuf_AddDesc_types_2eproto();
  }
} static_descriptor_initializer_types_2eproto_;
const ::google::protobuf::EnumDescriptor* FailureType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FailureType_descriptor_;
}
bool FailureType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 99:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OutputScriptType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OutputScriptType_descriptor_;
}
bool OutputScriptType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* InputScriptType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InputScriptType_descriptor_;
}
bool InputScriptType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RequestType_descriptor_;
}
bool RequestType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ButtonRequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonRequestType_descriptor_;
}
bool ButtonRequestType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PinMatrixRequestType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixRequestType_descriptor_;
}
bool PinMatrixRequestType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int HDNodeType::kDepthFieldNumber;
const int HDNodeType::kFingerprintFieldNumber;
const int HDNodeType::kChildNumFieldNumber;
const int HDNodeType::kChainCodeFieldNumber;
const int HDNodeType::kPrivateKeyFieldNumber;
const int HDNodeType::kPublicKeyFieldNumber;
#endif  // !_MSC_VER

HDNodeType::HDNodeType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HDNodeType::InitAsDefaultInstance() {
}

HDNodeType::HDNodeType(const HDNodeType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HDNodeType::SharedCtor() {
  _cached_size_ = 0;
  depth_ = 0u;
  fingerprint_ = 0u;
  child_num_ = 0u;
  chain_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  private_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  public_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HDNodeType::~HDNodeType() {
  SharedDtor();
}

void HDNodeType::SharedDtor() {
  if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
    delete chain_code_;
  }
  if (private_key_ != &::google::protobuf::internal::kEmptyString) {
    delete private_key_;
  }
  if (public_key_ != &::google::protobuf::internal::kEmptyString) {
    delete public_key_;
  }
  if (this != default_instance_) {
  }
}

void HDNodeType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HDNodeType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HDNodeType_descriptor_;
}

const HDNodeType& HDNodeType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

HDNodeType* HDNodeType::default_instance_ = NULL;

HDNodeType* HDNodeType::New() const {
  return new HDNodeType;
}

void HDNodeType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    depth_ = 0u;
    fingerprint_ = 0u;
    child_num_ = 0u;
    if (has_chain_code()) {
      if (chain_code_ != &::google::protobuf::internal::kEmptyString) {
        chain_code_->clear();
      }
    }
    if (has_private_key()) {
      if (private_key_ != &::google::protobuf::internal::kEmptyString) {
        private_key_->clear();
      }
    }
    if (has_public_key()) {
      if (public_key_ != &::google::protobuf::internal::kEmptyString) {
        public_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HDNodeType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 depth = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &depth_)));
          set_has_depth();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_fingerprint;
        break;
      }

      // required uint32 fingerprint = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_fingerprint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fingerprint_)));
          set_has_fingerprint();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_child_num;
        break;
      }

      // required uint32 child_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_child_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &child_num_)));
          set_has_child_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_chain_code;
        break;
      }

      // required bytes chain_code = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_chain_code:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_chain_code()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_private_key;
        break;
      }

      // optional bytes private_key = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_private_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_private_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_public_key;
        break;
      }

      // optional bytes public_key = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_public_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_public_key()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HDNodeType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 depth = 1;
  if (has_depth()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->depth(), output);
  }

  // required uint32 fingerprint = 2;
  if (has_fingerprint()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fingerprint(), output);
  }

  // required uint32 child_num = 3;
  if (has_child_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->child_num(), output);
  }

  // required bytes chain_code = 4;
  if (has_chain_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->chain_code(), output);
  }

  // optional bytes private_key = 5;
  if (has_private_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      5, this->private_key(), output);
  }

  // optional bytes public_key = 6;
  if (has_public_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->public_key(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HDNodeType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 depth = 1;
  if (has_depth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->depth(), target);
  }

  // required uint32 fingerprint = 2;
  if (has_fingerprint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->fingerprint(), target);
  }

  // required uint32 child_num = 3;
  if (has_child_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->child_num(), target);
  }

  // required bytes chain_code = 4;
  if (has_chain_code()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->chain_code(), target);
  }

  // optional bytes private_key = 5;
  if (has_private_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->private_key(), target);
  }

  // optional bytes public_key = 6;
  if (has_public_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->public_key(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HDNodeType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 depth = 1;
    if (has_depth()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->depth());
    }

    // required uint32 fingerprint = 2;
    if (has_fingerprint()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fingerprint());
    }

    // required uint32 child_num = 3;
    if (has_child_num()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->child_num());
    }

    // required bytes chain_code = 4;
    if (has_chain_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->chain_code());
    }

    // optional bytes private_key = 5;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->private_key());
    }

    // optional bytes public_key = 6;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->public_key());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HDNodeType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HDNodeType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HDNodeType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HDNodeType::MergeFrom(const HDNodeType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_depth()) {
      set_depth(from.depth());
    }
    if (from.has_fingerprint()) {
      set_fingerprint(from.fingerprint());
    }
    if (from.has_child_num()) {
      set_child_num(from.child_num());
    }
    if (from.has_chain_code()) {
      set_chain_code(from.chain_code());
    }
    if (from.has_private_key()) {
      set_private_key(from.private_key());
    }
    if (from.has_public_key()) {
      set_public_key(from.public_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HDNodeType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HDNodeType::CopyFrom(const HDNodeType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HDNodeType::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void HDNodeType::Swap(HDNodeType* other) {
  if (other != this) {
    std::swap(depth_, other->depth_);
    std::swap(fingerprint_, other->fingerprint_);
    std::swap(child_num_, other->child_num_);
    std::swap(chain_code_, other->chain_code_);
    std::swap(private_key_, other->private_key_);
    std::swap(public_key_, other->public_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HDNodeType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HDNodeType_descriptor_;
  metadata.reflection = HDNodeType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HDNodePathType::kNodeFieldNumber;
const int HDNodePathType::kAddressNFieldNumber;
#endif  // !_MSC_VER

HDNodePathType::HDNodePathType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void HDNodePathType::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

HDNodePathType::HDNodePathType(const HDNodePathType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void HDNodePathType::SharedCtor() {
  _cached_size_ = 0;
  node_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HDNodePathType::~HDNodePathType() {
  SharedDtor();
}

void HDNodePathType::SharedDtor() {
  if (this != default_instance_) {
    delete node_;
  }
}

void HDNodePathType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HDNodePathType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HDNodePathType_descriptor_;
}

const HDNodePathType& HDNodePathType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

HDNodePathType* HDNodePathType::default_instance_ = NULL;

HDNodePathType* HDNodePathType::New() const {
  return new HDNodePathType;
}

void HDNodePathType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_node()) {
      if (node_ != NULL) node_->::HDNodeType::Clear();
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HDNodePathType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HDNodeType node = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void HDNodePathType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HDNodeType node = 1;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* HDNodePathType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HDNodeType node = 1;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->address_n(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int HDNodePathType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HDNodeType node = 1;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

  }
  // repeated uint32 address_n = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HDNodePathType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HDNodePathType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HDNodePathType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HDNodePathType::MergeFrom(const HDNodePathType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HDNodePathType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HDNodePathType::CopyFrom(const HDNodePathType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HDNodePathType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void HDNodePathType::Swap(HDNodePathType* other) {
  if (other != this) {
    std::swap(node_, other->node_);
    address_n_.Swap(&other->address_n_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HDNodePathType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HDNodePathType_descriptor_;
  metadata.reflection = HDNodePathType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CoinType::kCoinNameFieldNumber;
const int CoinType::kCoinShortcutFieldNumber;
const int CoinType::kAddressTypeFieldNumber;
const int CoinType::kMaxfeeKbFieldNumber;
const int CoinType::kAddressTypeP2ShFieldNumber;
#endif  // !_MSC_VER

CoinType::CoinType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CoinType::InitAsDefaultInstance() {
}

CoinType::CoinType(const CoinType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CoinType::SharedCtor() {
  _cached_size_ = 0;
  coin_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coin_shortcut_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  address_type_ = 0u;
  maxfee_kb_ = GOOGLE_ULONGLONG(0);
  address_type_p2sh_ = 5u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CoinType::~CoinType() {
  SharedDtor();
}

void CoinType::SharedDtor() {
  if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_name_;
  }
  if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
    delete coin_shortcut_;
  }
  if (this != default_instance_) {
  }
}

void CoinType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CoinType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CoinType_descriptor_;
}

const CoinType& CoinType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

CoinType* CoinType::default_instance_ = NULL;

CoinType* CoinType::New() const {
  return new CoinType;
}

void CoinType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_coin_name()) {
      if (coin_name_ != &::google::protobuf::internal::kEmptyString) {
        coin_name_->clear();
      }
    }
    if (has_coin_shortcut()) {
      if (coin_shortcut_ != &::google::protobuf::internal::kEmptyString) {
        coin_shortcut_->clear();
      }
    }
    address_type_ = 0u;
    maxfee_kb_ = GOOGLE_ULONGLONG(0);
    address_type_p2sh_ = 5u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CoinType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string coin_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_coin_shortcut;
        break;
      }

      // optional string coin_shortcut = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_shortcut:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_shortcut()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_shortcut().data(), this->coin_shortcut().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_address_type;
        break;
      }

      // optional uint32 address_type = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_type_)));
          set_has_address_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_maxfee_kb;
        break;
      }

      // optional uint64 maxfee_kb = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maxfee_kb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &maxfee_kb_)));
          set_has_maxfee_kb();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_address_type_p2sh;
        break;
      }

      // optional uint32 address_type_p2sh = 5 [default = 5];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_type_p2sh:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &address_type_p2sh_)));
          set_has_address_type_p2sh();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CoinType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string coin_name = 1;
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->coin_name(), output);
  }

  // optional string coin_shortcut = 2;
  if (has_coin_shortcut()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_shortcut().data(), this->coin_shortcut().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->coin_shortcut(), output);
  }

  // optional uint32 address_type = 3 [default = 0];
  if (has_address_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->address_type(), output);
  }

  // optional uint64 maxfee_kb = 4;
  if (has_maxfee_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->maxfee_kb(), output);
  }

  // optional uint32 address_type_p2sh = 5 [default = 5];
  if (has_address_type_p2sh()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->address_type_p2sh(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CoinType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string coin_name = 1;
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->coin_name(), target);
  }

  // optional string coin_shortcut = 2;
  if (has_coin_shortcut()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_shortcut().data(), this->coin_shortcut().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->coin_shortcut(), target);
  }

  // optional uint32 address_type = 3 [default = 0];
  if (has_address_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->address_type(), target);
  }

  // optional uint64 maxfee_kb = 4;
  if (has_maxfee_kb()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->maxfee_kb(), target);
  }

  // optional uint32 address_type_p2sh = 5 [default = 5];
  if (has_address_type_p2sh()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->address_type_p2sh(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CoinType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string coin_name = 1;
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional string coin_shortcut = 2;
    if (has_coin_shortcut()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_shortcut());
    }

    // optional uint32 address_type = 3 [default = 0];
    if (has_address_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address_type());
    }

    // optional uint64 maxfee_kb = 4;
    if (has_maxfee_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->maxfee_kb());
    }

    // optional uint32 address_type_p2sh = 5 [default = 5];
    if (has_address_type_p2sh()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->address_type_p2sh());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CoinType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CoinType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CoinType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CoinType::MergeFrom(const CoinType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_coin_shortcut()) {
      set_coin_shortcut(from.coin_shortcut());
    }
    if (from.has_address_type()) {
      set_address_type(from.address_type());
    }
    if (from.has_maxfee_kb()) {
      set_maxfee_kb(from.maxfee_kb());
    }
    if (from.has_address_type_p2sh()) {
      set_address_type_p2sh(from.address_type_p2sh());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CoinType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CoinType::CopyFrom(const CoinType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoinType::IsInitialized() const {

  return true;
}

void CoinType::Swap(CoinType* other) {
  if (other != this) {
    std::swap(coin_name_, other->coin_name_);
    std::swap(coin_shortcut_, other->coin_shortcut_);
    std::swap(address_type_, other->address_type_);
    std::swap(maxfee_kb_, other->maxfee_kb_);
    std::swap(address_type_p2sh_, other->address_type_p2sh_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CoinType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CoinType_descriptor_;
  metadata.reflection = CoinType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MultisigRedeemScriptType::kPubkeysFieldNumber;
const int MultisigRedeemScriptType::kSignaturesFieldNumber;
const int MultisigRedeemScriptType::kMFieldNumber;
#endif  // !_MSC_VER

MultisigRedeemScriptType::MultisigRedeemScriptType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MultisigRedeemScriptType::InitAsDefaultInstance() {
}

MultisigRedeemScriptType::MultisigRedeemScriptType(const MultisigRedeemScriptType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MultisigRedeemScriptType::SharedCtor() {
  _cached_size_ = 0;
  m_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MultisigRedeemScriptType::~MultisigRedeemScriptType() {
  SharedDtor();
}

void MultisigRedeemScriptType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MultisigRedeemScriptType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MultisigRedeemScriptType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MultisigRedeemScriptType_descriptor_;
}

const MultisigRedeemScriptType& MultisigRedeemScriptType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

MultisigRedeemScriptType* MultisigRedeemScriptType::default_instance_ = NULL;

MultisigRedeemScriptType* MultisigRedeemScriptType::New() const {
  return new MultisigRedeemScriptType;
}

void MultisigRedeemScriptType::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    m_ = 0u;
  }
  pubkeys_.Clear();
  signatures_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MultisigRedeemScriptType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .HDNodePathType pubkeys = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pubkeys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pubkeys()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_pubkeys;
        if (input->ExpectTag(18)) goto parse_signatures;
        break;
      }

      // repeated bytes signatures = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signatures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_signatures()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signatures;
        if (input->ExpectTag(24)) goto parse_m;
        break;
      }

      // optional uint32 m = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_m:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &m_)));
          set_has_m();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MultisigRedeemScriptType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .HDNodePathType pubkeys = 1;
  for (int i = 0; i < this->pubkeys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pubkeys(i), output);
  }

  // repeated bytes signatures = 2;
  for (int i = 0; i < this->signatures_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signatures(i), output);
  }

  // optional uint32 m = 3;
  if (has_m()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->m(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MultisigRedeemScriptType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .HDNodePathType pubkeys = 1;
  for (int i = 0; i < this->pubkeys_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pubkeys(i), target);
  }

  // repeated bytes signatures = 2;
  for (int i = 0; i < this->signatures_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->signatures(i), target);
  }

  // optional uint32 m = 3;
  if (has_m()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->m(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MultisigRedeemScriptType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional uint32 m = 3;
    if (has_m()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->m());
    }

  }
  // repeated .HDNodePathType pubkeys = 1;
  total_size += 1 * this->pubkeys_size();
  for (int i = 0; i < this->pubkeys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pubkeys(i));
  }

  // repeated bytes signatures = 2;
  total_size += 1 * this->signatures_size();
  for (int i = 0; i < this->signatures_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->signatures(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MultisigRedeemScriptType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MultisigRedeemScriptType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MultisigRedeemScriptType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MultisigRedeemScriptType::MergeFrom(const MultisigRedeemScriptType& from) {
  GOOGLE_CHECK_NE(&from, this);
  pubkeys_.MergeFrom(from.pubkeys_);
  signatures_.MergeFrom(from.signatures_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_m()) {
      set_m(from.m());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MultisigRedeemScriptType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MultisigRedeemScriptType::CopyFrom(const MultisigRedeemScriptType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MultisigRedeemScriptType::IsInitialized() const {

  for (int i = 0; i < pubkeys_size(); i++) {
    if (!this->pubkeys(i).IsInitialized()) return false;
  }
  return true;
}

void MultisigRedeemScriptType::Swap(MultisigRedeemScriptType* other) {
  if (other != this) {
    pubkeys_.Swap(&other->pubkeys_);
    signatures_.Swap(&other->signatures_);
    std::swap(m_, other->m_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MultisigRedeemScriptType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MultisigRedeemScriptType_descriptor_;
  metadata.reflection = MultisigRedeemScriptType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxInputType::kAddressNFieldNumber;
const int TxInputType::kPrevHashFieldNumber;
const int TxInputType::kPrevIndexFieldNumber;
const int TxInputType::kScriptSigFieldNumber;
const int TxInputType::kSequenceFieldNumber;
const int TxInputType::kScriptTypeFieldNumber;
const int TxInputType::kMultisigFieldNumber;
#endif  // !_MSC_VER

TxInputType::TxInputType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxInputType::InitAsDefaultInstance() {
  multisig_ = const_cast< ::MultisigRedeemScriptType*>(&::MultisigRedeemScriptType::default_instance());
}

TxInputType::TxInputType(const TxInputType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxInputType::SharedCtor() {
  _cached_size_ = 0;
  prev_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  prev_index_ = 0u;
  script_sig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  sequence_ = 4294967295u;
  script_type_ = 0;
  multisig_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxInputType::~TxInputType() {
  SharedDtor();
}

void TxInputType::SharedDtor() {
  if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete prev_hash_;
  }
  if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
    delete script_sig_;
  }
  if (this != default_instance_) {
    delete multisig_;
  }
}

void TxInputType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxInputType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxInputType_descriptor_;
}

const TxInputType& TxInputType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TxInputType* TxInputType::default_instance_ = NULL;

TxInputType* TxInputType::New() const {
  return new TxInputType;
}

void TxInputType::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_prev_hash()) {
      if (prev_hash_ != &::google::protobuf::internal::kEmptyString) {
        prev_hash_->clear();
      }
    }
    prev_index_ = 0u;
    if (has_script_sig()) {
      if (script_sig_ != &::google::protobuf::internal::kEmptyString) {
        script_sig_->clear();
      }
    }
    sequence_ = 4294967295u;
    script_type_ = 0;
    if (has_multisig()) {
      if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxInputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_prev_hash;
        break;
      }

      // required bytes prev_hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_prev_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_prev_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_prev_index;
        break;
      }

      // required uint32 prev_index = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_prev_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prev_index_)));
          set_has_prev_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_script_sig;
        break;
      }

      // optional bytes script_sig = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_sig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_sig()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_sequence;
        break;
      }

      // optional uint32 sequence = 5 [default = 4294967295];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sequence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sequence_)));
          set_has_sequence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_script_type;
        break;
      }

      // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::InputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::InputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_multisig;
        break;
      }

      // optional .MultisigRedeemScriptType multisig = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_multisig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxInputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // required bytes prev_hash = 2;
  if (has_prev_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->prev_hash(), output);
  }

  // required uint32 prev_index = 3;
  if (has_prev_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->prev_index(), output);
  }

  // optional bytes script_sig = 4;
  if (has_script_sig()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->script_sig(), output);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (has_sequence()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->sequence(), output);
  }

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->script_type(), output);
  }

  // optional .MultisigRedeemScriptType multisig = 7;
  if (has_multisig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->multisig(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxInputType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // required bytes prev_hash = 2;
  if (has_prev_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->prev_hash(), target);
  }

  // required uint32 prev_index = 3;
  if (has_prev_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->prev_index(), target);
  }

  // optional bytes script_sig = 4;
  if (has_script_sig()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->script_sig(), target);
  }

  // optional uint32 sequence = 5 [default = 4294967295];
  if (has_sequence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->sequence(), target);
  }

  // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->script_type(), target);
  }

  // optional .MultisigRedeemScriptType multisig = 7;
  if (has_multisig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->multisig(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxInputType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes prev_hash = 2;
    if (has_prev_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->prev_hash());
    }

    // required uint32 prev_index = 3;
    if (has_prev_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prev_index());
    }

    // optional bytes script_sig = 4;
    if (has_script_sig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_sig());
    }

    // optional uint32 sequence = 5 [default = 4294967295];
    if (has_sequence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sequence());
    }

    // optional .InputScriptType script_type = 6 [default = SPENDADDRESS];
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

    // optional .MultisigRedeemScriptType multisig = 7;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->multisig());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxInputType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxInputType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxInputType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxInputType::MergeFrom(const TxInputType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_prev_hash()) {
      set_prev_hash(from.prev_hash());
    }
    if (from.has_prev_index()) {
      set_prev_index(from.prev_index());
    }
    if (from.has_script_sig()) {
      set_script_sig(from.script_sig());
    }
    if (from.has_sequence()) {
      set_sequence(from.sequence());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
    if (from.has_multisig()) {
      mutable_multisig()->::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxInputType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxInputType::CopyFrom(const TxInputType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxInputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_multisig()) {
    if (!this->multisig().IsInitialized()) return false;
  }
  return true;
}

void TxInputType::Swap(TxInputType* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(prev_hash_, other->prev_hash_);
    std::swap(prev_index_, other->prev_index_);
    std::swap(script_sig_, other->script_sig_);
    std::swap(sequence_, other->sequence_);
    std::swap(script_type_, other->script_type_);
    std::swap(multisig_, other->multisig_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxInputType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxInputType_descriptor_;
  metadata.reflection = TxInputType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxOutputType::kAddressFieldNumber;
const int TxOutputType::kAddressNFieldNumber;
const int TxOutputType::kAmountFieldNumber;
const int TxOutputType::kScriptTypeFieldNumber;
const int TxOutputType::kMultisigFieldNumber;
const int TxOutputType::kOpReturnDataFieldNumber;
#endif  // !_MSC_VER

TxOutputType::TxOutputType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxOutputType::InitAsDefaultInstance() {
  multisig_ = const_cast< ::MultisigRedeemScriptType*>(&::MultisigRedeemScriptType::default_instance());
}

TxOutputType::TxOutputType(const TxOutputType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxOutputType::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  amount_ = GOOGLE_ULONGLONG(0);
  script_type_ = 0;
  multisig_ = NULL;
  op_return_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxOutputType::~TxOutputType() {
  SharedDtor();
}

void TxOutputType::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (op_return_data_ != &::google::protobuf::internal::kEmptyString) {
    delete op_return_data_;
  }
  if (this != default_instance_) {
    delete multisig_;
  }
}

void TxOutputType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxOutputType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxOutputType_descriptor_;
}

const TxOutputType& TxOutputType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TxOutputType* TxOutputType::default_instance_ = NULL;

TxOutputType* TxOutputType::New() const {
  return new TxOutputType;
}

void TxOutputType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    amount_ = GOOGLE_ULONGLONG(0);
    script_type_ = 0;
    if (has_multisig()) {
      if (multisig_ != NULL) multisig_->::MultisigRedeemScriptType::Clear();
    }
    if (has_op_return_data()) {
      if (op_return_data_ != &::google::protobuf::internal::kEmptyString) {
        op_return_data_->clear();
      }
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxOutputType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_address_n;
        if (input->ExpectTag(24)) goto parse_amount;
        break;
      }

      // required uint64 amount = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_amount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_script_type;
        break;
      }

      // required .OutputScriptType script_type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_script_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::OutputScriptType_IsValid(value)) {
            set_script_type(static_cast< ::OutputScriptType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_multisig;
        break;
      }

      // optional .MultisigRedeemScriptType multisig = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_multisig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_multisig()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_op_return_data;
        break;
      }

      // optional bytes op_return_data = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_op_return_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_op_return_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxOutputType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->address(), output);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->address_n(i), output);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->amount(), output);
  }

  // required .OutputScriptType script_type = 4;
  if (has_script_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->script_type(), output);
  }

  // optional .MultisigRedeemScriptType multisig = 5;
  if (has_multisig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->multisig(), output);
  }

  // optional bytes op_return_data = 6;
  if (has_op_return_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      6, this->op_return_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxOutputType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // repeated uint32 address_n = 2;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(2, this->address_n(i), target);
  }

  // required uint64 amount = 3;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->amount(), target);
  }

  // required .OutputScriptType script_type = 4;
  if (has_script_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->script_type(), target);
  }

  // optional .MultisigRedeemScriptType multisig = 5;
  if (has_multisig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->multisig(), target);
  }

  // optional bytes op_return_data = 6;
  if (has_op_return_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->op_return_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxOutputType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // required uint64 amount = 3;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required .OutputScriptType script_type = 4;
    if (has_script_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->script_type());
    }

    // optional .MultisigRedeemScriptType multisig = 5;
    if (has_multisig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->multisig());
    }

    // optional bytes op_return_data = 6;
    if (has_op_return_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->op_return_data());
    }

  }
  // repeated uint32 address_n = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxOutputType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxOutputType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxOutputType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxOutputType::MergeFrom(const TxOutputType& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_script_type()) {
      set_script_type(from.script_type());
    }
    if (from.has_multisig()) {
      mutable_multisig()->::MultisigRedeemScriptType::MergeFrom(from.multisig());
    }
    if (from.has_op_return_data()) {
      set_op_return_data(from.op_return_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxOutputType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxOutputType::CopyFrom(const TxOutputType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxOutputType::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000c) != 0x0000000c) return false;

  if (has_multisig()) {
    if (!this->multisig().IsInitialized()) return false;
  }
  return true;
}

void TxOutputType::Swap(TxOutputType* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    address_n_.Swap(&other->address_n_);
    std::swap(amount_, other->amount_);
    std::swap(script_type_, other->script_type_);
    std::swap(multisig_, other->multisig_);
    std::swap(op_return_data_, other->op_return_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxOutputType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxOutputType_descriptor_;
  metadata.reflection = TxOutputType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxOutputBinType::kAmountFieldNumber;
const int TxOutputBinType::kScriptPubkeyFieldNumber;
#endif  // !_MSC_VER

TxOutputBinType::TxOutputBinType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxOutputBinType::InitAsDefaultInstance() {
}

TxOutputBinType::TxOutputBinType(const TxOutputBinType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxOutputBinType::SharedCtor() {
  _cached_size_ = 0;
  amount_ = GOOGLE_ULONGLONG(0);
  script_pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxOutputBinType::~TxOutputBinType() {
  SharedDtor();
}

void TxOutputBinType::SharedDtor() {
  if (script_pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete script_pubkey_;
  }
  if (this != default_instance_) {
  }
}

void TxOutputBinType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxOutputBinType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxOutputBinType_descriptor_;
}

const TxOutputBinType& TxOutputBinType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TxOutputBinType* TxOutputBinType::default_instance_ = NULL;

TxOutputBinType* TxOutputBinType::New() const {
  return new TxOutputBinType;
}

void TxOutputBinType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    amount_ = GOOGLE_ULONGLONG(0);
    if (has_script_pubkey()) {
      if (script_pubkey_ != &::google::protobuf::internal::kEmptyString) {
        script_pubkey_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxOutputBinType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 amount = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &amount_)));
          set_has_amount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_script_pubkey;
        break;
      }

      // required bytes script_pubkey = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_script_pubkey:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_script_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxOutputBinType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint64 amount = 1;
  if (has_amount()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->amount(), output);
  }

  // required bytes script_pubkey = 2;
  if (has_script_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->script_pubkey(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxOutputBinType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint64 amount = 1;
  if (has_amount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->amount(), target);
  }

  // required bytes script_pubkey = 2;
  if (has_script_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->script_pubkey(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxOutputBinType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 amount = 1;
    if (has_amount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->amount());
    }

    // required bytes script_pubkey = 2;
    if (has_script_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->script_pubkey());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxOutputBinType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxOutputBinType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxOutputBinType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxOutputBinType::MergeFrom(const TxOutputBinType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_amount()) {
      set_amount(from.amount());
    }
    if (from.has_script_pubkey()) {
      set_script_pubkey(from.script_pubkey());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxOutputBinType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxOutputBinType::CopyFrom(const TxOutputBinType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxOutputBinType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TxOutputBinType::Swap(TxOutputBinType* other) {
  if (other != this) {
    std::swap(amount_, other->amount_);
    std::swap(script_pubkey_, other->script_pubkey_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxOutputBinType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxOutputBinType_descriptor_;
  metadata.reflection = TxOutputBinType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TransactionType::kVersionFieldNumber;
const int TransactionType::kInputsFieldNumber;
const int TransactionType::kBinOutputsFieldNumber;
const int TransactionType::kOutputsFieldNumber;
const int TransactionType::kLockTimeFieldNumber;
const int TransactionType::kInputsCntFieldNumber;
const int TransactionType::kOutputsCntFieldNumber;
#endif  // !_MSC_VER

TransactionType::TransactionType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TransactionType::InitAsDefaultInstance() {
}

TransactionType::TransactionType(const TransactionType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TransactionType::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0u;
  lock_time_ = 0u;
  inputs_cnt_ = 0u;
  outputs_cnt_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TransactionType::~TransactionType() {
  SharedDtor();
}

void TransactionType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TransactionType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TransactionType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TransactionType_descriptor_;
}

const TransactionType& TransactionType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TransactionType* TransactionType::default_instance_ = NULL;

TransactionType* TransactionType::New() const {
  return new TransactionType;
}

void TransactionType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    version_ = 0u;
    lock_time_ = 0u;
    inputs_cnt_ = 0u;
    outputs_cnt_ = 0u;
  }
  inputs_.Clear();
  bin_outputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TransactionType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 version = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        break;
      }

      // repeated .TxInputType inputs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_inputs;
        if (input->ExpectTag(26)) goto parse_bin_outputs;
        break;
      }

      // repeated .TxOutputBinType bin_outputs = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bin_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_bin_outputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bin_outputs;
        if (input->ExpectTag(32)) goto parse_lock_time;
        break;
      }

      // optional uint32 lock_time = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_lock_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lock_time_)));
          set_has_lock_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_outputs;
        break;
      }

      // repeated .TxOutputType outputs = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_outputs;
        if (input->ExpectTag(48)) goto parse_inputs_cnt;
        break;
      }

      // optional uint32 inputs_cnt = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inputs_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_cnt_)));
          set_has_inputs_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_outputs_cnt;
        break;
      }

      // optional uint32 outputs_cnt = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_outputs_cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_cnt_)));
          set_has_outputs_cnt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TransactionType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->version(), output);
  }

  // repeated .TxInputType inputs = 2;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->inputs(i), output);
  }

  // repeated .TxOutputBinType bin_outputs = 3;
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->bin_outputs(i), output);
  }

  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->lock_time(), output);
  }

  // repeated .TxOutputType outputs = 5;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->outputs(i), output);
  }

  // optional uint32 inputs_cnt = 6;
  if (has_inputs_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->inputs_cnt(), output);
  }

  // optional uint32 outputs_cnt = 7;
  if (has_outputs_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->outputs_cnt(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TransactionType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->version(), target);
  }

  // repeated .TxInputType inputs = 2;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->inputs(i), target);
  }

  // repeated .TxOutputBinType bin_outputs = 3;
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->bin_outputs(i), target);
  }

  // optional uint32 lock_time = 4;
  if (has_lock_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->lock_time(), target);
  }

  // repeated .TxOutputType outputs = 5;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->outputs(i), target);
  }

  // optional uint32 inputs_cnt = 6;
  if (has_inputs_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->inputs_cnt(), target);
  }

  // optional uint32 outputs_cnt = 7;
  if (has_outputs_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->outputs_cnt(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TransactionType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 lock_time = 4;
    if (has_lock_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lock_time());
    }

    // optional uint32 inputs_cnt = 6;
    if (has_inputs_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_cnt());
    }

    // optional uint32 outputs_cnt = 7;
    if (has_outputs_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_cnt());
    }

  }
  // repeated .TxInputType inputs = 2;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inputs(i));
  }

  // repeated .TxOutputBinType bin_outputs = 3;
  total_size += 1 * this->bin_outputs_size();
  for (int i = 0; i < this->bin_outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->bin_outputs(i));
  }

  // repeated .TxOutputType outputs = 5;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TransactionType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TransactionType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TransactionType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TransactionType::MergeFrom(const TransactionType& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  bin_outputs_.MergeFrom(from.bin_outputs_);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_lock_time()) {
      set_lock_time(from.lock_time());
    }
    if (from.has_inputs_cnt()) {
      set_inputs_cnt(from.inputs_cnt());
    }
    if (from.has_outputs_cnt()) {
      set_outputs_cnt(from.outputs_cnt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TransactionType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TransactionType::CopyFrom(const TransactionType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionType::IsInitialized() const {

  for (int i = 0; i < inputs_size(); i++) {
    if (!this->inputs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < bin_outputs_size(); i++) {
    if (!this->bin_outputs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < outputs_size(); i++) {
    if (!this->outputs(i).IsInitialized()) return false;
  }
  return true;
}

void TransactionType::Swap(TransactionType* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    inputs_.Swap(&other->inputs_);
    bin_outputs_.Swap(&other->bin_outputs_);
    outputs_.Swap(&other->outputs_);
    std::swap(lock_time_, other->lock_time_);
    std::swap(inputs_cnt_, other->inputs_cnt_);
    std::swap(outputs_cnt_, other->outputs_cnt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TransactionType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TransactionType_descriptor_;
  metadata.reflection = TransactionType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxRequestDetailsType::kRequestIndexFieldNumber;
const int TxRequestDetailsType::kTxHashFieldNumber;
#endif  // !_MSC_VER

TxRequestDetailsType::TxRequestDetailsType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxRequestDetailsType::InitAsDefaultInstance() {
}

TxRequestDetailsType::TxRequestDetailsType(const TxRequestDetailsType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxRequestDetailsType::SharedCtor() {
  _cached_size_ = 0;
  request_index_ = 0u;
  tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequestDetailsType::~TxRequestDetailsType() {
  SharedDtor();
}

void TxRequestDetailsType::SharedDtor() {
  if (tx_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete tx_hash_;
  }
  if (this != default_instance_) {
  }
}

void TxRequestDetailsType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequestDetailsType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequestDetailsType_descriptor_;
}

const TxRequestDetailsType& TxRequestDetailsType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TxRequestDetailsType* TxRequestDetailsType::default_instance_ = NULL;

TxRequestDetailsType* TxRequestDetailsType::New() const {
  return new TxRequestDetailsType;
}

void TxRequestDetailsType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    request_index_ = 0u;
    if (has_tx_hash()) {
      if (tx_hash_ != &::google::protobuf::internal::kEmptyString) {
        tx_hash_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequestDetailsType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 request_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &request_index_)));
          set_has_request_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_tx_hash;
        break;
      }

      // optional bytes tx_hash = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_tx_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tx_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxRequestDetailsType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 request_index = 1;
  if (has_request_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->request_index(), output);
  }

  // optional bytes tx_hash = 2;
  if (has_tx_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->tx_hash(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxRequestDetailsType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 request_index = 1;
  if (has_request_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->request_index(), target);
  }

  // optional bytes tx_hash = 2;
  if (has_tx_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->tx_hash(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxRequestDetailsType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 request_index = 1;
    if (has_request_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->request_index());
    }

    // optional bytes tx_hash = 2;
    if (has_tx_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tx_hash());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequestDetailsType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequestDetailsType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequestDetailsType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequestDetailsType::MergeFrom(const TxRequestDetailsType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_index()) {
      set_request_index(from.request_index());
    }
    if (from.has_tx_hash()) {
      set_tx_hash(from.tx_hash());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequestDetailsType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequestDetailsType::CopyFrom(const TxRequestDetailsType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequestDetailsType::IsInitialized() const {

  return true;
}

void TxRequestDetailsType::Swap(TxRequestDetailsType* other) {
  if (other != this) {
    std::swap(request_index_, other->request_index_);
    std::swap(tx_hash_, other->tx_hash_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequestDetailsType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequestDetailsType_descriptor_;
  metadata.reflection = TxRequestDetailsType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxRequestSerializedType::kSignatureIndexFieldNumber;
const int TxRequestSerializedType::kSignatureFieldNumber;
const int TxRequestSerializedType::kSerializedTxFieldNumber;
#endif  // !_MSC_VER

TxRequestSerializedType::TxRequestSerializedType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxRequestSerializedType::InitAsDefaultInstance() {
}

TxRequestSerializedType::TxRequestSerializedType(const TxRequestSerializedType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxRequestSerializedType::SharedCtor() {
  _cached_size_ = 0;
  signature_index_ = 0u;
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  serialized_tx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequestSerializedType::~TxRequestSerializedType() {
  SharedDtor();
}

void TxRequestSerializedType::SharedDtor() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
    delete serialized_tx_;
  }
  if (this != default_instance_) {
  }
}

void TxRequestSerializedType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequestSerializedType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequestSerializedType_descriptor_;
}

const TxRequestSerializedType& TxRequestSerializedType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

TxRequestSerializedType* TxRequestSerializedType::default_instance_ = NULL;

TxRequestSerializedType* TxRequestSerializedType::New() const {
  return new TxRequestSerializedType;
}

void TxRequestSerializedType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    signature_index_ = 0u;
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_serialized_tx()) {
      if (serialized_tx_ != &::google::protobuf::internal::kEmptyString) {
        serialized_tx_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequestSerializedType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 signature_index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &signature_index_)));
          set_has_signature_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_serialized_tx;
        break;
      }

      // optional bytes serialized_tx = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialized_tx:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_serialized_tx()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxRequestSerializedType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 signature_index = 1;
  if (has_signature_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->signature_index(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signature(), output);
  }

  // optional bytes serialized_tx = 3;
  if (has_serialized_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->serialized_tx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxRequestSerializedType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 signature_index = 1;
  if (has_signature_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->signature_index(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes serialized_tx = 3;
  if (has_serialized_tx()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->serialized_tx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxRequestSerializedType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 signature_index = 1;
    if (has_signature_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->signature_index());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes serialized_tx = 3;
    if (has_serialized_tx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->serialized_tx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequestSerializedType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequestSerializedType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequestSerializedType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequestSerializedType::MergeFrom(const TxRequestSerializedType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_signature_index()) {
      set_signature_index(from.signature_index());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_serialized_tx()) {
      set_serialized_tx(from.serialized_tx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequestSerializedType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequestSerializedType::CopyFrom(const TxRequestSerializedType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequestSerializedType::IsInitialized() const {

  return true;
}

void TxRequestSerializedType::Swap(TxRequestSerializedType* other) {
  if (other != this) {
    std::swap(signature_index_, other->signature_index_);
    std::swap(signature_, other->signature_);
    std::swap(serialized_tx_, other->serialized_tx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequestSerializedType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequestSerializedType_descriptor_;
  metadata.reflection = TxRequestSerializedType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int IdentityType::kProtoFieldNumber;
const int IdentityType::kUserFieldNumber;
const int IdentityType::kHostFieldNumber;
const int IdentityType::kPortFieldNumber;
const int IdentityType::kPathFieldNumber;
const int IdentityType::kIndexFieldNumber;
#endif  // !_MSC_VER

IdentityType::IdentityType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void IdentityType::InitAsDefaultInstance() {
}

IdentityType::IdentityType(const IdentityType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void IdentityType::SharedCtor() {
  _cached_size_ = 0;
  proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  port_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  index_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IdentityType::~IdentityType() {
  SharedDtor();
}

void IdentityType::SharedDtor() {
  if (proto_ != &::google::protobuf::internal::kEmptyString) {
    delete proto_;
  }
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (port_ != &::google::protobuf::internal::kEmptyString) {
    delete port_;
  }
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (this != default_instance_) {
  }
}

void IdentityType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IdentityType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IdentityType_descriptor_;
}

const IdentityType& IdentityType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

IdentityType* IdentityType::default_instance_ = NULL;

IdentityType* IdentityType::New() const {
  return new IdentityType;
}

void IdentityType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_proto()) {
      if (proto_ != &::google::protobuf::internal::kEmptyString) {
        proto_->clear();
      }
    }
    if (has_user()) {
      if (user_ != &::google::protobuf::internal::kEmptyString) {
        user_->clear();
      }
    }
    if (has_host()) {
      if (host_ != &::google::protobuf::internal::kEmptyString) {
        host_->clear();
      }
    }
    if (has_port()) {
      if (port_ != &::google::protobuf::internal::kEmptyString) {
        port_->clear();
      }
    }
    if (has_path()) {
      if (path_ != &::google::protobuf::internal::kEmptyString) {
        path_->clear();
      }
    }
    index_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool IdentityType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string proto = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_proto()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->proto().data(), this->proto().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_user;
        break;
      }

      // optional string user = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_host;
        break;
      }

      // optional string host = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_host:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->host().data(), this->host().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_port;
        break;
      }

      // optional string port = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_port:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_port()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->port().data(), this->port().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_path;
        break;
      }

      // optional string path = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_index;
        break;
      }

      // optional uint32 index = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void IdentityType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string proto = 1;
  if (has_proto()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proto().data(), this->proto().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->proto(), output);
  }

  // optional string user = 2;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->user(), output);
  }

  // optional string host = 3;
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->host(), output);
  }

  // optional string port = 4;
  if (has_port()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->port().data(), this->port().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->port(), output);
  }

  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->path(), output);
  }

  // optional uint32 index = 6 [default = 0];
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* IdentityType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string proto = 1;
  if (has_proto()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->proto().data(), this->proto().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->proto(), target);
  }

  // optional string user = 2;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->user(), target);
  }

  // optional string host = 3;
  if (has_host()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->host().data(), this->host().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->host(), target);
  }

  // optional string port = 4;
  if (has_port()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->port().data(), this->port().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->port(), target);
  }

  // optional string path = 5;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->path(), target);
  }

  // optional uint32 index = 6 [default = 0];
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int IdentityType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string proto = 1;
    if (has_proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->proto());
    }

    // optional string user = 2;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

    // optional string host = 3;
    if (has_host()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host());
    }

    // optional string port = 4;
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->port());
    }

    // optional string path = 5;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional uint32 index = 6 [default = 0];
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IdentityType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const IdentityType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const IdentityType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void IdentityType::MergeFrom(const IdentityType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_proto()) {
      set_proto(from.proto());
    }
    if (from.has_user()) {
      set_user(from.user());
    }
    if (from.has_host()) {
      set_host(from.host());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_path()) {
      set_path(from.path());
    }
    if (from.has_index()) {
      set_index(from.index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void IdentityType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IdentityType::CopyFrom(const IdentityType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IdentityType::IsInitialized() const {

  return true;
}

void IdentityType::Swap(IdentityType* other) {
  if (other != this) {
    std::swap(proto_, other->proto_);
    std::swap(user_, other->user_);
    std::swap(host_, other->host_);
    std::swap(port_, other->port_);
    std::swap(path_, other->path_);
    std::swap(index_, other->index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata IdentityType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IdentityType_descriptor_;
  metadata.reflection = IdentityType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AccountLabelsType::kCountFieldNumber;
const int AccountLabelsType::kLabelsFieldNumber;
#endif  // !_MSC_VER

AccountLabelsType::AccountLabelsType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountLabelsType::InitAsDefaultInstance() {
}

AccountLabelsType::AccountLabelsType(const AccountLabelsType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountLabelsType::SharedCtor() {
  _cached_size_ = 0;
  count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountLabelsType::~AccountLabelsType() {
  SharedDtor();
}

void AccountLabelsType::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AccountLabelsType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountLabelsType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountLabelsType_descriptor_;
}

const AccountLabelsType& AccountLabelsType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

AccountLabelsType* AccountLabelsType::default_instance_ = NULL;

AccountLabelsType* AccountLabelsType::New() const {
  return new AccountLabelsType;
}

void AccountLabelsType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    count_ = 0u;
  }
  labels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountLabelsType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &count_)));
          set_has_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_labels;
        break;
      }

      // repeated .AccountLabelType labels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_labels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_labels;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountLabelsType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 count = 1;
  if (has_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->count(), output);
  }

  // repeated .AccountLabelType labels = 2;
  for (int i = 0; i < this->labels_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->labels(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountLabelsType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 count = 1;
  if (has_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->count(), target);
  }

  // repeated .AccountLabelType labels = 2;
  for (int i = 0; i < this->labels_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->labels(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountLabelsType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 count = 1;
    if (has_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->count());
    }

  }
  // repeated .AccountLabelType labels = 2;
  total_size += 1 * this->labels_size();
  for (int i = 0; i < this->labels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->labels(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountLabelsType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountLabelsType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountLabelsType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountLabelsType::MergeFrom(const AccountLabelsType& from) {
  GOOGLE_CHECK_NE(&from, this);
  labels_.MergeFrom(from.labels_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_count()) {
      set_count(from.count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountLabelsType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountLabelsType::CopyFrom(const AccountLabelsType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountLabelsType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  for (int i = 0; i < labels_size(); i++) {
    if (!this->labels(i).IsInitialized()) return false;
  }
  return true;
}

void AccountLabelsType::Swap(AccountLabelsType* other) {
  if (other != this) {
    std::swap(count_, other->count_);
    labels_.Swap(&other->labels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountLabelsType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountLabelsType_descriptor_;
  metadata.reflection = AccountLabelsType_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AccountLabelType::kIndexFieldNumber;
const int AccountLabelType::kLabelFieldNumber;
#endif  // !_MSC_VER

AccountLabelType::AccountLabelType()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AccountLabelType::InitAsDefaultInstance() {
}

AccountLabelType::AccountLabelType(const AccountLabelType& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AccountLabelType::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0u;
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AccountLabelType::~AccountLabelType() {
  SharedDtor();
}

void AccountLabelType::SharedDtor() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void AccountLabelType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AccountLabelType::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccountLabelType_descriptor_;
}

const AccountLabelType& AccountLabelType::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_types_2eproto();
  return *default_instance_;
}

AccountLabelType* AccountLabelType::default_instance_ = NULL;

AccountLabelType* AccountLabelType::New() const {
  return new AccountLabelType;
}

void AccountLabelType::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0u;
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AccountLabelType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_label;
        break;
      }

      // required string label = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AccountLabelType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->index(), output);
  }

  // required string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AccountLabelType::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->index(), target);
  }

  // required string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AccountLabelType::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->index());
    }

    // required string label = 2;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AccountLabelType::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AccountLabelType* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AccountLabelType*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AccountLabelType::MergeFrom(const AccountLabelType& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AccountLabelType::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AccountLabelType::CopyFrom(const AccountLabelType& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AccountLabelType::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void AccountLabelType::Swap(AccountLabelType* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AccountLabelType::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AccountLabelType_descriptor_;
  metadata.reflection = AccountLabelType_reflection_;
  return metadata;
}

::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_in(kWireInFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_out(kWireOutFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_in(kWireDebugInFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  wire_debug_out(kWireDebugOutFieldNumber, false);

// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
