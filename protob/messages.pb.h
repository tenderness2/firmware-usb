// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "types.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Initialize;
class Features;
class ClearSession;
class ApplySettings;
class ChangePin;
class Ping;
class Success;
class Failure;
class ButtonRequest;
class ButtonAck;
class PinMatrixRequest;
class PinMatrixAck;
class Cancel;
class PassphraseRequest;
class PassphraseAck;
class GetEntropy;
class Entropy;
class GetPublicKey;
class PublicKey;
class GetAddress;
class Address;
class WipeDevice;
class LoadDevice;
class ResetDevice;
class EntropyRequest;
class EntropyAck;
class RecoveryDevice;
class WordRequest;
class WordAck;
class SignMessage;
class VerifyMessage;
class MessageSignature;
class EncryptMessage;
class DecryptMessage;
class CipherKeyValue;
class EstimateTxSize;
class TxSize;
class SignTx;
class SimpleSignTx;
class TxRequest;
class TxAck;
class FirmwareErase;
class FirmwareUpload;
class TestScreen;
class DebugLinkDecision;
class DebugLinkGetState;
class DebugLinkState;
class DebugLinkStop;
class DebugLinkLog;

enum MessageType {
  MessageType_Initialize = 0,
  MessageType_Ping = 1,
  MessageType_Success = 2,
  MessageType_Failure = 3,
  MessageType_ChangePin = 4,
  MessageType_WipeDevice = 5,
  MessageType_FirmwareErase = 6,
  MessageType_FirmwareUpload = 7,
  MessageType_GetEntropy = 9,
  MessageType_Entropy = 10,
  MessageType_GetPublicKey = 11,
  MessageType_PublicKey = 12,
  MessageType_LoadDevice = 13,
  MessageType_ResetDevice = 14,
  MessageType_SignTx = 15,
  MessageType_SimpleSignTx = 16,
  MessageType_Features = 17,
  MessageType_PinMatrixRequest = 18,
  MessageType_PinMatrixAck = 19,
  MessageType_Cancel = 20,
  MessageType_TxRequest = 21,
  MessageType_TxAck = 22,
  MessageType_CipherKeyValue = 23,
  MessageType_ClearSession = 24,
  MessageType_ApplySettings = 25,
  MessageType_ButtonRequest = 26,
  MessageType_ButtonAck = 27,
  MessageType_GetAddress = 29,
  MessageType_Address = 30,
  MessageType_EntropyRequest = 35,
  MessageType_EntropyAck = 36,
  MessageType_SignMessage = 38,
  MessageType_VerifyMessage = 39,
  MessageType_MessageSignature = 40,
  MessageType_EncryptMessage = 48,
  MessageType_DecryptMessage = 49,
  MessageType_PassphraseRequest = 41,
  MessageType_PassphraseAck = 42,
  MessageType_EstimateTxSize = 43,
  MessageType_TxSize = 44,
  MessageType_RecoveryDevice = 45,
  MessageType_WordRequest = 46,
  MessageType_WordAck = 47,
  MessageType_TestScreen = 50,
  MessageType_DebugLinkDecision = 100,
  MessageType_DebugLinkGetState = 101,
  MessageType_DebugLinkState = 102,
  MessageType_DebugLinkStop = 103,
  MessageType_DebugLinkLog = 104
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessageType_Initialize;
const MessageType MessageType_MAX = MessageType_DebugLinkLog;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Initialize : public ::google::protobuf::Message {
 public:
  Initialize();
  virtual ~Initialize();

  Initialize(const Initialize& from);

  inline Initialize& operator=(const Initialize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Initialize& default_instance();

  void Swap(Initialize* other);

  // implements Message ----------------------------------------------

  Initialize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Initialize& from);
  void MergeFrom(const Initialize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Initialize)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Initialize* default_instance_;
};
// -------------------------------------------------------------------

class Features : public ::google::protobuf::Message {
 public:
  Features();
  virtual ~Features();

  Features(const Features& from);

  inline Features& operator=(const Features& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Features& default_instance();

  void Swap(Features* other);

  // implements Message ----------------------------------------------

  Features* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Features& from);
  void MergeFrom(const Features& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string vendor = 1;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 1;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional uint32 major_version = 2;
  inline bool has_major_version() const;
  inline void clear_major_version();
  static const int kMajorVersionFieldNumber = 2;
  inline ::google::protobuf::uint32 major_version() const;
  inline void set_major_version(::google::protobuf::uint32 value);

  // optional uint32 minor_version = 3;
  inline bool has_minor_version() const;
  inline void clear_minor_version();
  static const int kMinorVersionFieldNumber = 3;
  inline ::google::protobuf::uint32 minor_version() const;
  inline void set_minor_version(::google::protobuf::uint32 value);

  // optional uint32 patch_version = 4;
  inline bool has_patch_version() const;
  inline void clear_patch_version();
  static const int kPatchVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 patch_version() const;
  inline void set_patch_version(::google::protobuf::uint32 value);

  // optional bool bootloader_mode = 5;
  inline bool has_bootloader_mode() const;
  inline void clear_bootloader_mode();
  static const int kBootloaderModeFieldNumber = 5;
  inline bool bootloader_mode() const;
  inline void set_bootloader_mode(bool value);

  // optional string device_id = 6;
  inline bool has_device_id() const;
  inline void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  inline const ::std::string& device_id() const;
  inline void set_device_id(const ::std::string& value);
  inline void set_device_id(const char* value);
  inline void set_device_id(const char* value, size_t size);
  inline ::std::string* mutable_device_id();
  inline ::std::string* release_device_id();
  inline void set_allocated_device_id(::std::string* device_id);

  // optional bool pin_protection = 7;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 7;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional bool passphrase_protection = 8;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 8;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional string language = 9;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 9;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 10;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 10;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // repeated .CoinType coins = 11;
  inline int coins_size() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 11;
  inline const ::CoinType& coins(int index) const;
  inline ::CoinType* mutable_coins(int index);
  inline ::CoinType* add_coins();
  inline const ::google::protobuf::RepeatedPtrField< ::CoinType >&
      coins() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoinType >*
      mutable_coins();

  // optional bool initialized = 12;
  inline bool has_initialized() const;
  inline void clear_initialized();
  static const int kInitializedFieldNumber = 12;
  inline bool initialized() const;
  inline void set_initialized(bool value);

  // optional bytes revision = 13;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 13;
  inline const ::std::string& revision() const;
  inline void set_revision(const ::std::string& value);
  inline void set_revision(const char* value);
  inline void set_revision(const void* value, size_t size);
  inline ::std::string* mutable_revision();
  inline ::std::string* release_revision();
  inline void set_allocated_revision(::std::string* revision);

  // optional bytes bootloader_hash = 14;
  inline bool has_bootloader_hash() const;
  inline void clear_bootloader_hash();
  static const int kBootloaderHashFieldNumber = 14;
  inline const ::std::string& bootloader_hash() const;
  inline void set_bootloader_hash(const ::std::string& value);
  inline void set_bootloader_hash(const char* value);
  inline void set_bootloader_hash(const void* value, size_t size);
  inline ::std::string* mutable_bootloader_hash();
  inline ::std::string* release_bootloader_hash();
  inline void set_allocated_bootloader_hash(::std::string* bootloader_hash);

  // optional bool imported = 15;
  inline bool has_imported() const;
  inline void clear_imported();
  static const int kImportedFieldNumber = 15;
  inline bool imported() const;
  inline void set_imported(bool value);

  // optional string cpu_sn = 16;
  inline bool has_cpu_sn() const;
  inline void clear_cpu_sn();
  static const int kCpuSnFieldNumber = 16;
  inline const ::std::string& cpu_sn() const;
  inline void set_cpu_sn(const ::std::string& value);
  inline void set_cpu_sn(const char* value);
  inline void set_cpu_sn(const char* value, size_t size);
  inline ::std::string* mutable_cpu_sn();
  inline ::std::string* release_cpu_sn();
  inline void set_allocated_cpu_sn(::std::string* cpu_sn);

  // @@protoc_insertion_point(class_scope:Features)
 private:
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_major_version();
  inline void clear_has_major_version();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();
  inline void set_has_patch_version();
  inline void clear_has_patch_version();
  inline void set_has_bootloader_mode();
  inline void clear_has_bootloader_mode();
  inline void set_has_device_id();
  inline void clear_has_device_id();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_initialized();
  inline void clear_has_initialized();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_bootloader_hash();
  inline void clear_has_bootloader_hash();
  inline void set_has_imported();
  inline void clear_has_imported();
  inline void set_has_cpu_sn();
  inline void clear_has_cpu_sn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vendor_;
  ::google::protobuf::uint32 major_version_;
  ::google::protobuf::uint32 minor_version_;
  ::std::string* device_id_;
  ::google::protobuf::uint32 patch_version_;
  bool bootloader_mode_;
  bool pin_protection_;
  bool passphrase_protection_;
  bool initialized_;
  ::std::string* language_;
  ::std::string* label_;
  ::google::protobuf::RepeatedPtrField< ::CoinType > coins_;
  ::std::string* revision_;
  ::std::string* bootloader_hash_;
  ::std::string* cpu_sn_;
  bool imported_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Features* default_instance_;
};
// -------------------------------------------------------------------

class ClearSession : public ::google::protobuf::Message {
 public:
  ClearSession();
  virtual ~ClearSession();

  ClearSession(const ClearSession& from);

  inline ClearSession& operator=(const ClearSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearSession& default_instance();

  void Swap(ClearSession* other);

  // implements Message ----------------------------------------------

  ClearSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClearSession& from);
  void MergeFrom(const ClearSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ClearSession)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ClearSession* default_instance_;
};
// -------------------------------------------------------------------

class ApplySettings : public ::google::protobuf::Message {
 public:
  ApplySettings();
  virtual ~ApplySettings();

  ApplySettings(const ApplySettings& from);

  inline ApplySettings& operator=(const ApplySettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplySettings& default_instance();

  void Swap(ApplySettings* other);

  // implements Message ----------------------------------------------

  ApplySettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplySettings& from);
  void MergeFrom(const ApplySettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string language = 1;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 1;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:ApplySettings)
 private:
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* language_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ApplySettings* default_instance_;
};
// -------------------------------------------------------------------

class ChangePin : public ::google::protobuf::Message {
 public:
  ChangePin();
  virtual ~ChangePin();

  ChangePin(const ChangePin& from);

  inline ChangePin& operator=(const ChangePin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePin& default_instance();

  void Swap(ChangePin* other);

  // implements Message ----------------------------------------------

  ChangePin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePin& from);
  void MergeFrom(const ChangePin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool remove = 1;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 1;
  inline bool remove() const;
  inline void set_remove(bool value);

  // @@protoc_insertion_point(class_scope:ChangePin)
 private:
  inline void set_has_remove();
  inline void clear_has_remove();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool remove_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ChangePin* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool button_protection = 2;
  inline bool has_button_protection() const;
  inline void clear_button_protection();
  static const int kButtonProtectionFieldNumber = 2;
  inline bool button_protection() const;
  inline void set_button_protection(bool value);

  // optional bool pin_protection = 3;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional bool passphrase_protection = 4;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_button_protection();
  inline void clear_has_button_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  bool button_protection_;
  bool pin_protection_;
  bool passphrase_protection_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class Success : public ::google::protobuf::Message {
 public:
  Success();
  virtual ~Success();

  Success(const Success& from);

  inline Success& operator=(const Success& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Success& default_instance();

  void Swap(Success* other);

  // implements Message ----------------------------------------------

  Success* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Success& from);
  void MergeFrom(const Success& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 1;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:Success)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  ::std::string* payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Success* default_instance_;
};
// -------------------------------------------------------------------

class Failure : public ::google::protobuf::Message {
 public:
  Failure();
  virtual ~Failure();

  Failure(const Failure& from);

  inline Failure& operator=(const Failure& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Failure& default_instance();

  void Swap(Failure* other);

  // implements Message ----------------------------------------------

  Failure* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Failure& from);
  void MergeFrom(const Failure& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FailureType code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::FailureType code() const;
  inline void set_code(::FailureType value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:Failure)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* message_;
  int code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Failure* default_instance_;
};
// -------------------------------------------------------------------

class ButtonRequest : public ::google::protobuf::Message {
 public:
  ButtonRequest();
  virtual ~ButtonRequest();

  ButtonRequest(const ButtonRequest& from);

  inline ButtonRequest& operator=(const ButtonRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonRequest& default_instance();

  void Swap(ButtonRequest* other);

  // implements Message ----------------------------------------------

  ButtonRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonRequest& from);
  void MergeFrom(const ButtonRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ButtonRequestType code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::ButtonRequestType code() const;
  inline void set_code(::ButtonRequestType value);

  // optional string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ButtonRequest)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  int code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ButtonRequest* default_instance_;
};
// -------------------------------------------------------------------

class ButtonAck : public ::google::protobuf::Message {
 public:
  ButtonAck();
  virtual ~ButtonAck();

  ButtonAck(const ButtonAck& from);

  inline ButtonAck& operator=(const ButtonAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ButtonAck& default_instance();

  void Swap(ButtonAck* other);

  // implements Message ----------------------------------------------

  ButtonAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ButtonAck& from);
  void MergeFrom(const ButtonAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ButtonAck)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ButtonAck* default_instance_;
};
// -------------------------------------------------------------------

class PinMatrixRequest : public ::google::protobuf::Message {
 public:
  PinMatrixRequest();
  virtual ~PinMatrixRequest();

  PinMatrixRequest(const PinMatrixRequest& from);

  inline PinMatrixRequest& operator=(const PinMatrixRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixRequest& default_instance();

  void Swap(PinMatrixRequest* other);

  // implements Message ----------------------------------------------

  PinMatrixRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinMatrixRequest& from);
  void MergeFrom(const PinMatrixRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .PinMatrixRequestType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PinMatrixRequestType type() const;
  inline void set_type(::PinMatrixRequestType value);

  // @@protoc_insertion_point(class_scope:PinMatrixRequest)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PinMatrixRequest* default_instance_;
};
// -------------------------------------------------------------------

class PinMatrixAck : public ::google::protobuf::Message {
 public:
  PinMatrixAck();
  virtual ~PinMatrixAck();

  PinMatrixAck(const PinMatrixAck& from);

  inline PinMatrixAck& operator=(const PinMatrixAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PinMatrixAck& default_instance();

  void Swap(PinMatrixAck* other);

  // implements Message ----------------------------------------------

  PinMatrixAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PinMatrixAck& from);
  void MergeFrom(const PinMatrixAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:PinMatrixAck)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PinMatrixAck* default_instance_;
};
// -------------------------------------------------------------------

class Cancel : public ::google::protobuf::Message {
 public:
  Cancel();
  virtual ~Cancel();

  Cancel(const Cancel& from);

  inline Cancel& operator=(const Cancel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Cancel& default_instance();

  void Swap(Cancel* other);

  // implements Message ----------------------------------------------

  Cancel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cancel& from);
  void MergeFrom(const Cancel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Cancel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Cancel* default_instance_;
};
// -------------------------------------------------------------------

class PassphraseRequest : public ::google::protobuf::Message {
 public:
  PassphraseRequest();
  virtual ~PassphraseRequest();

  PassphraseRequest(const PassphraseRequest& from);

  inline PassphraseRequest& operator=(const PassphraseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassphraseRequest& default_instance();

  void Swap(PassphraseRequest* other);

  // implements Message ----------------------------------------------

  PassphraseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassphraseRequest& from);
  void MergeFrom(const PassphraseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:PassphraseRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PassphraseRequest* default_instance_;
};
// -------------------------------------------------------------------

class PassphraseAck : public ::google::protobuf::Message {
 public:
  PassphraseAck();
  virtual ~PassphraseAck();

  PassphraseAck(const PassphraseAck& from);

  inline PassphraseAck& operator=(const PassphraseAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PassphraseAck& default_instance();

  void Swap(PassphraseAck* other);

  // implements Message ----------------------------------------------

  PassphraseAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PassphraseAck& from);
  void MergeFrom(const PassphraseAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string passphrase = 1;
  inline bool has_passphrase() const;
  inline void clear_passphrase();
  static const int kPassphraseFieldNumber = 1;
  inline const ::std::string& passphrase() const;
  inline void set_passphrase(const ::std::string& value);
  inline void set_passphrase(const char* value);
  inline void set_passphrase(const char* value, size_t size);
  inline ::std::string* mutable_passphrase();
  inline ::std::string* release_passphrase();
  inline void set_allocated_passphrase(::std::string* passphrase);

  // @@protoc_insertion_point(class_scope:PassphraseAck)
 private:
  inline void set_has_passphrase();
  inline void clear_has_passphrase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* passphrase_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PassphraseAck* default_instance_;
};
// -------------------------------------------------------------------

class GetEntropy : public ::google::protobuf::Message {
 public:
  GetEntropy();
  virtual ~GetEntropy();

  GetEntropy(const GetEntropy& from);

  inline GetEntropy& operator=(const GetEntropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetEntropy& default_instance();

  void Swap(GetEntropy* other);

  // implements Message ----------------------------------------------

  GetEntropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetEntropy& from);
  void MergeFrom(const GetEntropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:GetEntropy)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static GetEntropy* default_instance_;
};
// -------------------------------------------------------------------

class Entropy : public ::google::protobuf::Message {
 public:
  Entropy();
  virtual ~Entropy();

  Entropy(const Entropy& from);

  inline Entropy& operator=(const Entropy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entropy& default_instance();

  void Swap(Entropy* other);

  // implements Message ----------------------------------------------

  Entropy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entropy& from);
  void MergeFrom(const Entropy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  inline void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:Entropy)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* entropy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Entropy* default_instance_;
};
// -------------------------------------------------------------------

class GetPublicKey : public ::google::protobuf::Message {
 public:
  GetPublicKey();
  virtual ~GetPublicKey();

  GetPublicKey(const GetPublicKey& from);

  inline GetPublicKey& operator=(const GetPublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPublicKey& default_instance();

  void Swap(GetPublicKey* other);

  // implements Message ----------------------------------------------

  GetPublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPublicKey& from);
  void MergeFrom(const GetPublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // @@protoc_insertion_point(class_scope:GetPublicKey)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static GetPublicKey* default_instance_;
};
// -------------------------------------------------------------------

class PublicKey : public ::google::protobuf::Message {
 public:
  PublicKey();
  virtual ~PublicKey();

  PublicKey(const PublicKey& from);

  inline PublicKey& operator=(const PublicKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKey& default_instance();

  void Swap(PublicKey* other);

  // implements Message ----------------------------------------------

  PublicKey* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKey& from);
  void MergeFrom(const PublicKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HDNodeType node = 1;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // optional string xpub = 2;
  inline bool has_xpub() const;
  inline void clear_xpub();
  static const int kXpubFieldNumber = 2;
  inline const ::std::string& xpub() const;
  inline void set_xpub(const ::std::string& value);
  inline void set_xpub(const char* value);
  inline void set_xpub(const char* value, size_t size);
  inline ::std::string* mutable_xpub();
  inline ::std::string* release_xpub();
  inline void set_allocated_xpub(::std::string* xpub);

  // @@protoc_insertion_point(class_scope:PublicKey)
 private:
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_xpub();
  inline void clear_has_xpub();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HDNodeType* node_;
  ::std::string* xpub_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PublicKey* default_instance_;
};
// -------------------------------------------------------------------

class GetAddress : public ::google::protobuf::Message {
 public:
  GetAddress();
  virtual ~GetAddress();

  GetAddress(const GetAddress& from);

  inline GetAddress& operator=(const GetAddress& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAddress& default_instance();

  void Swap(GetAddress* other);

  // implements Message ----------------------------------------------

  GetAddress* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAddress& from);
  void MergeFrom(const GetAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string coin_name = 2 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 2;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // optional bool show_display = 3;
  inline bool has_show_display() const;
  inline void clear_show_display();
  static const int kShowDisplayFieldNumber = 3;
  inline bool show_display() const;
  inline void set_show_display(bool value);

  // @@protoc_insertion_point(class_scope:GetAddress)
 private:
  inline void set_has_coin_name();
  inline void clear_has_coin_name();
  inline void set_has_show_display();
  inline void clear_has_show_display();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* coin_name_;
  static ::std::string* _default_coin_name_;
  bool show_display_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static GetAddress* default_instance_;
};
// -------------------------------------------------------------------

class Address : public ::google::protobuf::Message {
 public:
  Address();
  virtual ~Address();

  Address(const Address& from);

  inline Address& operator=(const Address& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Address& default_instance();

  void Swap(Address* other);

  // implements Message ----------------------------------------------

  Address* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Address& from);
  void MergeFrom(const Address& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:Address)
 private:
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Address* default_instance_;
};
// -------------------------------------------------------------------

class WipeDevice : public ::google::protobuf::Message {
 public:
  WipeDevice();
  virtual ~WipeDevice();

  WipeDevice(const WipeDevice& from);

  inline WipeDevice& operator=(const WipeDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WipeDevice& default_instance();

  void Swap(WipeDevice* other);

  // implements Message ----------------------------------------------

  WipeDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WipeDevice& from);
  void MergeFrom(const WipeDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:WipeDevice)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static WipeDevice* default_instance_;
};
// -------------------------------------------------------------------

class LoadDevice : public ::google::protobuf::Message {
 public:
  LoadDevice();
  virtual ~LoadDevice();

  LoadDevice(const LoadDevice& from);

  inline LoadDevice& operator=(const LoadDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoadDevice& default_instance();

  void Swap(LoadDevice* other);

  // implements Message ----------------------------------------------

  LoadDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoadDevice& from);
  void MergeFrom(const LoadDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mnemonic = 1;
  inline bool has_mnemonic() const;
  inline void clear_mnemonic();
  static const int kMnemonicFieldNumber = 1;
  inline const ::std::string& mnemonic() const;
  inline void set_mnemonic(const ::std::string& value);
  inline void set_mnemonic(const char* value);
  inline void set_mnemonic(const char* value, size_t size);
  inline ::std::string* mutable_mnemonic();
  inline ::std::string* release_mnemonic();
  inline void set_allocated_mnemonic(::std::string* mnemonic);

  // optional .HDNodeType node = 2;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 2;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // optional string pin = 3;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 3;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional bool passphrase_protection = 4;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 4;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional string language = 5 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 5;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool skip_checksum = 7;
  inline bool has_skip_checksum() const;
  inline void clear_skip_checksum();
  static const int kSkipChecksumFieldNumber = 7;
  inline bool skip_checksum() const;
  inline void set_skip_checksum(bool value);

  // @@protoc_insertion_point(class_scope:LoadDevice)
 private:
  inline void set_has_mnemonic();
  inline void clear_has_mnemonic();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_skip_checksum();
  inline void clear_has_skip_checksum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mnemonic_;
  ::HDNodeType* node_;
  ::std::string* pin_;
  ::std::string* language_;
  static ::std::string* _default_language_;
  ::std::string* label_;
  bool passphrase_protection_;
  bool skip_checksum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static LoadDevice* default_instance_;
};
// -------------------------------------------------------------------

class ResetDevice : public ::google::protobuf::Message {
 public:
  ResetDevice();
  virtual ~ResetDevice();

  ResetDevice(const ResetDevice& from);

  inline ResetDevice& operator=(const ResetDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetDevice& default_instance();

  void Swap(ResetDevice* other);

  // implements Message ----------------------------------------------

  ResetDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResetDevice& from);
  void MergeFrom(const ResetDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool display_random = 1;
  inline bool has_display_random() const;
  inline void clear_display_random();
  static const int kDisplayRandomFieldNumber = 1;
  inline bool display_random() const;
  inline void set_display_random(bool value);

  // optional uint32 strength = 2 [default = 128];
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 2;
  inline ::google::protobuf::uint32 strength() const;
  inline void set_strength(::google::protobuf::uint32 value);

  // optional bool passphrase_protection = 3;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 3;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional bool pin_protection = 4;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 4;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional string language = 5 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 5;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 6;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 6;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // @@protoc_insertion_point(class_scope:ResetDevice)
 private:
  inline void set_has_display_random();
  inline void clear_has_display_random();
  inline void set_has_strength();
  inline void clear_has_strength();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 strength_;
  bool display_random_;
  bool passphrase_protection_;
  bool pin_protection_;
  ::std::string* language_;
  static ::std::string* _default_language_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ResetDevice* default_instance_;
};
// -------------------------------------------------------------------

class EntropyRequest : public ::google::protobuf::Message {
 public:
  EntropyRequest();
  virtual ~EntropyRequest();

  EntropyRequest(const EntropyRequest& from);

  inline EntropyRequest& operator=(const EntropyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyRequest& default_instance();

  void Swap(EntropyRequest* other);

  // implements Message ----------------------------------------------

  EntropyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntropyRequest& from);
  void MergeFrom(const EntropyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:EntropyRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static EntropyRequest* default_instance_;
};
// -------------------------------------------------------------------

class EntropyAck : public ::google::protobuf::Message {
 public:
  EntropyAck();
  virtual ~EntropyAck();

  EntropyAck(const EntropyAck& from);

  inline EntropyAck& operator=(const EntropyAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntropyAck& default_instance();

  void Swap(EntropyAck* other);

  // implements Message ----------------------------------------------

  EntropyAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntropyAck& from);
  void MergeFrom(const EntropyAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes entropy = 1;
  inline bool has_entropy() const;
  inline void clear_entropy();
  static const int kEntropyFieldNumber = 1;
  inline const ::std::string& entropy() const;
  inline void set_entropy(const ::std::string& value);
  inline void set_entropy(const char* value);
  inline void set_entropy(const void* value, size_t size);
  inline ::std::string* mutable_entropy();
  inline ::std::string* release_entropy();
  inline void set_allocated_entropy(::std::string* entropy);

  // @@protoc_insertion_point(class_scope:EntropyAck)
 private:
  inline void set_has_entropy();
  inline void clear_has_entropy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* entropy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static EntropyAck* default_instance_;
};
// -------------------------------------------------------------------

class RecoveryDevice : public ::google::protobuf::Message {
 public:
  RecoveryDevice();
  virtual ~RecoveryDevice();

  RecoveryDevice(const RecoveryDevice& from);

  inline RecoveryDevice& operator=(const RecoveryDevice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecoveryDevice& default_instance();

  void Swap(RecoveryDevice* other);

  // implements Message ----------------------------------------------

  RecoveryDevice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecoveryDevice& from);
  void MergeFrom(const RecoveryDevice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 word_count = 1;
  inline bool has_word_count() const;
  inline void clear_word_count();
  static const int kWordCountFieldNumber = 1;
  inline ::google::protobuf::uint32 word_count() const;
  inline void set_word_count(::google::protobuf::uint32 value);

  // optional bool passphrase_protection = 2;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 2;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional bool pin_protection = 3;
  inline bool has_pin_protection() const;
  inline void clear_pin_protection();
  static const int kPinProtectionFieldNumber = 3;
  inline bool pin_protection() const;
  inline void set_pin_protection(bool value);

  // optional string language = 4 [default = "english"];
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 4;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // optional string label = 5;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 5;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional bool enforce_wordlist = 6;
  inline bool has_enforce_wordlist() const;
  inline void clear_enforce_wordlist();
  static const int kEnforceWordlistFieldNumber = 6;
  inline bool enforce_wordlist() const;
  inline void set_enforce_wordlist(bool value);

  // @@protoc_insertion_point(class_scope:RecoveryDevice)
 private:
  inline void set_has_word_count();
  inline void clear_has_word_count();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_pin_protection();
  inline void clear_has_pin_protection();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_enforce_wordlist();
  inline void clear_has_enforce_wordlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 word_count_;
  bool passphrase_protection_;
  bool pin_protection_;
  bool enforce_wordlist_;
  ::std::string* language_;
  static ::std::string* _default_language_;
  ::std::string* label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static RecoveryDevice* default_instance_;
};
// -------------------------------------------------------------------

class WordRequest : public ::google::protobuf::Message {
 public:
  WordRequest();
  virtual ~WordRequest();

  WordRequest(const WordRequest& from);

  inline WordRequest& operator=(const WordRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordRequest& default_instance();

  void Swap(WordRequest* other);

  // implements Message ----------------------------------------------

  WordRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordRequest& from);
  void MergeFrom(const WordRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:WordRequest)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static WordRequest* default_instance_;
};
// -------------------------------------------------------------------

class WordAck : public ::google::protobuf::Message {
 public:
  WordAck();
  virtual ~WordAck();

  WordAck(const WordAck& from);

  inline WordAck& operator=(const WordAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordAck& default_instance();

  void Swap(WordAck* other);

  // implements Message ----------------------------------------------

  WordAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordAck& from);
  void MergeFrom(const WordAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string word = 1;
  inline bool has_word() const;
  inline void clear_word();
  static const int kWordFieldNumber = 1;
  inline const ::std::string& word() const;
  inline void set_word(const ::std::string& value);
  inline void set_word(const char* value);
  inline void set_word(const char* value, size_t size);
  inline ::std::string* mutable_word();
  inline ::std::string* release_word();
  inline void set_allocated_word(::std::string* word);

  // @@protoc_insertion_point(class_scope:WordAck)
 private:
  inline void set_has_word();
  inline void clear_has_word();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* word_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static WordAck* default_instance_;
};
// -------------------------------------------------------------------

class SignMessage : public ::google::protobuf::Message {
 public:
  SignMessage();
  virtual ~SignMessage();

  SignMessage(const SignMessage& from);

  inline SignMessage& operator=(const SignMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignMessage& default_instance();

  void Swap(SignMessage* other);

  // implements Message ----------------------------------------------

  SignMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignMessage& from);
  void MergeFrom(const SignMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // required bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional string coin_name = 3 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:SignMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* message_;
  ::std::string* coin_name_;
  static ::std::string* _default_coin_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static SignMessage* default_instance_;
};
// -------------------------------------------------------------------

class VerifyMessage : public ::google::protobuf::Message {
 public:
  VerifyMessage();
  virtual ~VerifyMessage();

  VerifyMessage(const VerifyMessage& from);

  inline VerifyMessage& operator=(const VerifyMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VerifyMessage& default_instance();

  void Swap(VerifyMessage* other);

  // implements Message ----------------------------------------------

  VerifyMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VerifyMessage& from);
  void MergeFrom(const VerifyMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional bytes message = 3;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 3;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:VerifyMessage)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::std::string* signature_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static VerifyMessage* default_instance_;
};
// -------------------------------------------------------------------

class MessageSignature : public ::google::protobuf::Message {
 public:
  MessageSignature();
  virtual ~MessageSignature();

  MessageSignature(const MessageSignature& from);

  inline MessageSignature& operator=(const MessageSignature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageSignature& default_instance();

  void Swap(MessageSignature* other);

  // implements Message ----------------------------------------------

  MessageSignature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageSignature& from);
  void MergeFrom(const MessageSignature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // @@protoc_insertion_point(class_scope:MessageSignature)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_signature();
  inline void clear_has_signature();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* address_;
  ::std::string* signature_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static MessageSignature* default_instance_;
};
// -------------------------------------------------------------------

class EncryptMessage : public ::google::protobuf::Message {
 public:
  EncryptMessage();
  virtual ~EncryptMessage();

  EncryptMessage(const EncryptMessage& from);

  inline EncryptMessage& operator=(const EncryptMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptMessage& default_instance();

  void Swap(EncryptMessage* other);

  // implements Message ----------------------------------------------

  EncryptMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptMessage& from);
  void MergeFrom(const EncryptMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pubkey = 1;
  inline bool has_pubkey() const;
  inline void clear_pubkey();
  static const int kPubkeyFieldNumber = 1;
  inline const ::std::string& pubkey() const;
  inline void set_pubkey(const ::std::string& value);
  inline void set_pubkey(const char* value);
  inline void set_pubkey(const void* value, size_t size);
  inline ::std::string* mutable_pubkey();
  inline ::std::string* release_pubkey();
  inline void set_allocated_pubkey(::std::string* pubkey);

  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool display_only = 3;
  inline bool has_display_only() const;
  inline void clear_display_only();
  static const int kDisplayOnlyFieldNumber = 3;
  inline bool display_only() const;
  inline void set_display_only(bool value);

  // repeated uint32 address_n = 4;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 4;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // @@protoc_insertion_point(class_scope:EncryptMessage)
 private:
  inline void set_has_pubkey();
  inline void clear_has_pubkey();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_display_only();
  inline void clear_has_display_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pubkey_;
  ::std::string* message_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  bool display_only_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static EncryptMessage* default_instance_;
};
// -------------------------------------------------------------------

class DecryptMessage : public ::google::protobuf::Message {
 public:
  DecryptMessage();
  virtual ~DecryptMessage();

  DecryptMessage(const DecryptMessage& from);

  inline DecryptMessage& operator=(const DecryptMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecryptMessage& default_instance();

  void Swap(DecryptMessage* other);

  // implements Message ----------------------------------------------

  DecryptMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecryptMessage& from);
  void MergeFrom(const DecryptMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional bytes message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:DecryptMessage)
 private:
  inline void set_has_message();
  inline void clear_has_message();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* message_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DecryptMessage* default_instance_;
};
// -------------------------------------------------------------------

class CipherKeyValue : public ::google::protobuf::Message {
 public:
  CipherKeyValue();
  virtual ~CipherKeyValue();

  CipherKeyValue(const CipherKeyValue& from);

  inline CipherKeyValue& operator=(const CipherKeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CipherKeyValue& default_instance();

  void Swap(CipherKeyValue* other);

  // implements Message ----------------------------------------------

  CipherKeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CipherKeyValue& from);
  void MergeFrom(const CipherKeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 address_n = 1;
  inline int address_n_size() const;
  inline void clear_address_n();
  static const int kAddressNFieldNumber = 1;
  inline ::google::protobuf::uint32 address_n(int index) const;
  inline void set_address_n(int index, ::google::protobuf::uint32 value);
  inline void add_address_n(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      address_n() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_address_n();

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bool encrypt = 4;
  inline bool has_encrypt() const;
  inline void clear_encrypt();
  static const int kEncryptFieldNumber = 4;
  inline bool encrypt() const;
  inline void set_encrypt(bool value);

  // optional bool ask_on_encrypt = 5;
  inline bool has_ask_on_encrypt() const;
  inline void clear_ask_on_encrypt();
  static const int kAskOnEncryptFieldNumber = 5;
  inline bool ask_on_encrypt() const;
  inline void set_ask_on_encrypt(bool value);

  // optional bool ask_on_decrypt = 6;
  inline bool has_ask_on_decrypt() const;
  inline void clear_ask_on_decrypt();
  static const int kAskOnDecryptFieldNumber = 6;
  inline bool ask_on_decrypt() const;
  inline void set_ask_on_decrypt(bool value);

  // @@protoc_insertion_point(class_scope:CipherKeyValue)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_encrypt();
  inline void clear_has_encrypt();
  inline void set_has_ask_on_encrypt();
  inline void clear_has_ask_on_encrypt();
  inline void set_has_ask_on_decrypt();
  inline void clear_has_ask_on_decrypt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > address_n_;
  ::std::string* key_;
  ::std::string* value_;
  bool encrypt_;
  bool ask_on_encrypt_;
  bool ask_on_decrypt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static CipherKeyValue* default_instance_;
};
// -------------------------------------------------------------------

class EstimateTxSize : public ::google::protobuf::Message {
 public:
  EstimateTxSize();
  virtual ~EstimateTxSize();

  EstimateTxSize(const EstimateTxSize& from);

  inline EstimateTxSize& operator=(const EstimateTxSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EstimateTxSize& default_instance();

  void Swap(EstimateTxSize* other);

  // implements Message ----------------------------------------------

  EstimateTxSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EstimateTxSize& from);
  void MergeFrom(const EstimateTxSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 outputs_count = 1;
  inline bool has_outputs_count() const;
  inline void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  inline ::google::protobuf::uint32 outputs_count() const;
  inline void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  inline bool has_inputs_count() const;
  inline void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  inline ::google::protobuf::uint32 inputs_count() const;
  inline void set_inputs_count(::google::protobuf::uint32 value);

  // optional string coin_name = 3 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:EstimateTxSize)
 private:
  inline void set_has_outputs_count();
  inline void clear_has_outputs_count();
  inline void set_has_inputs_count();
  inline void clear_has_inputs_count();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  ::std::string* coin_name_;
  static ::std::string* _default_coin_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static EstimateTxSize* default_instance_;
};
// -------------------------------------------------------------------

class TxSize : public ::google::protobuf::Message {
 public:
  TxSize();
  virtual ~TxSize();

  TxSize(const TxSize& from);

  inline TxSize& operator=(const TxSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxSize& default_instance();

  void Swap(TxSize* other);

  // implements Message ----------------------------------------------

  TxSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxSize& from);
  void MergeFrom(const TxSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 tx_size = 1;
  inline bool has_tx_size() const;
  inline void clear_tx_size();
  static const int kTxSizeFieldNumber = 1;
  inline ::google::protobuf::uint32 tx_size() const;
  inline void set_tx_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TxSize)
 private:
  inline void set_has_tx_size();
  inline void clear_has_tx_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tx_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TxSize* default_instance_;
};
// -------------------------------------------------------------------

class SignTx : public ::google::protobuf::Message {
 public:
  SignTx();
  virtual ~SignTx();

  SignTx(const SignTx& from);

  inline SignTx& operator=(const SignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignTx& default_instance();

  void Swap(SignTx* other);

  // implements Message ----------------------------------------------

  SignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignTx& from);
  void MergeFrom(const SignTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 outputs_count = 1;
  inline bool has_outputs_count() const;
  inline void clear_outputs_count();
  static const int kOutputsCountFieldNumber = 1;
  inline ::google::protobuf::uint32 outputs_count() const;
  inline void set_outputs_count(::google::protobuf::uint32 value);

  // required uint32 inputs_count = 2;
  inline bool has_inputs_count() const;
  inline void clear_inputs_count();
  static const int kInputsCountFieldNumber = 2;
  inline ::google::protobuf::uint32 inputs_count() const;
  inline void set_inputs_count(::google::protobuf::uint32 value);

  // optional string coin_name = 3 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 3;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:SignTx)
 private:
  inline void set_has_outputs_count();
  inline void clear_has_outputs_count();
  inline void set_has_inputs_count();
  inline void clear_has_inputs_count();
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 outputs_count_;
  ::google::protobuf::uint32 inputs_count_;
  ::std::string* coin_name_;
  static ::std::string* _default_coin_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static SignTx* default_instance_;
};
// -------------------------------------------------------------------

class SimpleSignTx : public ::google::protobuf::Message {
 public:
  SimpleSignTx();
  virtual ~SimpleSignTx();

  SimpleSignTx(const SimpleSignTx& from);

  inline SimpleSignTx& operator=(const SimpleSignTx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SimpleSignTx& default_instance();

  void Swap(SimpleSignTx* other);

  // implements Message ----------------------------------------------

  SimpleSignTx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SimpleSignTx& from);
  void MergeFrom(const SimpleSignTx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .TxInputType inputs = 1;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 1;
  inline const ::TxInputType& inputs(int index) const;
  inline ::TxInputType* mutable_inputs(int index);
  inline ::TxInputType* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxInputType >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxInputType >*
      mutable_inputs();

  // repeated .TxOutputType outputs = 2;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  inline const ::TxOutputType& outputs(int index) const;
  inline ::TxOutputType* mutable_outputs(int index);
  inline ::TxOutputType* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::TxOutputType >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::TxOutputType >*
      mutable_outputs();

  // repeated .TransactionType transactions = 3;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 3;
  inline const ::TransactionType& transactions(int index) const;
  inline ::TransactionType* mutable_transactions(int index);
  inline ::TransactionType* add_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::TransactionType >&
      transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::TransactionType >*
      mutable_transactions();

  // optional string coin_name = 4 [default = "Bitcoin"];
  inline bool has_coin_name() const;
  inline void clear_coin_name();
  static const int kCoinNameFieldNumber = 4;
  inline const ::std::string& coin_name() const;
  inline void set_coin_name(const ::std::string& value);
  inline void set_coin_name(const char* value);
  inline void set_coin_name(const char* value, size_t size);
  inline ::std::string* mutable_coin_name();
  inline ::std::string* release_coin_name();
  inline void set_allocated_coin_name(::std::string* coin_name);

  // @@protoc_insertion_point(class_scope:SimpleSignTx)
 private:
  inline void set_has_coin_name();
  inline void clear_has_coin_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::TxInputType > inputs_;
  ::google::protobuf::RepeatedPtrField< ::TxOutputType > outputs_;
  ::google::protobuf::RepeatedPtrField< ::TransactionType > transactions_;
  ::std::string* coin_name_;
  static ::std::string* _default_coin_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static SimpleSignTx* default_instance_;
};
// -------------------------------------------------------------------

class TxRequest : public ::google::protobuf::Message {
 public:
  TxRequest();
  virtual ~TxRequest();

  TxRequest(const TxRequest& from);

  inline TxRequest& operator=(const TxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxRequest& default_instance();

  void Swap(TxRequest* other);

  // implements Message ----------------------------------------------

  TxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxRequest& from);
  void MergeFrom(const TxRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .RequestType request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::RequestType request_type() const;
  inline void set_request_type(::RequestType value);

  // optional .TxRequestDetailsType details = 2;
  inline bool has_details() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 2;
  inline const ::TxRequestDetailsType& details() const;
  inline ::TxRequestDetailsType* mutable_details();
  inline ::TxRequestDetailsType* release_details();
  inline void set_allocated_details(::TxRequestDetailsType* details);

  // optional .TxRequestSerializedType serialized = 3;
  inline bool has_serialized() const;
  inline void clear_serialized();
  static const int kSerializedFieldNumber = 3;
  inline const ::TxRequestSerializedType& serialized() const;
  inline ::TxRequestSerializedType* mutable_serialized();
  inline ::TxRequestSerializedType* release_serialized();
  inline void set_allocated_serialized(::TxRequestSerializedType* serialized);

  // @@protoc_insertion_point(class_scope:TxRequest)
 private:
  inline void set_has_request_type();
  inline void clear_has_request_type();
  inline void set_has_details();
  inline void clear_has_details();
  inline void set_has_serialized();
  inline void clear_has_serialized();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TxRequestDetailsType* details_;
  ::TxRequestSerializedType* serialized_;
  int request_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TxRequest* default_instance_;
};
// -------------------------------------------------------------------

class TxAck : public ::google::protobuf::Message {
 public:
  TxAck();
  virtual ~TxAck();

  TxAck(const TxAck& from);

  inline TxAck& operator=(const TxAck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TxAck& default_instance();

  void Swap(TxAck* other);

  // implements Message ----------------------------------------------

  TxAck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TxAck& from);
  void MergeFrom(const TxAck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .TransactionType tx = 1;
  inline bool has_tx() const;
  inline void clear_tx();
  static const int kTxFieldNumber = 1;
  inline const ::TransactionType& tx() const;
  inline ::TransactionType* mutable_tx();
  inline ::TransactionType* release_tx();
  inline void set_allocated_tx(::TransactionType* tx);

  // @@protoc_insertion_point(class_scope:TxAck)
 private:
  inline void set_has_tx();
  inline void clear_has_tx();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::TransactionType* tx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TxAck* default_instance_;
};
// -------------------------------------------------------------------

class FirmwareErase : public ::google::protobuf::Message {
 public:
  FirmwareErase();
  virtual ~FirmwareErase();

  FirmwareErase(const FirmwareErase& from);

  inline FirmwareErase& operator=(const FirmwareErase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareErase& default_instance();

  void Swap(FirmwareErase* other);

  // implements Message ----------------------------------------------

  FirmwareErase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FirmwareErase& from);
  void MergeFrom(const FirmwareErase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:FirmwareErase)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static FirmwareErase* default_instance_;
};
// -------------------------------------------------------------------

class FirmwareUpload : public ::google::protobuf::Message {
 public:
  FirmwareUpload();
  virtual ~FirmwareUpload();

  FirmwareUpload(const FirmwareUpload& from);

  inline FirmwareUpload& operator=(const FirmwareUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FirmwareUpload& default_instance();

  void Swap(FirmwareUpload* other);

  // implements Message ----------------------------------------------

  FirmwareUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FirmwareUpload& from);
  void MergeFrom(const FirmwareUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  inline void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:FirmwareUpload)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* payload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static FirmwareUpload* default_instance_;
};
// -------------------------------------------------------------------

class TestScreen : public ::google::protobuf::Message {
 public:
  TestScreen();
  virtual ~TestScreen();

  TestScreen(const TestScreen& from);

  inline TestScreen& operator=(const TestScreen& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestScreen& default_instance();

  void Swap(TestScreen* other);

  // implements Message ----------------------------------------------

  TestScreen* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestScreen& from);
  void MergeFrom(const TestScreen& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 delay_time = 1 [default = 1];
  inline bool has_delay_time() const;
  inline void clear_delay_time();
  static const int kDelayTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 delay_time() const;
  inline void set_delay_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TestScreen)
 private:
  inline void set_has_delay_time();
  inline void clear_has_delay_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 delay_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static TestScreen* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkDecision : public ::google::protobuf::Message {
 public:
  DebugLinkDecision();
  virtual ~DebugLinkDecision();

  DebugLinkDecision(const DebugLinkDecision& from);

  inline DebugLinkDecision& operator=(const DebugLinkDecision& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkDecision& default_instance();

  void Swap(DebugLinkDecision* other);

  // implements Message ----------------------------------------------

  DebugLinkDecision* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkDecision& from);
  void MergeFrom(const DebugLinkDecision& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool yes_no = 1;
  inline bool has_yes_no() const;
  inline void clear_yes_no();
  static const int kYesNoFieldNumber = 1;
  inline bool yes_no() const;
  inline void set_yes_no(bool value);

  // @@protoc_insertion_point(class_scope:DebugLinkDecision)
 private:
  inline void set_has_yes_no();
  inline void clear_has_yes_no();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool yes_no_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkDecision* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkGetState : public ::google::protobuf::Message {
 public:
  DebugLinkGetState();
  virtual ~DebugLinkGetState();

  DebugLinkGetState(const DebugLinkGetState& from);

  inline DebugLinkGetState& operator=(const DebugLinkGetState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkGetState& default_instance();

  void Swap(DebugLinkGetState* other);

  // implements Message ----------------------------------------------

  DebugLinkGetState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkGetState& from);
  void MergeFrom(const DebugLinkGetState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DebugLinkGetState)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkGetState* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkState : public ::google::protobuf::Message {
 public:
  DebugLinkState();
  virtual ~DebugLinkState();

  DebugLinkState(const DebugLinkState& from);

  inline DebugLinkState& operator=(const DebugLinkState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkState& default_instance();

  void Swap(DebugLinkState* other);

  // implements Message ----------------------------------------------

  DebugLinkState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkState& from);
  void MergeFrom(const DebugLinkState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes layout = 1;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 1;
  inline const ::std::string& layout() const;
  inline void set_layout(const ::std::string& value);
  inline void set_layout(const char* value);
  inline void set_layout(const void* value, size_t size);
  inline ::std::string* mutable_layout();
  inline ::std::string* release_layout();
  inline void set_allocated_layout(::std::string* layout);

  // optional string pin = 2;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 2;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const char* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // optional string matrix = 3;
  inline bool has_matrix() const;
  inline void clear_matrix();
  static const int kMatrixFieldNumber = 3;
  inline const ::std::string& matrix() const;
  inline void set_matrix(const ::std::string& value);
  inline void set_matrix(const char* value);
  inline void set_matrix(const char* value, size_t size);
  inline ::std::string* mutable_matrix();
  inline ::std::string* release_matrix();
  inline void set_allocated_matrix(::std::string* matrix);

  // optional string mnemonic = 4;
  inline bool has_mnemonic() const;
  inline void clear_mnemonic();
  static const int kMnemonicFieldNumber = 4;
  inline const ::std::string& mnemonic() const;
  inline void set_mnemonic(const ::std::string& value);
  inline void set_mnemonic(const char* value);
  inline void set_mnemonic(const char* value, size_t size);
  inline ::std::string* mutable_mnemonic();
  inline ::std::string* release_mnemonic();
  inline void set_allocated_mnemonic(::std::string* mnemonic);

  // optional .HDNodeType node = 5;
  inline bool has_node() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 5;
  inline const ::HDNodeType& node() const;
  inline ::HDNodeType* mutable_node();
  inline ::HDNodeType* release_node();
  inline void set_allocated_node(::HDNodeType* node);

  // optional bool passphrase_protection = 6;
  inline bool has_passphrase_protection() const;
  inline void clear_passphrase_protection();
  static const int kPassphraseProtectionFieldNumber = 6;
  inline bool passphrase_protection() const;
  inline void set_passphrase_protection(bool value);

  // optional string reset_word = 7;
  inline bool has_reset_word() const;
  inline void clear_reset_word();
  static const int kResetWordFieldNumber = 7;
  inline const ::std::string& reset_word() const;
  inline void set_reset_word(const ::std::string& value);
  inline void set_reset_word(const char* value);
  inline void set_reset_word(const char* value, size_t size);
  inline ::std::string* mutable_reset_word();
  inline ::std::string* release_reset_word();
  inline void set_allocated_reset_word(::std::string* reset_word);

  // optional bytes reset_entropy = 8;
  inline bool has_reset_entropy() const;
  inline void clear_reset_entropy();
  static const int kResetEntropyFieldNumber = 8;
  inline const ::std::string& reset_entropy() const;
  inline void set_reset_entropy(const ::std::string& value);
  inline void set_reset_entropy(const char* value);
  inline void set_reset_entropy(const void* value, size_t size);
  inline ::std::string* mutable_reset_entropy();
  inline ::std::string* release_reset_entropy();
  inline void set_allocated_reset_entropy(::std::string* reset_entropy);

  // optional string recovery_fake_word = 9;
  inline bool has_recovery_fake_word() const;
  inline void clear_recovery_fake_word();
  static const int kRecoveryFakeWordFieldNumber = 9;
  inline const ::std::string& recovery_fake_word() const;
  inline void set_recovery_fake_word(const ::std::string& value);
  inline void set_recovery_fake_word(const char* value);
  inline void set_recovery_fake_word(const char* value, size_t size);
  inline ::std::string* mutable_recovery_fake_word();
  inline ::std::string* release_recovery_fake_word();
  inline void set_allocated_recovery_fake_word(::std::string* recovery_fake_word);

  // optional uint32 recovery_word_pos = 10;
  inline bool has_recovery_word_pos() const;
  inline void clear_recovery_word_pos();
  static const int kRecoveryWordPosFieldNumber = 10;
  inline ::google::protobuf::uint32 recovery_word_pos() const;
  inline void set_recovery_word_pos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DebugLinkState)
 private:
  inline void set_has_layout();
  inline void clear_has_layout();
  inline void set_has_pin();
  inline void clear_has_pin();
  inline void set_has_matrix();
  inline void clear_has_matrix();
  inline void set_has_mnemonic();
  inline void clear_has_mnemonic();
  inline void set_has_node();
  inline void clear_has_node();
  inline void set_has_passphrase_protection();
  inline void clear_has_passphrase_protection();
  inline void set_has_reset_word();
  inline void clear_has_reset_word();
  inline void set_has_reset_entropy();
  inline void clear_has_reset_entropy();
  inline void set_has_recovery_fake_word();
  inline void clear_has_recovery_fake_word();
  inline void set_has_recovery_word_pos();
  inline void clear_has_recovery_word_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* layout_;
  ::std::string* pin_;
  ::std::string* matrix_;
  ::std::string* mnemonic_;
  ::HDNodeType* node_;
  ::std::string* reset_word_;
  ::std::string* reset_entropy_;
  bool passphrase_protection_;
  ::google::protobuf::uint32 recovery_word_pos_;
  ::std::string* recovery_fake_word_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkState* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkStop : public ::google::protobuf::Message {
 public:
  DebugLinkStop();
  virtual ~DebugLinkStop();

  DebugLinkStop(const DebugLinkStop& from);

  inline DebugLinkStop& operator=(const DebugLinkStop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkStop& default_instance();

  void Swap(DebugLinkStop* other);

  // implements Message ----------------------------------------------

  DebugLinkStop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkStop& from);
  void MergeFrom(const DebugLinkStop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DebugLinkStop)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkStop* default_instance_;
};
// -------------------------------------------------------------------

class DebugLinkLog : public ::google::protobuf::Message {
 public:
  DebugLinkLog();
  virtual ~DebugLinkLog();

  DebugLinkLog(const DebugLinkLog& from);

  inline DebugLinkLog& operator=(const DebugLinkLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugLinkLog& default_instance();

  void Swap(DebugLinkLog* other);

  // implements Message ----------------------------------------------

  DebugLinkLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DebugLinkLog& from);
  void MergeFrom(const DebugLinkLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional string bucket = 2;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 2;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:DebugLinkLog)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_bucket();
  inline void clear_has_bucket();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bucket_;
  ::std::string* text_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static DebugLinkLog* default_instance_;
};
// ===================================================================


// ===================================================================

// Initialize

// -------------------------------------------------------------------

// Features

// optional string vendor = 1;
inline bool Features::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Features::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Features::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Features::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Features::vendor() const {
  return *vendor_;
}
inline void Features::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Features::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* Features::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 major_version = 2;
inline bool Features::has_major_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Features::set_has_major_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Features::clear_has_major_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Features::clear_major_version() {
  major_version_ = 0u;
  clear_has_major_version();
}
inline ::google::protobuf::uint32 Features::major_version() const {
  return major_version_;
}
inline void Features::set_major_version(::google::protobuf::uint32 value) {
  set_has_major_version();
  major_version_ = value;
}

// optional uint32 minor_version = 3;
inline bool Features::has_minor_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Features::set_has_minor_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Features::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Features::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 Features::minor_version() const {
  return minor_version_;
}
inline void Features::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
}

// optional uint32 patch_version = 4;
inline bool Features::has_patch_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Features::set_has_patch_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Features::clear_has_patch_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Features::clear_patch_version() {
  patch_version_ = 0u;
  clear_has_patch_version();
}
inline ::google::protobuf::uint32 Features::patch_version() const {
  return patch_version_;
}
inline void Features::set_patch_version(::google::protobuf::uint32 value) {
  set_has_patch_version();
  patch_version_ = value;
}

// optional bool bootloader_mode = 5;
inline bool Features::has_bootloader_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Features::set_has_bootloader_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Features::clear_has_bootloader_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Features::clear_bootloader_mode() {
  bootloader_mode_ = false;
  clear_has_bootloader_mode();
}
inline bool Features::bootloader_mode() const {
  return bootloader_mode_;
}
inline void Features::set_bootloader_mode(bool value) {
  set_has_bootloader_mode();
  bootloader_mode_ = value;
}

// optional string device_id = 6;
inline bool Features::has_device_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Features::set_has_device_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Features::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Features::clear_device_id() {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    device_id_->clear();
  }
  clear_has_device_id();
}
inline const ::std::string& Features::device_id() const {
  return *device_id_;
}
inline void Features::set_device_id(const ::std::string& value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void Features::set_device_id(const char* value) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(value);
}
inline void Features::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  device_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_device_id() {
  set_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    device_id_ = new ::std::string;
  }
  return device_id_;
}
inline ::std::string* Features::release_device_id() {
  clear_has_device_id();
  if (device_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_id_;
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_device_id(::std::string* device_id) {
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (device_id) {
    set_has_device_id();
    device_id_ = device_id;
  } else {
    clear_has_device_id();
    device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool pin_protection = 7;
inline bool Features::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Features::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Features::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Features::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Features::pin_protection() const {
  return pin_protection_;
}
inline void Features::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
}

// optional bool passphrase_protection = 8;
inline bool Features::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Features::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Features::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Features::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Features::passphrase_protection() const {
  return passphrase_protection_;
}
inline void Features::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// optional string language = 9;
inline bool Features::has_language() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Features::set_has_language() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Features::clear_has_language() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Features::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& Features::language() const {
  return *language_;
}
inline void Features::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Features::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void Features::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* Features::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label = 10;
inline bool Features::has_label() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Features::set_has_label() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Features::clear_has_label() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Features::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& Features::label() const {
  return *label_;
}
inline void Features::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Features::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void Features::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* Features::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .CoinType coins = 11;
inline int Features::coins_size() const {
  return coins_.size();
}
inline void Features::clear_coins() {
  coins_.Clear();
}
inline const ::CoinType& Features::coins(int index) const {
  return coins_.Get(index);
}
inline ::CoinType* Features::mutable_coins(int index) {
  return coins_.Mutable(index);
}
inline ::CoinType* Features::add_coins() {
  return coins_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoinType >&
Features::coins() const {
  return coins_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoinType >*
Features::mutable_coins() {
  return &coins_;
}

// optional bool initialized = 12;
inline bool Features::has_initialized() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Features::set_has_initialized() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Features::clear_has_initialized() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Features::clear_initialized() {
  initialized_ = false;
  clear_has_initialized();
}
inline bool Features::initialized() const {
  return initialized_;
}
inline void Features::set_initialized(bool value) {
  set_has_initialized();
  initialized_ = value;
}

// optional bytes revision = 13;
inline bool Features::has_revision() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Features::set_has_revision() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Features::clear_has_revision() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Features::clear_revision() {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    revision_->clear();
  }
  clear_has_revision();
}
inline const ::std::string& Features::revision() const {
  return *revision_;
}
inline void Features::set_revision(const ::std::string& value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void Features::set_revision(const char* value) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(value);
}
inline void Features::set_revision(const void* value, size_t size) {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  revision_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_revision() {
  set_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    revision_ = new ::std::string;
  }
  return revision_;
}
inline ::std::string* Features::release_revision() {
  clear_has_revision();
  if (revision_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = revision_;
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_revision(::std::string* revision) {
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (revision) {
    set_has_revision();
    revision_ = revision;
  } else {
    clear_has_revision();
    revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes bootloader_hash = 14;
inline bool Features::has_bootloader_hash() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Features::set_has_bootloader_hash() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Features::clear_has_bootloader_hash() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Features::clear_bootloader_hash() {
  if (bootloader_hash_ != &::google::protobuf::internal::kEmptyString) {
    bootloader_hash_->clear();
  }
  clear_has_bootloader_hash();
}
inline const ::std::string& Features::bootloader_hash() const {
  return *bootloader_hash_;
}
inline void Features::set_bootloader_hash(const ::std::string& value) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(value);
}
inline void Features::set_bootloader_hash(const char* value) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(value);
}
inline void Features::set_bootloader_hash(const void* value, size_t size) {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_hash_ = new ::std::string;
  }
  bootloader_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_bootloader_hash() {
  set_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::kEmptyString) {
    bootloader_hash_ = new ::std::string;
  }
  return bootloader_hash_;
}
inline ::std::string* Features::release_bootloader_hash() {
  clear_has_bootloader_hash();
  if (bootloader_hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bootloader_hash_;
    bootloader_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_bootloader_hash(::std::string* bootloader_hash) {
  if (bootloader_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete bootloader_hash_;
  }
  if (bootloader_hash) {
    set_has_bootloader_hash();
    bootloader_hash_ = bootloader_hash;
  } else {
    clear_has_bootloader_hash();
    bootloader_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool imported = 15;
inline bool Features::has_imported() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Features::set_has_imported() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Features::clear_has_imported() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Features::clear_imported() {
  imported_ = false;
  clear_has_imported();
}
inline bool Features::imported() const {
  return imported_;
}
inline void Features::set_imported(bool value) {
  set_has_imported();
  imported_ = value;
}

// optional string cpu_sn = 16;
inline bool Features::has_cpu_sn() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Features::set_has_cpu_sn() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Features::clear_has_cpu_sn() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Features::clear_cpu_sn() {
  if (cpu_sn_ != &::google::protobuf::internal::kEmptyString) {
    cpu_sn_->clear();
  }
  clear_has_cpu_sn();
}
inline const ::std::string& Features::cpu_sn() const {
  return *cpu_sn_;
}
inline void Features::set_cpu_sn(const ::std::string& value) {
  set_has_cpu_sn();
  if (cpu_sn_ == &::google::protobuf::internal::kEmptyString) {
    cpu_sn_ = new ::std::string;
  }
  cpu_sn_->assign(value);
}
inline void Features::set_cpu_sn(const char* value) {
  set_has_cpu_sn();
  if (cpu_sn_ == &::google::protobuf::internal::kEmptyString) {
    cpu_sn_ = new ::std::string;
  }
  cpu_sn_->assign(value);
}
inline void Features::set_cpu_sn(const char* value, size_t size) {
  set_has_cpu_sn();
  if (cpu_sn_ == &::google::protobuf::internal::kEmptyString) {
    cpu_sn_ = new ::std::string;
  }
  cpu_sn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Features::mutable_cpu_sn() {
  set_has_cpu_sn();
  if (cpu_sn_ == &::google::protobuf::internal::kEmptyString) {
    cpu_sn_ = new ::std::string;
  }
  return cpu_sn_;
}
inline ::std::string* Features::release_cpu_sn() {
  clear_has_cpu_sn();
  if (cpu_sn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cpu_sn_;
    cpu_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Features::set_allocated_cpu_sn(::std::string* cpu_sn) {
  if (cpu_sn_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_sn_;
  }
  if (cpu_sn) {
    set_has_cpu_sn();
    cpu_sn_ = cpu_sn;
  } else {
    clear_has_cpu_sn();
    cpu_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ClearSession

// -------------------------------------------------------------------

// ApplySettings

// optional string language = 1;
inline bool ApplySettings::has_language() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplySettings::set_has_language() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplySettings::clear_has_language() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplySettings::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& ApplySettings::language() const {
  return *language_;
}
inline void ApplySettings::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ApplySettings::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ApplySettings::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplySettings::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* ApplySettings::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplySettings::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label = 2;
inline bool ApplySettings::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplySettings::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplySettings::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplySettings::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ApplySettings::label() const {
  return *label_;
}
inline void ApplySettings::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ApplySettings::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ApplySettings::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplySettings::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* ApplySettings::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplySettings::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangePin

// optional bool remove = 1;
inline bool ChangePin::has_remove() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePin::set_has_remove() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePin::clear_has_remove() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePin::clear_remove() {
  remove_ = false;
  clear_has_remove();
}
inline bool ChangePin::remove() const {
  return remove_;
}
inline void ChangePin::set_remove(bool value) {
  set_has_remove();
  remove_ = value;
}

// -------------------------------------------------------------------

// Ping

// optional string message = 1;
inline bool Ping::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Ping::message() const {
  return *message_;
}
inline void Ping::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Ping::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ping::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Ping::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Ping::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool button_protection = 2;
inline bool Ping::has_button_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_button_protection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_button_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_button_protection() {
  button_protection_ = false;
  clear_has_button_protection();
}
inline bool Ping::button_protection() const {
  return button_protection_;
}
inline void Ping::set_button_protection(bool value) {
  set_has_button_protection();
  button_protection_ = value;
}

// optional bool pin_protection = 3;
inline bool Ping::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ping::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ping::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool Ping::pin_protection() const {
  return pin_protection_;
}
inline void Ping::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
}

// optional bool passphrase_protection = 4;
inline bool Ping::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ping::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ping::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool Ping::passphrase_protection() const {
  return passphrase_protection_;
}
inline void Ping::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// -------------------------------------------------------------------

// Success

// optional string message = 1;
inline bool Success::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Success::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Success::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Success::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Success::message() const {
  return *message_;
}
inline void Success::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Success::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Success::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Success::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Success::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes payload = 2;
inline bool Success::has_payload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Success::set_has_payload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Success::clear_has_payload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Success::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& Success::payload() const {
  return *payload_;
}
inline void Success::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Success::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void Success::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Success::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* Success::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Success::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Failure

// optional .FailureType code = 1;
inline bool Failure::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Failure::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Failure::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Failure::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::FailureType Failure::code() const {
  return static_cast< ::FailureType >(code_);
}
inline void Failure::set_code(::FailureType value) {
  assert(::FailureType_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string message = 2;
inline bool Failure::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Failure::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Failure::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Failure::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Failure::message() const {
  return *message_;
}
inline void Failure::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void Failure::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Failure::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* Failure::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Failure::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ButtonRequest

// optional .ButtonRequestType code = 1;
inline bool ButtonRequest::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ButtonRequest::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ButtonRequest::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ButtonRequest::clear_code() {
  code_ = 1;
  clear_has_code();
}
inline ::ButtonRequestType ButtonRequest::code() const {
  return static_cast< ::ButtonRequestType >(code_);
}
inline void ButtonRequest::set_code(::ButtonRequestType value) {
  assert(::ButtonRequestType_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string data = 2;
inline bool ButtonRequest::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ButtonRequest::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ButtonRequest::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ButtonRequest::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ButtonRequest::data() const {
  return *data_;
}
inline void ButtonRequest::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ButtonRequest::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ButtonRequest::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonRequest::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* ButtonRequest::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonRequest::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ButtonAck

// -------------------------------------------------------------------

// PinMatrixRequest

// optional .PinMatrixRequestType type = 1;
inline bool PinMatrixRequest::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixRequest::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixRequest::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixRequest::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PinMatrixRequestType PinMatrixRequest::type() const {
  return static_cast< ::PinMatrixRequestType >(type_);
}
inline void PinMatrixRequest::set_type(::PinMatrixRequestType value) {
  assert(::PinMatrixRequestType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PinMatrixAck

// required string pin = 1;
inline bool PinMatrixAck::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PinMatrixAck::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PinMatrixAck::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PinMatrixAck::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& PinMatrixAck::pin() const {
  return *pin_;
}
inline void PinMatrixAck::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinMatrixAck::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void PinMatrixAck::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PinMatrixAck::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* PinMatrixAck::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PinMatrixAck::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Cancel

// -------------------------------------------------------------------

// PassphraseRequest

// -------------------------------------------------------------------

// PassphraseAck

// required string passphrase = 1;
inline bool PassphraseAck::has_passphrase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PassphraseAck::set_has_passphrase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PassphraseAck::clear_has_passphrase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PassphraseAck::clear_passphrase() {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    passphrase_->clear();
  }
  clear_has_passphrase();
}
inline const ::std::string& PassphraseAck::passphrase() const {
  return *passphrase_;
}
inline void PassphraseAck::set_passphrase(const ::std::string& value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void PassphraseAck::set_passphrase(const char* value) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(value);
}
inline void PassphraseAck::set_passphrase(const char* value, size_t size) {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  passphrase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PassphraseAck::mutable_passphrase() {
  set_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    passphrase_ = new ::std::string;
  }
  return passphrase_;
}
inline ::std::string* PassphraseAck::release_passphrase() {
  clear_has_passphrase();
  if (passphrase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passphrase_;
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PassphraseAck::set_allocated_passphrase(::std::string* passphrase) {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    delete passphrase_;
  }
  if (passphrase) {
    set_has_passphrase();
    passphrase_ = passphrase;
  } else {
    clear_has_passphrase();
    passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetEntropy

// required uint32 size = 1;
inline bool GetEntropy::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetEntropy::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetEntropy::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetEntropy::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 GetEntropy::size() const {
  return size_;
}
inline void GetEntropy::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// -------------------------------------------------------------------

// Entropy

// required bytes entropy = 1;
inline bool Entropy::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entropy::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entropy::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entropy::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& Entropy::entropy() const {
  return *entropy_;
}
inline void Entropy::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void Entropy::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entropy::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  return entropy_;
}
inline ::std::string* Entropy::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entropy::set_allocated_entropy(::std::string* entropy) {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (entropy) {
    set_has_entropy();
    entropy_ = entropy;
  } else {
    clear_has_entropy();
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetPublicKey

// repeated uint32 address_n = 1;
inline int GetPublicKey::address_n_size() const {
  return address_n_.size();
}
inline void GetPublicKey::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetPublicKey::address_n(int index) const {
  return address_n_.Get(index);
}
inline void GetPublicKey::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void GetPublicKey::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetPublicKey::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetPublicKey::mutable_address_n() {
  return &address_n_;
}

// -------------------------------------------------------------------

// PublicKey

// required .HDNodeType node = 1;
inline bool PublicKey::has_node() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicKey::set_has_node() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicKey::clear_has_node() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicKey::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& PublicKey::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* PublicKey::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  return node_;
}
inline ::HDNodeType* PublicKey::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void PublicKey::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional string xpub = 2;
inline bool PublicKey::has_xpub() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicKey::set_has_xpub() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicKey::clear_has_xpub() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicKey::clear_xpub() {
  if (xpub_ != &::google::protobuf::internal::kEmptyString) {
    xpub_->clear();
  }
  clear_has_xpub();
}
inline const ::std::string& PublicKey::xpub() const {
  return *xpub_;
}
inline void PublicKey::set_xpub(const ::std::string& value) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::kEmptyString) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(value);
}
inline void PublicKey::set_xpub(const char* value) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::kEmptyString) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(value);
}
inline void PublicKey::set_xpub(const char* value, size_t size) {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::kEmptyString) {
    xpub_ = new ::std::string;
  }
  xpub_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicKey::mutable_xpub() {
  set_has_xpub();
  if (xpub_ == &::google::protobuf::internal::kEmptyString) {
    xpub_ = new ::std::string;
  }
  return xpub_;
}
inline ::std::string* PublicKey::release_xpub() {
  clear_has_xpub();
  if (xpub_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xpub_;
    xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PublicKey::set_allocated_xpub(::std::string* xpub) {
  if (xpub_ != &::google::protobuf::internal::kEmptyString) {
    delete xpub_;
  }
  if (xpub) {
    set_has_xpub();
    xpub_ = xpub;
  } else {
    clear_has_xpub();
    xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetAddress

// repeated uint32 address_n = 1;
inline int GetAddress::address_n_size() const {
  return address_n_.size();
}
inline void GetAddress::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 GetAddress::address_n(int index) const {
  return address_n_.Get(index);
}
inline void GetAddress::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void GetAddress::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GetAddress::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GetAddress::mutable_address_n() {
  return &address_n_;
}

// optional string coin_name = 2 [default = "Bitcoin"];
inline bool GetAddress::has_coin_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAddress::set_has_coin_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAddress::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAddress::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& GetAddress::coin_name() const {
  return *coin_name_;
}
inline void GetAddress::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void GetAddress::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void GetAddress::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetAddress::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  return coin_name_;
}
inline ::std::string* GetAddress::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void GetAddress::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
}

// optional bool show_display = 3;
inline bool GetAddress::has_show_display() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetAddress::set_has_show_display() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetAddress::clear_has_show_display() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetAddress::clear_show_display() {
  show_display_ = false;
  clear_has_show_display();
}
inline bool GetAddress::show_display() const {
  return show_display_;
}
inline void GetAddress::set_show_display(bool value) {
  set_has_show_display();
  show_display_ = value;
}

// -------------------------------------------------------------------

// Address

// required string address = 1;
inline bool Address::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Address::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Address::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Address::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& Address::address() const {
  return *address_;
}
inline void Address::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void Address::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Address::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* Address::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Address::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WipeDevice

// -------------------------------------------------------------------

// LoadDevice

// optional string mnemonic = 1;
inline bool LoadDevice::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadDevice::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadDevice::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadDevice::clear_mnemonic() {
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    mnemonic_->clear();
  }
  clear_has_mnemonic();
}
inline const ::std::string& LoadDevice::mnemonic() const {
  return *mnemonic_;
}
inline void LoadDevice::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
}
inline void LoadDevice::set_mnemonic(const char* value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
}
inline void LoadDevice::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_mnemonic() {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  return mnemonic_;
}
inline ::std::string* LoadDevice::release_mnemonic() {
  clear_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mnemonic_;
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadDevice::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    delete mnemonic_;
  }
  if (mnemonic) {
    set_has_mnemonic();
    mnemonic_ = mnemonic;
  } else {
    clear_has_mnemonic();
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .HDNodeType node = 2;
inline bool LoadDevice::has_node() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadDevice::set_has_node() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadDevice::clear_has_node() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadDevice::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& LoadDevice::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* LoadDevice::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  return node_;
}
inline ::HDNodeType* LoadDevice::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void LoadDevice::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional string pin = 3;
inline bool LoadDevice::has_pin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadDevice::set_has_pin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadDevice::clear_has_pin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadDevice::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& LoadDevice::pin() const {
  return *pin_;
}
inline void LoadDevice::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void LoadDevice::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* LoadDevice::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadDevice::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool passphrase_protection = 4;
inline bool LoadDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool LoadDevice::passphrase_protection() const {
  return passphrase_protection_;
}
inline void LoadDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// optional string language = 5 [default = "english"];
inline bool LoadDevice::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadDevice::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& LoadDevice::language() const {
  return *language_;
}
inline void LoadDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void LoadDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void LoadDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  return language_;
}
inline ::std::string* LoadDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void LoadDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
}

// optional string label = 6;
inline bool LoadDevice::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoadDevice::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoadDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoadDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& LoadDevice::label() const {
  return *label_;
}
inline void LoadDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void LoadDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void LoadDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* LoadDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool skip_checksum = 7;
inline bool LoadDevice::has_skip_checksum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoadDevice::set_has_skip_checksum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoadDevice::clear_has_skip_checksum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoadDevice::clear_skip_checksum() {
  skip_checksum_ = false;
  clear_has_skip_checksum();
}
inline bool LoadDevice::skip_checksum() const {
  return skip_checksum_;
}
inline void LoadDevice::set_skip_checksum(bool value) {
  set_has_skip_checksum();
  skip_checksum_ = value;
}

// -------------------------------------------------------------------

// ResetDevice

// optional bool display_random = 1;
inline bool ResetDevice::has_display_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetDevice::set_has_display_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetDevice::clear_has_display_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetDevice::clear_display_random() {
  display_random_ = false;
  clear_has_display_random();
}
inline bool ResetDevice::display_random() const {
  return display_random_;
}
inline void ResetDevice::set_display_random(bool value) {
  set_has_display_random();
  display_random_ = value;
}

// optional uint32 strength = 2 [default = 128];
inline bool ResetDevice::has_strength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResetDevice::set_has_strength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResetDevice::clear_has_strength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResetDevice::clear_strength() {
  strength_ = 128u;
  clear_has_strength();
}
inline ::google::protobuf::uint32 ResetDevice::strength() const {
  return strength_;
}
inline void ResetDevice::set_strength(::google::protobuf::uint32 value) {
  set_has_strength();
  strength_ = value;
}

// optional bool passphrase_protection = 3;
inline bool ResetDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResetDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResetDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResetDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool ResetDevice::passphrase_protection() const {
  return passphrase_protection_;
}
inline void ResetDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// optional bool pin_protection = 4;
inline bool ResetDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResetDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResetDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResetDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool ResetDevice::pin_protection() const {
  return pin_protection_;
}
inline void ResetDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
}

// optional string language = 5 [default = "english"];
inline bool ResetDevice::has_language() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResetDevice::set_has_language() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResetDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResetDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& ResetDevice::language() const {
  return *language_;
}
inline void ResetDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ResetDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void ResetDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResetDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  return language_;
}
inline ::std::string* ResetDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void ResetDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
}

// optional string label = 6;
inline bool ResetDevice::has_label() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResetDevice::set_has_label() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResetDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResetDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& ResetDevice::label() const {
  return *label_;
}
inline void ResetDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ResetDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void ResetDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResetDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* ResetDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResetDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EntropyRequest

// -------------------------------------------------------------------

// EntropyAck

// optional bytes entropy = 1;
inline bool EntropyAck::has_entropy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntropyAck::set_has_entropy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntropyAck::clear_has_entropy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntropyAck::clear_entropy() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    entropy_->clear();
  }
  clear_has_entropy();
}
inline const ::std::string& EntropyAck::entropy() const {
  return *entropy_;
}
inline void EntropyAck::set_entropy(const ::std::string& value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void EntropyAck::set_entropy(const char* value) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(value);
}
inline void EntropyAck::set_entropy(const void* value, size_t size) {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  entropy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntropyAck::mutable_entropy() {
  set_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    entropy_ = new ::std::string;
  }
  return entropy_;
}
inline ::std::string* EntropyAck::release_entropy() {
  clear_has_entropy();
  if (entropy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = entropy_;
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EntropyAck::set_allocated_entropy(::std::string* entropy) {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (entropy) {
    set_has_entropy();
    entropy_ = entropy;
  } else {
    clear_has_entropy();
    entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RecoveryDevice

// optional uint32 word_count = 1;
inline bool RecoveryDevice::has_word_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecoveryDevice::set_has_word_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecoveryDevice::clear_has_word_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecoveryDevice::clear_word_count() {
  word_count_ = 0u;
  clear_has_word_count();
}
inline ::google::protobuf::uint32 RecoveryDevice::word_count() const {
  return word_count_;
}
inline void RecoveryDevice::set_word_count(::google::protobuf::uint32 value) {
  set_has_word_count();
  word_count_ = value;
}

// optional bool passphrase_protection = 2;
inline bool RecoveryDevice::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecoveryDevice::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecoveryDevice::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecoveryDevice::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool RecoveryDevice::passphrase_protection() const {
  return passphrase_protection_;
}
inline void RecoveryDevice::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// optional bool pin_protection = 3;
inline bool RecoveryDevice::has_pin_protection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecoveryDevice::set_has_pin_protection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecoveryDevice::clear_has_pin_protection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecoveryDevice::clear_pin_protection() {
  pin_protection_ = false;
  clear_has_pin_protection();
}
inline bool RecoveryDevice::pin_protection() const {
  return pin_protection_;
}
inline void RecoveryDevice::set_pin_protection(bool value) {
  set_has_pin_protection();
  pin_protection_ = value;
}

// optional string language = 4 [default = "english"];
inline bool RecoveryDevice::has_language() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecoveryDevice::set_has_language() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecoveryDevice::clear_has_language() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecoveryDevice::clear_language() {
  if (language_ != _default_language_) {
    language_->assign(*_default_language_);
  }
  clear_has_language();
}
inline const ::std::string& RecoveryDevice::language() const {
  return *language_;
}
inline void RecoveryDevice::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void RecoveryDevice::set_language(const char* value) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void RecoveryDevice::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecoveryDevice::mutable_language() {
  set_has_language();
  if (language_ == _default_language_) {
    language_ = new ::std::string(*_default_language_);
  }
  return language_;
}
inline ::std::string* RecoveryDevice::release_language() {
  clear_has_language();
  if (language_ == _default_language_) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(_default_language_);
    return temp;
  }
}
inline void RecoveryDevice::set_allocated_language(::std::string* language) {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(_default_language_);
  }
}

// optional string label = 5;
inline bool RecoveryDevice::has_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecoveryDevice::set_has_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecoveryDevice::clear_has_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecoveryDevice::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& RecoveryDevice::label() const {
  return *label_;
}
inline void RecoveryDevice::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void RecoveryDevice::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void RecoveryDevice::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecoveryDevice::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* RecoveryDevice::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecoveryDevice::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enforce_wordlist = 6;
inline bool RecoveryDevice::has_enforce_wordlist() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RecoveryDevice::set_has_enforce_wordlist() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RecoveryDevice::clear_has_enforce_wordlist() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RecoveryDevice::clear_enforce_wordlist() {
  enforce_wordlist_ = false;
  clear_has_enforce_wordlist();
}
inline bool RecoveryDevice::enforce_wordlist() const {
  return enforce_wordlist_;
}
inline void RecoveryDevice::set_enforce_wordlist(bool value) {
  set_has_enforce_wordlist();
  enforce_wordlist_ = value;
}

// -------------------------------------------------------------------

// WordRequest

// -------------------------------------------------------------------

// WordAck

// required string word = 1;
inline bool WordAck::has_word() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordAck::set_has_word() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordAck::clear_has_word() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordAck::clear_word() {
  if (word_ != &::google::protobuf::internal::kEmptyString) {
    word_->clear();
  }
  clear_has_word();
}
inline const ::std::string& WordAck::word() const {
  return *word_;
}
inline void WordAck::set_word(const ::std::string& value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::kEmptyString) {
    word_ = new ::std::string;
  }
  word_->assign(value);
}
inline void WordAck::set_word(const char* value) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::kEmptyString) {
    word_ = new ::std::string;
  }
  word_->assign(value);
}
inline void WordAck::set_word(const char* value, size_t size) {
  set_has_word();
  if (word_ == &::google::protobuf::internal::kEmptyString) {
    word_ = new ::std::string;
  }
  word_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WordAck::mutable_word() {
  set_has_word();
  if (word_ == &::google::protobuf::internal::kEmptyString) {
    word_ = new ::std::string;
  }
  return word_;
}
inline ::std::string* WordAck::release_word() {
  clear_has_word();
  if (word_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = word_;
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WordAck::set_allocated_word(::std::string* word) {
  if (word_ != &::google::protobuf::internal::kEmptyString) {
    delete word_;
  }
  if (word) {
    set_has_word();
    word_ = word;
  } else {
    clear_has_word();
    word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SignMessage

// repeated uint32 address_n = 1;
inline int SignMessage::address_n_size() const {
  return address_n_.size();
}
inline void SignMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 SignMessage::address_n(int index) const {
  return address_n_.Get(index);
}
inline void SignMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void SignMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
SignMessage::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
SignMessage::mutable_address_n() {
  return &address_n_;
}

// required bytes message = 2;
inline bool SignMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& SignMessage::message() const {
  return *message_;
}
inline void SignMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void SignMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* SignMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SignMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignMessage::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignMessage::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignMessage::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignMessage::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& SignMessage::coin_name() const {
  return *coin_name_;
}
inline void SignMessage::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SignMessage::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SignMessage::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignMessage::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  return coin_name_;
}
inline ::std::string* SignMessage::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void SignMessage::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
}

// -------------------------------------------------------------------

// VerifyMessage

// optional string address = 1;
inline bool VerifyMessage::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VerifyMessage::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VerifyMessage::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VerifyMessage::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& VerifyMessage::address() const {
  return *address_;
}
inline void VerifyMessage::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void VerifyMessage::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void VerifyMessage::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyMessage::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* VerifyMessage::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyMessage::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool VerifyMessage::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VerifyMessage::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VerifyMessage::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VerifyMessage::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& VerifyMessage::signature() const {
  return *signature_;
}
inline void VerifyMessage::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void VerifyMessage::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void VerifyMessage::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyMessage::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* VerifyMessage::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyMessage::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes message = 3;
inline bool VerifyMessage::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VerifyMessage::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VerifyMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VerifyMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& VerifyMessage::message() const {
  return *message_;
}
inline void VerifyMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void VerifyMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void VerifyMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VerifyMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* VerifyMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VerifyMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageSignature

// optional string address = 1;
inline bool MessageSignature::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageSignature::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageSignature::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageSignature::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& MessageSignature::address() const {
  return *address_;
}
inline void MessageSignature::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void MessageSignature::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void MessageSignature::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageSignature::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* MessageSignature::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageSignature::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes signature = 2;
inline bool MessageSignature::has_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageSignature::set_has_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageSignature::clear_has_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageSignature::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& MessageSignature::signature() const {
  return *signature_;
}
inline void MessageSignature::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void MessageSignature::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void MessageSignature::set_signature(const void* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageSignature::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* MessageSignature::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageSignature::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EncryptMessage

// optional bytes pubkey = 1;
inline bool EncryptMessage::has_pubkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptMessage::set_has_pubkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptMessage::clear_has_pubkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptMessage::clear_pubkey() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    pubkey_->clear();
  }
  clear_has_pubkey();
}
inline const ::std::string& EncryptMessage::pubkey() const {
  return *pubkey_;
}
inline void EncryptMessage::set_pubkey(const ::std::string& value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void EncryptMessage::set_pubkey(const char* value) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(value);
}
inline void EncryptMessage::set_pubkey(const void* value, size_t size) {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  pubkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptMessage::mutable_pubkey() {
  set_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    pubkey_ = new ::std::string;
  }
  return pubkey_;
}
inline ::std::string* EncryptMessage::release_pubkey() {
  clear_has_pubkey();
  if (pubkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pubkey_;
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptMessage::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (pubkey) {
    set_has_pubkey();
    pubkey_ = pubkey;
  } else {
    clear_has_pubkey();
    pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes message = 2;
inline bool EncryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncryptMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& EncryptMessage::message() const {
  return *message_;
}
inline void EncryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void EncryptMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void EncryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* EncryptMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool display_only = 3;
inline bool EncryptMessage::has_display_only() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncryptMessage::set_has_display_only() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncryptMessage::clear_has_display_only() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncryptMessage::clear_display_only() {
  display_only_ = false;
  clear_has_display_only();
}
inline bool EncryptMessage::display_only() const {
  return display_only_;
}
inline void EncryptMessage::set_display_only(bool value) {
  set_has_display_only();
  display_only_ = value;
}

// repeated uint32 address_n = 4;
inline int EncryptMessage::address_n_size() const {
  return address_n_.size();
}
inline void EncryptMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 EncryptMessage::address_n(int index) const {
  return address_n_.Get(index);
}
inline void EncryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void EncryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EncryptMessage::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EncryptMessage::mutable_address_n() {
  return &address_n_;
}

// -------------------------------------------------------------------

// DecryptMessage

// repeated uint32 address_n = 1;
inline int DecryptMessage::address_n_size() const {
  return address_n_.size();
}
inline void DecryptMessage::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 DecryptMessage::address_n(int index) const {
  return address_n_.Get(index);
}
inline void DecryptMessage::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void DecryptMessage::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DecryptMessage::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DecryptMessage::mutable_address_n() {
  return &address_n_;
}

// optional bytes message = 2;
inline bool DecryptMessage::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecryptMessage::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecryptMessage::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecryptMessage::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& DecryptMessage::message() const {
  return *message_;
}
inline void DecryptMessage::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DecryptMessage::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void DecryptMessage::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecryptMessage::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* DecryptMessage::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DecryptMessage::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CipherKeyValue

// repeated uint32 address_n = 1;
inline int CipherKeyValue::address_n_size() const {
  return address_n_.size();
}
inline void CipherKeyValue::clear_address_n() {
  address_n_.Clear();
}
inline ::google::protobuf::uint32 CipherKeyValue::address_n(int index) const {
  return address_n_.Get(index);
}
inline void CipherKeyValue::set_address_n(int index, ::google::protobuf::uint32 value) {
  address_n_.Set(index, value);
}
inline void CipherKeyValue::add_address_n(::google::protobuf::uint32 value) {
  address_n_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CipherKeyValue::address_n() const {
  return address_n_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CipherKeyValue::mutable_address_n() {
  return &address_n_;
}

// optional string key = 2;
inline bool CipherKeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CipherKeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CipherKeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CipherKeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CipherKeyValue::key() const {
  return *key_;
}
inline void CipherKeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CipherKeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CipherKeyValue::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CipherKeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CipherKeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CipherKeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value = 3;
inline bool CipherKeyValue::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CipherKeyValue::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CipherKeyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CipherKeyValue::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CipherKeyValue::value() const {
  return *value_;
}
inline void CipherKeyValue::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CipherKeyValue::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CipherKeyValue::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CipherKeyValue::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* CipherKeyValue::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CipherKeyValue::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool encrypt = 4;
inline bool CipherKeyValue::has_encrypt() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CipherKeyValue::set_has_encrypt() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CipherKeyValue::clear_has_encrypt() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CipherKeyValue::clear_encrypt() {
  encrypt_ = false;
  clear_has_encrypt();
}
inline bool CipherKeyValue::encrypt() const {
  return encrypt_;
}
inline void CipherKeyValue::set_encrypt(bool value) {
  set_has_encrypt();
  encrypt_ = value;
}

// optional bool ask_on_encrypt = 5;
inline bool CipherKeyValue::has_ask_on_encrypt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CipherKeyValue::set_has_ask_on_encrypt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CipherKeyValue::clear_has_ask_on_encrypt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CipherKeyValue::clear_ask_on_encrypt() {
  ask_on_encrypt_ = false;
  clear_has_ask_on_encrypt();
}
inline bool CipherKeyValue::ask_on_encrypt() const {
  return ask_on_encrypt_;
}
inline void CipherKeyValue::set_ask_on_encrypt(bool value) {
  set_has_ask_on_encrypt();
  ask_on_encrypt_ = value;
}

// optional bool ask_on_decrypt = 6;
inline bool CipherKeyValue::has_ask_on_decrypt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CipherKeyValue::set_has_ask_on_decrypt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CipherKeyValue::clear_has_ask_on_decrypt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CipherKeyValue::clear_ask_on_decrypt() {
  ask_on_decrypt_ = false;
  clear_has_ask_on_decrypt();
}
inline bool CipherKeyValue::ask_on_decrypt() const {
  return ask_on_decrypt_;
}
inline void CipherKeyValue::set_ask_on_decrypt(bool value) {
  set_has_ask_on_decrypt();
  ask_on_decrypt_ = value;
}

// -------------------------------------------------------------------

// EstimateTxSize

// required uint32 outputs_count = 1;
inline bool EstimateTxSize::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EstimateTxSize::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EstimateTxSize::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EstimateTxSize::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 EstimateTxSize::outputs_count() const {
  return outputs_count_;
}
inline void EstimateTxSize::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
}

// required uint32 inputs_count = 2;
inline bool EstimateTxSize::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EstimateTxSize::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EstimateTxSize::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EstimateTxSize::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 EstimateTxSize::inputs_count() const {
  return inputs_count_;
}
inline void EstimateTxSize::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool EstimateTxSize::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EstimateTxSize::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EstimateTxSize::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EstimateTxSize::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& EstimateTxSize::coin_name() const {
  return *coin_name_;
}
inline void EstimateTxSize::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void EstimateTxSize::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void EstimateTxSize::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EstimateTxSize::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  return coin_name_;
}
inline ::std::string* EstimateTxSize::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void EstimateTxSize::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
}

// -------------------------------------------------------------------

// TxSize

// optional uint32 tx_size = 1;
inline bool TxSize::has_tx_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxSize::set_has_tx_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxSize::clear_has_tx_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxSize::clear_tx_size() {
  tx_size_ = 0u;
  clear_has_tx_size();
}
inline ::google::protobuf::uint32 TxSize::tx_size() const {
  return tx_size_;
}
inline void TxSize::set_tx_size(::google::protobuf::uint32 value) {
  set_has_tx_size();
  tx_size_ = value;
}

// -------------------------------------------------------------------

// SignTx

// required uint32 outputs_count = 1;
inline bool SignTx::has_outputs_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignTx::set_has_outputs_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignTx::clear_has_outputs_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignTx::clear_outputs_count() {
  outputs_count_ = 0u;
  clear_has_outputs_count();
}
inline ::google::protobuf::uint32 SignTx::outputs_count() const {
  return outputs_count_;
}
inline void SignTx::set_outputs_count(::google::protobuf::uint32 value) {
  set_has_outputs_count();
  outputs_count_ = value;
}

// required uint32 inputs_count = 2;
inline bool SignTx::has_inputs_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignTx::set_has_inputs_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignTx::clear_has_inputs_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignTx::clear_inputs_count() {
  inputs_count_ = 0u;
  clear_has_inputs_count();
}
inline ::google::protobuf::uint32 SignTx::inputs_count() const {
  return inputs_count_;
}
inline void SignTx::set_inputs_count(::google::protobuf::uint32 value) {
  set_has_inputs_count();
  inputs_count_ = value;
}

// optional string coin_name = 3 [default = "Bitcoin"];
inline bool SignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignTx::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& SignTx::coin_name() const {
  return *coin_name_;
}
inline void SignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SignTx::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignTx::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  return coin_name_;
}
inline ::std::string* SignTx::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void SignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
}

// -------------------------------------------------------------------

// SimpleSignTx

// repeated .TxInputType inputs = 1;
inline int SimpleSignTx::inputs_size() const {
  return inputs_.size();
}
inline void SimpleSignTx::clear_inputs() {
  inputs_.Clear();
}
inline const ::TxInputType& SimpleSignTx::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::TxInputType* SimpleSignTx::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::TxInputType* SimpleSignTx::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxInputType >&
SimpleSignTx::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxInputType >*
SimpleSignTx::mutable_inputs() {
  return &inputs_;
}

// repeated .TxOutputType outputs = 2;
inline int SimpleSignTx::outputs_size() const {
  return outputs_.size();
}
inline void SimpleSignTx::clear_outputs() {
  outputs_.Clear();
}
inline const ::TxOutputType& SimpleSignTx::outputs(int index) const {
  return outputs_.Get(index);
}
inline ::TxOutputType* SimpleSignTx::mutable_outputs(int index) {
  return outputs_.Mutable(index);
}
inline ::TxOutputType* SimpleSignTx::add_outputs() {
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TxOutputType >&
SimpleSignTx::outputs() const {
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::TxOutputType >*
SimpleSignTx::mutable_outputs() {
  return &outputs_;
}

// repeated .TransactionType transactions = 3;
inline int SimpleSignTx::transactions_size() const {
  return transactions_.size();
}
inline void SimpleSignTx::clear_transactions() {
  transactions_.Clear();
}
inline const ::TransactionType& SimpleSignTx::transactions(int index) const {
  return transactions_.Get(index);
}
inline ::TransactionType* SimpleSignTx::mutable_transactions(int index) {
  return transactions_.Mutable(index);
}
inline ::TransactionType* SimpleSignTx::add_transactions() {
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TransactionType >&
SimpleSignTx::transactions() const {
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::TransactionType >*
SimpleSignTx::mutable_transactions() {
  return &transactions_;
}

// optional string coin_name = 4 [default = "Bitcoin"];
inline bool SimpleSignTx::has_coin_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimpleSignTx::set_has_coin_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimpleSignTx::clear_has_coin_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimpleSignTx::clear_coin_name() {
  if (coin_name_ != _default_coin_name_) {
    coin_name_->assign(*_default_coin_name_);
  }
  clear_has_coin_name();
}
inline const ::std::string& SimpleSignTx::coin_name() const {
  return *coin_name_;
}
inline void SimpleSignTx::set_coin_name(const ::std::string& value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SimpleSignTx::set_coin_name(const char* value) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(value);
}
inline void SimpleSignTx::set_coin_name(const char* value, size_t size) {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string;
  }
  coin_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleSignTx::mutable_coin_name() {
  set_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    coin_name_ = new ::std::string(*_default_coin_name_);
  }
  return coin_name_;
}
inline ::std::string* SimpleSignTx::release_coin_name() {
  clear_has_coin_name();
  if (coin_name_ == _default_coin_name_) {
    return NULL;
  } else {
    ::std::string* temp = coin_name_;
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
    return temp;
  }
}
inline void SimpleSignTx::set_allocated_coin_name(::std::string* coin_name) {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (coin_name) {
    set_has_coin_name();
    coin_name_ = coin_name;
  } else {
    clear_has_coin_name();
    coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  }
}

// -------------------------------------------------------------------

// TxRequest

// optional .RequestType request_type = 1;
inline bool TxRequest::has_request_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxRequest::set_has_request_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxRequest::clear_has_request_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxRequest::clear_request_type() {
  request_type_ = 0;
  clear_has_request_type();
}
inline ::RequestType TxRequest::request_type() const {
  return static_cast< ::RequestType >(request_type_);
}
inline void TxRequest::set_request_type(::RequestType value) {
  assert(::RequestType_IsValid(value));
  set_has_request_type();
  request_type_ = value;
}

// optional .TxRequestDetailsType details = 2;
inline bool TxRequest::has_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TxRequest::set_has_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TxRequest::clear_has_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TxRequest::clear_details() {
  if (details_ != NULL) details_->::TxRequestDetailsType::Clear();
  clear_has_details();
}
inline const ::TxRequestDetailsType& TxRequest::details() const {
  return details_ != NULL ? *details_ : *default_instance_->details_;
}
inline ::TxRequestDetailsType* TxRequest::mutable_details() {
  set_has_details();
  if (details_ == NULL) details_ = new ::TxRequestDetailsType;
  return details_;
}
inline ::TxRequestDetailsType* TxRequest::release_details() {
  clear_has_details();
  ::TxRequestDetailsType* temp = details_;
  details_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_details(::TxRequestDetailsType* details) {
  delete details_;
  details_ = details;
  if (details) {
    set_has_details();
  } else {
    clear_has_details();
  }
}

// optional .TxRequestSerializedType serialized = 3;
inline bool TxRequest::has_serialized() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TxRequest::set_has_serialized() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TxRequest::clear_has_serialized() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TxRequest::clear_serialized() {
  if (serialized_ != NULL) serialized_->::TxRequestSerializedType::Clear();
  clear_has_serialized();
}
inline const ::TxRequestSerializedType& TxRequest::serialized() const {
  return serialized_ != NULL ? *serialized_ : *default_instance_->serialized_;
}
inline ::TxRequestSerializedType* TxRequest::mutable_serialized() {
  set_has_serialized();
  if (serialized_ == NULL) serialized_ = new ::TxRequestSerializedType;
  return serialized_;
}
inline ::TxRequestSerializedType* TxRequest::release_serialized() {
  clear_has_serialized();
  ::TxRequestSerializedType* temp = serialized_;
  serialized_ = NULL;
  return temp;
}
inline void TxRequest::set_allocated_serialized(::TxRequestSerializedType* serialized) {
  delete serialized_;
  serialized_ = serialized;
  if (serialized) {
    set_has_serialized();
  } else {
    clear_has_serialized();
  }
}

// -------------------------------------------------------------------

// TxAck

// optional .TransactionType tx = 1;
inline bool TxAck::has_tx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TxAck::set_has_tx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TxAck::clear_has_tx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TxAck::clear_tx() {
  if (tx_ != NULL) tx_->::TransactionType::Clear();
  clear_has_tx();
}
inline const ::TransactionType& TxAck::tx() const {
  return tx_ != NULL ? *tx_ : *default_instance_->tx_;
}
inline ::TransactionType* TxAck::mutable_tx() {
  set_has_tx();
  if (tx_ == NULL) tx_ = new ::TransactionType;
  return tx_;
}
inline ::TransactionType* TxAck::release_tx() {
  clear_has_tx();
  ::TransactionType* temp = tx_;
  tx_ = NULL;
  return temp;
}
inline void TxAck::set_allocated_tx(::TransactionType* tx) {
  delete tx_;
  tx_ = tx;
  if (tx) {
    set_has_tx();
  } else {
    clear_has_tx();
  }
}

// -------------------------------------------------------------------

// FirmwareErase

// -------------------------------------------------------------------

// FirmwareUpload

// required bytes payload = 1;
inline bool FirmwareUpload::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FirmwareUpload::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FirmwareUpload::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FirmwareUpload::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& FirmwareUpload::payload() const {
  return *payload_;
}
inline void FirmwareUpload::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void FirmwareUpload::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void FirmwareUpload::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FirmwareUpload::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* FirmwareUpload::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FirmwareUpload::set_allocated_payload(::std::string* payload) {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (payload) {
    set_has_payload();
    payload_ = payload;
  } else {
    clear_has_payload();
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TestScreen

// required uint32 delay_time = 1 [default = 1];
inline bool TestScreen::has_delay_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestScreen::set_has_delay_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestScreen::clear_has_delay_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestScreen::clear_delay_time() {
  delay_time_ = 1u;
  clear_has_delay_time();
}
inline ::google::protobuf::uint32 TestScreen::delay_time() const {
  return delay_time_;
}
inline void TestScreen::set_delay_time(::google::protobuf::uint32 value) {
  set_has_delay_time();
  delay_time_ = value;
}

// -------------------------------------------------------------------

// DebugLinkDecision

// required bool yes_no = 1;
inline bool DebugLinkDecision::has_yes_no() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkDecision::set_has_yes_no() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkDecision::clear_has_yes_no() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkDecision::clear_yes_no() {
  yes_no_ = false;
  clear_has_yes_no();
}
inline bool DebugLinkDecision::yes_no() const {
  return yes_no_;
}
inline void DebugLinkDecision::set_yes_no(bool value) {
  set_has_yes_no();
  yes_no_ = value;
}

// -------------------------------------------------------------------

// DebugLinkGetState

// -------------------------------------------------------------------

// DebugLinkState

// optional bytes layout = 1;
inline bool DebugLinkState::has_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkState::set_has_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkState::clear_has_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkState::clear_layout() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    layout_->clear();
  }
  clear_has_layout();
}
inline const ::std::string& DebugLinkState::layout() const {
  return *layout_;
}
inline void DebugLinkState::set_layout(const ::std::string& value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const char* value) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(value);
}
inline void DebugLinkState::set_layout(const void* value, size_t size) {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  layout_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_layout() {
  set_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    layout_ = new ::std::string;
  }
  return layout_;
}
inline ::std::string* DebugLinkState::release_layout() {
  clear_has_layout();
  if (layout_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = layout_;
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_layout(::std::string* layout) {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    delete layout_;
  }
  if (layout) {
    set_has_layout();
    layout_ = layout;
  } else {
    clear_has_layout();
    layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pin = 2;
inline bool DebugLinkState::has_pin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkState::set_has_pin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkState::clear_has_pin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkState::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& DebugLinkState::pin() const {
  return *pin_;
}
inline void DebugLinkState::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DebugLinkState::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void DebugLinkState::set_pin(const char* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* DebugLinkState::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string matrix = 3;
inline bool DebugLinkState::has_matrix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkState::set_has_matrix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkState::clear_has_matrix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkState::clear_matrix() {
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    matrix_->clear();
  }
  clear_has_matrix();
}
inline const ::std::string& DebugLinkState::matrix() const {
  return *matrix_;
}
inline void DebugLinkState::set_matrix(const ::std::string& value) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(value);
}
inline void DebugLinkState::set_matrix(const char* value) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(value);
}
inline void DebugLinkState::set_matrix(const char* value, size_t size) {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  matrix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_matrix() {
  set_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    matrix_ = new ::std::string;
  }
  return matrix_;
}
inline ::std::string* DebugLinkState::release_matrix() {
  clear_has_matrix();
  if (matrix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matrix_;
    matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_matrix(::std::string* matrix) {
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete matrix_;
  }
  if (matrix) {
    set_has_matrix();
    matrix_ = matrix;
  } else {
    clear_has_matrix();
    matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mnemonic = 4;
inline bool DebugLinkState::has_mnemonic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DebugLinkState::set_has_mnemonic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DebugLinkState::clear_has_mnemonic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DebugLinkState::clear_mnemonic() {
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    mnemonic_->clear();
  }
  clear_has_mnemonic();
}
inline const ::std::string& DebugLinkState::mnemonic() const {
  return *mnemonic_;
}
inline void DebugLinkState::set_mnemonic(const ::std::string& value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
}
inline void DebugLinkState::set_mnemonic(const char* value) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(value);
}
inline void DebugLinkState::set_mnemonic(const char* value, size_t size) {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  mnemonic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_mnemonic() {
  set_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    mnemonic_ = new ::std::string;
  }
  return mnemonic_;
}
inline ::std::string* DebugLinkState::release_mnemonic() {
  clear_has_mnemonic();
  if (mnemonic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mnemonic_;
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_mnemonic(::std::string* mnemonic) {
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    delete mnemonic_;
  }
  if (mnemonic) {
    set_has_mnemonic();
    mnemonic_ = mnemonic;
  } else {
    clear_has_mnemonic();
    mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .HDNodeType node = 5;
inline bool DebugLinkState::has_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DebugLinkState::set_has_node() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DebugLinkState::clear_has_node() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DebugLinkState::clear_node() {
  if (node_ != NULL) node_->::HDNodeType::Clear();
  clear_has_node();
}
inline const ::HDNodeType& DebugLinkState::node() const {
  return node_ != NULL ? *node_ : *default_instance_->node_;
}
inline ::HDNodeType* DebugLinkState::mutable_node() {
  set_has_node();
  if (node_ == NULL) node_ = new ::HDNodeType;
  return node_;
}
inline ::HDNodeType* DebugLinkState::release_node() {
  clear_has_node();
  ::HDNodeType* temp = node_;
  node_ = NULL;
  return temp;
}
inline void DebugLinkState::set_allocated_node(::HDNodeType* node) {
  delete node_;
  node_ = node;
  if (node) {
    set_has_node();
  } else {
    clear_has_node();
  }
}

// optional bool passphrase_protection = 6;
inline bool DebugLinkState::has_passphrase_protection() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DebugLinkState::set_has_passphrase_protection() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DebugLinkState::clear_has_passphrase_protection() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DebugLinkState::clear_passphrase_protection() {
  passphrase_protection_ = false;
  clear_has_passphrase_protection();
}
inline bool DebugLinkState::passphrase_protection() const {
  return passphrase_protection_;
}
inline void DebugLinkState::set_passphrase_protection(bool value) {
  set_has_passphrase_protection();
  passphrase_protection_ = value;
}

// optional string reset_word = 7;
inline bool DebugLinkState::has_reset_word() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DebugLinkState::set_has_reset_word() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DebugLinkState::clear_has_reset_word() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DebugLinkState::clear_reset_word() {
  if (reset_word_ != &::google::protobuf::internal::kEmptyString) {
    reset_word_->clear();
  }
  clear_has_reset_word();
}
inline const ::std::string& DebugLinkState::reset_word() const {
  return *reset_word_;
}
inline void DebugLinkState::set_reset_word(const ::std::string& value) {
  set_has_reset_word();
  if (reset_word_ == &::google::protobuf::internal::kEmptyString) {
    reset_word_ = new ::std::string;
  }
  reset_word_->assign(value);
}
inline void DebugLinkState::set_reset_word(const char* value) {
  set_has_reset_word();
  if (reset_word_ == &::google::protobuf::internal::kEmptyString) {
    reset_word_ = new ::std::string;
  }
  reset_word_->assign(value);
}
inline void DebugLinkState::set_reset_word(const char* value, size_t size) {
  set_has_reset_word();
  if (reset_word_ == &::google::protobuf::internal::kEmptyString) {
    reset_word_ = new ::std::string;
  }
  reset_word_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_reset_word() {
  set_has_reset_word();
  if (reset_word_ == &::google::protobuf::internal::kEmptyString) {
    reset_word_ = new ::std::string;
  }
  return reset_word_;
}
inline ::std::string* DebugLinkState::release_reset_word() {
  clear_has_reset_word();
  if (reset_word_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reset_word_;
    reset_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_reset_word(::std::string* reset_word) {
  if (reset_word_ != &::google::protobuf::internal::kEmptyString) {
    delete reset_word_;
  }
  if (reset_word) {
    set_has_reset_word();
    reset_word_ = reset_word;
  } else {
    clear_has_reset_word();
    reset_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes reset_entropy = 8;
inline bool DebugLinkState::has_reset_entropy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DebugLinkState::set_has_reset_entropy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DebugLinkState::clear_has_reset_entropy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DebugLinkState::clear_reset_entropy() {
  if (reset_entropy_ != &::google::protobuf::internal::kEmptyString) {
    reset_entropy_->clear();
  }
  clear_has_reset_entropy();
}
inline const ::std::string& DebugLinkState::reset_entropy() const {
  return *reset_entropy_;
}
inline void DebugLinkState::set_reset_entropy(const ::std::string& value) {
  set_has_reset_entropy();
  if (reset_entropy_ == &::google::protobuf::internal::kEmptyString) {
    reset_entropy_ = new ::std::string;
  }
  reset_entropy_->assign(value);
}
inline void DebugLinkState::set_reset_entropy(const char* value) {
  set_has_reset_entropy();
  if (reset_entropy_ == &::google::protobuf::internal::kEmptyString) {
    reset_entropy_ = new ::std::string;
  }
  reset_entropy_->assign(value);
}
inline void DebugLinkState::set_reset_entropy(const void* value, size_t size) {
  set_has_reset_entropy();
  if (reset_entropy_ == &::google::protobuf::internal::kEmptyString) {
    reset_entropy_ = new ::std::string;
  }
  reset_entropy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_reset_entropy() {
  set_has_reset_entropy();
  if (reset_entropy_ == &::google::protobuf::internal::kEmptyString) {
    reset_entropy_ = new ::std::string;
  }
  return reset_entropy_;
}
inline ::std::string* DebugLinkState::release_reset_entropy() {
  clear_has_reset_entropy();
  if (reset_entropy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reset_entropy_;
    reset_entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_reset_entropy(::std::string* reset_entropy) {
  if (reset_entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete reset_entropy_;
  }
  if (reset_entropy) {
    set_has_reset_entropy();
    reset_entropy_ = reset_entropy;
  } else {
    clear_has_reset_entropy();
    reset_entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string recovery_fake_word = 9;
inline bool DebugLinkState::has_recovery_fake_word() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DebugLinkState::set_has_recovery_fake_word() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DebugLinkState::clear_has_recovery_fake_word() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DebugLinkState::clear_recovery_fake_word() {
  if (recovery_fake_word_ != &::google::protobuf::internal::kEmptyString) {
    recovery_fake_word_->clear();
  }
  clear_has_recovery_fake_word();
}
inline const ::std::string& DebugLinkState::recovery_fake_word() const {
  return *recovery_fake_word_;
}
inline void DebugLinkState::set_recovery_fake_word(const ::std::string& value) {
  set_has_recovery_fake_word();
  if (recovery_fake_word_ == &::google::protobuf::internal::kEmptyString) {
    recovery_fake_word_ = new ::std::string;
  }
  recovery_fake_word_->assign(value);
}
inline void DebugLinkState::set_recovery_fake_word(const char* value) {
  set_has_recovery_fake_word();
  if (recovery_fake_word_ == &::google::protobuf::internal::kEmptyString) {
    recovery_fake_word_ = new ::std::string;
  }
  recovery_fake_word_->assign(value);
}
inline void DebugLinkState::set_recovery_fake_word(const char* value, size_t size) {
  set_has_recovery_fake_word();
  if (recovery_fake_word_ == &::google::protobuf::internal::kEmptyString) {
    recovery_fake_word_ = new ::std::string;
  }
  recovery_fake_word_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkState::mutable_recovery_fake_word() {
  set_has_recovery_fake_word();
  if (recovery_fake_word_ == &::google::protobuf::internal::kEmptyString) {
    recovery_fake_word_ = new ::std::string;
  }
  return recovery_fake_word_;
}
inline ::std::string* DebugLinkState::release_recovery_fake_word() {
  clear_has_recovery_fake_word();
  if (recovery_fake_word_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = recovery_fake_word_;
    recovery_fake_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkState::set_allocated_recovery_fake_word(::std::string* recovery_fake_word) {
  if (recovery_fake_word_ != &::google::protobuf::internal::kEmptyString) {
    delete recovery_fake_word_;
  }
  if (recovery_fake_word) {
    set_has_recovery_fake_word();
    recovery_fake_word_ = recovery_fake_word;
  } else {
    clear_has_recovery_fake_word();
    recovery_fake_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 recovery_word_pos = 10;
inline bool DebugLinkState::has_recovery_word_pos() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DebugLinkState::set_has_recovery_word_pos() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DebugLinkState::clear_has_recovery_word_pos() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DebugLinkState::clear_recovery_word_pos() {
  recovery_word_pos_ = 0u;
  clear_has_recovery_word_pos();
}
inline ::google::protobuf::uint32 DebugLinkState::recovery_word_pos() const {
  return recovery_word_pos_;
}
inline void DebugLinkState::set_recovery_word_pos(::google::protobuf::uint32 value) {
  set_has_recovery_word_pos();
  recovery_word_pos_ = value;
}

// -------------------------------------------------------------------

// DebugLinkStop

// -------------------------------------------------------------------

// DebugLinkLog

// optional uint32 level = 1;
inline bool DebugLinkLog::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugLinkLog::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugLinkLog::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugLinkLog::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 DebugLinkLog::level() const {
  return level_;
}
inline void DebugLinkLog::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional string bucket = 2;
inline bool DebugLinkLog::has_bucket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugLinkLog::set_has_bucket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugLinkLog::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugLinkLog::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& DebugLinkLog::bucket() const {
  return *bucket_;
}
inline void DebugLinkLog::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void DebugLinkLog::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void DebugLinkLog::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkLog::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* DebugLinkLog::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkLog::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 3;
inline bool DebugLinkLog::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugLinkLog::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugLinkLog::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugLinkLog::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& DebugLinkLog::text() const {
  return *text_;
}
inline void DebugLinkLog::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DebugLinkLog::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DebugLinkLog::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DebugLinkLog::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* DebugLinkLog::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DebugLinkLog::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
