// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* Initialize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Initialize_reflection_ = NULL;
const ::google::protobuf::Descriptor* Features_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Features_reflection_ = NULL;
const ::google::protobuf::Descriptor* ClearSession_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ClearSession_reflection_ = NULL;
const ::google::protobuf::Descriptor* ApplySettings_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ApplySettings_reflection_ = NULL;
const ::google::protobuf::Descriptor* ChangePin_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ChangePin_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ping_reflection_ = NULL;
const ::google::protobuf::Descriptor* Success_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Success_reflection_ = NULL;
const ::google::protobuf::Descriptor* Failure_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Failure_reflection_ = NULL;
const ::google::protobuf::Descriptor* ButtonRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ButtonRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ButtonAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ButtonAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* PinMatrixRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PinMatrixRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PinMatrixAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PinMatrixAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* Cancel_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Cancel_reflection_ = NULL;
const ::google::protobuf::Descriptor* PassphraseRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PassphraseRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* PassphraseAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PassphraseAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetEntropy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetEntropy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Entropy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Entropy_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetPublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetPublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* PublicKey_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PublicKey_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* WipeDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WipeDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoadDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoadDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResetDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResetDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntropyRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntropyRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* EntropyAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EntropyAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* RecoveryDevice_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RecoveryDevice_reflection_ = NULL;
const ::google::protobuf::Descriptor* WordRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WordRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* WordAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WordAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* VerifyMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VerifyMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* MessageSignature_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MessageSignature_reflection_ = NULL;
const ::google::protobuf::Descriptor* EncryptMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EncryptMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* DecryptMessage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DecryptMessage_reflection_ = NULL;
const ::google::protobuf::Descriptor* CipherKeyValue_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CipherKeyValue_reflection_ = NULL;
const ::google::protobuf::Descriptor* EstimateTxSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EstimateTxSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* SignTx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SignTx_reflection_ = NULL;
const ::google::protobuf::Descriptor* SimpleSignTx_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SimpleSignTx_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TxAck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TxAck_reflection_ = NULL;
const ::google::protobuf::Descriptor* FirmwareErase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirmwareErase_reflection_ = NULL;
const ::google::protobuf::Descriptor* FirmwareUpload_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirmwareUpload_reflection_ = NULL;
const ::google::protobuf::Descriptor* TestScreen_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TestScreen_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkDecision_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkDecision_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkGetState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkGetState_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkState_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkStop_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkStop_reflection_ = NULL;
const ::google::protobuf::Descriptor* DebugLinkLog_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DebugLinkLog_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  Initialize_descriptor_ = file->message_type(0);
  static const int Initialize_offsets_[1] = {
  };
  Initialize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Initialize_descriptor_,
      Initialize::default_instance_,
      Initialize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Initialize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Initialize));
  Features_descriptor_ = file->message_type(1);
  static const int Features_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, vendor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, major_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, minor_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, patch_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, bootloader_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, device_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, pin_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, passphrase_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, coins_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, initialized_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, revision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, bootloader_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, imported_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, cpu_sn_),
  };
  Features_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Features_descriptor_,
      Features::default_instance_,
      Features_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Features, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Features));
  ClearSession_descriptor_ = file->message_type(2);
  static const int ClearSession_offsets_[1] = {
  };
  ClearSession_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ClearSession_descriptor_,
      ClearSession::default_instance_,
      ClearSession_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearSession, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ClearSession, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ClearSession));
  ApplySettings_descriptor_ = file->message_type(3);
  static const int ApplySettings_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, label_),
  };
  ApplySettings_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ApplySettings_descriptor_,
      ApplySettings::default_instance_,
      ApplySettings_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ApplySettings, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ApplySettings));
  ChangePin_descriptor_ = file->message_type(4);
  static const int ChangePin_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, remove_),
  };
  ChangePin_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ChangePin_descriptor_,
      ChangePin::default_instance_,
      ChangePin_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ChangePin, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ChangePin));
  Ping_descriptor_ = file->message_type(5);
  static const int Ping_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, button_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, pin_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, passphrase_protection_),
  };
  Ping_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Ping_descriptor_,
      Ping::default_instance_,
      Ping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ping, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Ping));
  Success_descriptor_ = file->message_type(6);
  static const int Success_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, payload_),
  };
  Success_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Success_descriptor_,
      Success::default_instance_,
      Success_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Success, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Success));
  Failure_descriptor_ = file->message_type(7);
  static const int Failure_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, message_),
  };
  Failure_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Failure_descriptor_,
      Failure::default_instance_,
      Failure_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Failure, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Failure));
  ButtonRequest_descriptor_ = file->message_type(8);
  static const int ButtonRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, code_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, data_),
  };
  ButtonRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ButtonRequest_descriptor_,
      ButtonRequest::default_instance_,
      ButtonRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ButtonRequest));
  ButtonAck_descriptor_ = file->message_type(9);
  static const int ButtonAck_offsets_[1] = {
  };
  ButtonAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ButtonAck_descriptor_,
      ButtonAck::default_instance_,
      ButtonAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ButtonAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ButtonAck));
  PinMatrixRequest_descriptor_ = file->message_type(10);
  static const int PinMatrixRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, type_),
  };
  PinMatrixRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PinMatrixRequest_descriptor_,
      PinMatrixRequest::default_instance_,
      PinMatrixRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PinMatrixRequest));
  PinMatrixAck_descriptor_ = file->message_type(11);
  static const int PinMatrixAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, pin_),
  };
  PinMatrixAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PinMatrixAck_descriptor_,
      PinMatrixAck::default_instance_,
      PinMatrixAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PinMatrixAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PinMatrixAck));
  Cancel_descriptor_ = file->message_type(12);
  static const int Cancel_offsets_[1] = {
  };
  Cancel_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Cancel_descriptor_,
      Cancel::default_instance_,
      Cancel_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cancel, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Cancel, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Cancel));
  PassphraseRequest_descriptor_ = file->message_type(13);
  static const int PassphraseRequest_offsets_[1] = {
  };
  PassphraseRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PassphraseRequest_descriptor_,
      PassphraseRequest::default_instance_,
      PassphraseRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PassphraseRequest));
  PassphraseAck_descriptor_ = file->message_type(14);
  static const int PassphraseAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, passphrase_),
  };
  PassphraseAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PassphraseAck_descriptor_,
      PassphraseAck::default_instance_,
      PassphraseAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PassphraseAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PassphraseAck));
  GetEntropy_descriptor_ = file->message_type(15);
  static const int GetEntropy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, size_),
  };
  GetEntropy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetEntropy_descriptor_,
      GetEntropy::default_instance_,
      GetEntropy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetEntropy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetEntropy));
  Entropy_descriptor_ = file->message_type(16);
  static const int Entropy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, entropy_),
  };
  Entropy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Entropy_descriptor_,
      Entropy::default_instance_,
      Entropy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Entropy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Entropy));
  GetPublicKey_descriptor_ = file->message_type(17);
  static const int GetPublicKey_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, address_n_),
  };
  GetPublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetPublicKey_descriptor_,
      GetPublicKey::default_instance_,
      GetPublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetPublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetPublicKey));
  PublicKey_descriptor_ = file->message_type(18);
  static const int PublicKey_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, xpub_),
  };
  PublicKey_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PublicKey_descriptor_,
      PublicKey::default_instance_,
      PublicKey_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicKey, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PublicKey));
  GetAddress_descriptor_ = file->message_type(19);
  static const int GetAddress_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, coin_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, show_display_),
  };
  GetAddress_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetAddress_descriptor_,
      GetAddress::default_instance_,
      GetAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetAddress, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetAddress));
  Address_descriptor_ = file->message_type(20);
  static const int Address_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, address_),
  };
  Address_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Address));
  WipeDevice_descriptor_ = file->message_type(21);
  static const int WipeDevice_offsets_[1] = {
  };
  WipeDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WipeDevice_descriptor_,
      WipeDevice::default_instance_,
      WipeDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WipeDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WipeDevice));
  LoadDevice_descriptor_ = file->message_type(22);
  static const int LoadDevice_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, mnemonic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, pin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, passphrase_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, skip_checksum_),
  };
  LoadDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoadDevice_descriptor_,
      LoadDevice::default_instance_,
      LoadDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoadDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoadDevice));
  ResetDevice_descriptor_ = file->message_type(23);
  static const int ResetDevice_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, display_random_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, strength_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, passphrase_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, pin_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, label_),
  };
  ResetDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResetDevice_descriptor_,
      ResetDevice::default_instance_,
      ResetDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResetDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResetDevice));
  EntropyRequest_descriptor_ = file->message_type(24);
  static const int EntropyRequest_offsets_[1] = {
  };
  EntropyRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntropyRequest_descriptor_,
      EntropyRequest::default_instance_,
      EntropyRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntropyRequest));
  EntropyAck_descriptor_ = file->message_type(25);
  static const int EntropyAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, entropy_),
  };
  EntropyAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EntropyAck_descriptor_,
      EntropyAck::default_instance_,
      EntropyAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EntropyAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EntropyAck));
  RecoveryDevice_descriptor_ = file->message_type(26);
  static const int RecoveryDevice_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, word_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, passphrase_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, pin_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, label_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, enforce_wordlist_),
  };
  RecoveryDevice_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RecoveryDevice_descriptor_,
      RecoveryDevice::default_instance_,
      RecoveryDevice_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RecoveryDevice, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RecoveryDevice));
  WordRequest_descriptor_ = file->message_type(27);
  static const int WordRequest_offsets_[1] = {
  };
  WordRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WordRequest_descriptor_,
      WordRequest::default_instance_,
      WordRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WordRequest));
  WordAck_descriptor_ = file->message_type(28);
  static const int WordAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, word_),
  };
  WordAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WordAck_descriptor_,
      WordAck::default_instance_,
      WordAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WordAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WordAck));
  SignMessage_descriptor_ = file->message_type(29);
  static const int SignMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, coin_name_),
  };
  SignMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignMessage_descriptor_,
      SignMessage::default_instance_,
      SignMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignMessage));
  VerifyMessage_descriptor_ = file->message_type(30);
  static const int VerifyMessage_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, message_),
  };
  VerifyMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VerifyMessage_descriptor_,
      VerifyMessage::default_instance_,
      VerifyMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VerifyMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VerifyMessage));
  MessageSignature_descriptor_ = file->message_type(31);
  static const int MessageSignature_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, signature_),
  };
  MessageSignature_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MessageSignature_descriptor_,
      MessageSignature::default_instance_,
      MessageSignature_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MessageSignature, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MessageSignature));
  EncryptMessage_descriptor_ = file->message_type(32);
  static const int EncryptMessage_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, pubkey_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, display_only_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, address_n_),
  };
  EncryptMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EncryptMessage_descriptor_,
      EncryptMessage::default_instance_,
      EncryptMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EncryptMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EncryptMessage));
  DecryptMessage_descriptor_ = file->message_type(33);
  static const int DecryptMessage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, message_),
  };
  DecryptMessage_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DecryptMessage_descriptor_,
      DecryptMessage::default_instance_,
      DecryptMessage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DecryptMessage, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DecryptMessage));
  CipherKeyValue_descriptor_ = file->message_type(34);
  static const int CipherKeyValue_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, address_n_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, encrypt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, ask_on_encrypt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, ask_on_decrypt_),
  };
  CipherKeyValue_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CipherKeyValue_descriptor_,
      CipherKeyValue::default_instance_,
      CipherKeyValue_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CipherKeyValue, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CipherKeyValue));
  EstimateTxSize_descriptor_ = file->message_type(35);
  static const int EstimateTxSize_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, outputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, inputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, coin_name_),
  };
  EstimateTxSize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EstimateTxSize_descriptor_,
      EstimateTxSize::default_instance_,
      EstimateTxSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EstimateTxSize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EstimateTxSize));
  TxSize_descriptor_ = file->message_type(36);
  static const int TxSize_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, tx_size_),
  };
  TxSize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxSize_descriptor_,
      TxSize::default_instance_,
      TxSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxSize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxSize));
  SignTx_descriptor_ = file->message_type(37);
  static const int SignTx_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, outputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, inputs_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, coin_name_),
  };
  SignTx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SignTx_descriptor_,
      SignTx::default_instance_,
      SignTx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SignTx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SignTx));
  SimpleSignTx_descriptor_ = file->message_type(38);
  static const int SimpleSignTx_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, transactions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, coin_name_),
  };
  SimpleSignTx_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SimpleSignTx_descriptor_,
      SimpleSignTx::default_instance_,
      SimpleSignTx_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SimpleSignTx, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SimpleSignTx));
  TxRequest_descriptor_ = file->message_type(39);
  static const int TxRequest_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, request_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, details_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, serialized_),
  };
  TxRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxRequest_descriptor_,
      TxRequest::default_instance_,
      TxRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxRequest));
  TxAck_descriptor_ = file->message_type(40);
  static const int TxAck_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, tx_),
  };
  TxAck_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TxAck_descriptor_,
      TxAck::default_instance_,
      TxAck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TxAck, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TxAck));
  FirmwareErase_descriptor_ = file->message_type(41);
  static const int FirmwareErase_offsets_[1] = {
  };
  FirmwareErase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirmwareErase_descriptor_,
      FirmwareErase::default_instance_,
      FirmwareErase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareErase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareErase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirmwareErase));
  FirmwareUpload_descriptor_ = file->message_type(42);
  static const int FirmwareUpload_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, payload_),
  };
  FirmwareUpload_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirmwareUpload_descriptor_,
      FirmwareUpload::default_instance_,
      FirmwareUpload_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirmwareUpload, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirmwareUpload));
  TestScreen_descriptor_ = file->message_type(43);
  static const int TestScreen_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestScreen, delay_time_),
  };
  TestScreen_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TestScreen_descriptor_,
      TestScreen::default_instance_,
      TestScreen_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestScreen, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TestScreen, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TestScreen));
  DebugLinkDecision_descriptor_ = file->message_type(44);
  static const int DebugLinkDecision_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, yes_no_),
  };
  DebugLinkDecision_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkDecision_descriptor_,
      DebugLinkDecision::default_instance_,
      DebugLinkDecision_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkDecision, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkDecision));
  DebugLinkGetState_descriptor_ = file->message_type(45);
  static const int DebugLinkGetState_offsets_[1] = {
  };
  DebugLinkGetState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkGetState_descriptor_,
      DebugLinkGetState::default_instance_,
      DebugLinkGetState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkGetState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkGetState));
  DebugLinkState_descriptor_ = file->message_type(46);
  static const int DebugLinkState_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, layout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, pin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, matrix_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, mnemonic_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, node_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, passphrase_protection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, reset_word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, reset_entropy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, recovery_fake_word_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, recovery_word_pos_),
  };
  DebugLinkState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkState_descriptor_,
      DebugLinkState::default_instance_,
      DebugLinkState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkState));
  DebugLinkStop_descriptor_ = file->message_type(47);
  static const int DebugLinkStop_offsets_[1] = {
  };
  DebugLinkStop_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkStop_descriptor_,
      DebugLinkStop::default_instance_,
      DebugLinkStop_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkStop, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkStop));
  DebugLinkLog_descriptor_ = file->message_type(48);
  static const int DebugLinkLog_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, bucket_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, text_),
  };
  DebugLinkLog_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DebugLinkLog_descriptor_,
      DebugLinkLog::default_instance_,
      DebugLinkLog_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DebugLinkLog, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DebugLinkLog));
  MessageType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Initialize_descriptor_, &Initialize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Features_descriptor_, &Features::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ClearSession_descriptor_, &ClearSession::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ApplySettings_descriptor_, &ApplySettings::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ChangePin_descriptor_, &ChangePin::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Ping_descriptor_, &Ping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Success_descriptor_, &Success::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Failure_descriptor_, &Failure::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ButtonRequest_descriptor_, &ButtonRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ButtonAck_descriptor_, &ButtonAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PinMatrixRequest_descriptor_, &PinMatrixRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PinMatrixAck_descriptor_, &PinMatrixAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Cancel_descriptor_, &Cancel::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PassphraseRequest_descriptor_, &PassphraseRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PassphraseAck_descriptor_, &PassphraseAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetEntropy_descriptor_, &GetEntropy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Entropy_descriptor_, &Entropy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetPublicKey_descriptor_, &GetPublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PublicKey_descriptor_, &PublicKey::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetAddress_descriptor_, &GetAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WipeDevice_descriptor_, &WipeDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoadDevice_descriptor_, &LoadDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResetDevice_descriptor_, &ResetDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntropyRequest_descriptor_, &EntropyRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EntropyAck_descriptor_, &EntropyAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RecoveryDevice_descriptor_, &RecoveryDevice::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WordRequest_descriptor_, &WordRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WordAck_descriptor_, &WordAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignMessage_descriptor_, &SignMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VerifyMessage_descriptor_, &VerifyMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MessageSignature_descriptor_, &MessageSignature::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EncryptMessage_descriptor_, &EncryptMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DecryptMessage_descriptor_, &DecryptMessage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CipherKeyValue_descriptor_, &CipherKeyValue::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EstimateTxSize_descriptor_, &EstimateTxSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxSize_descriptor_, &TxSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SignTx_descriptor_, &SignTx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SimpleSignTx_descriptor_, &SimpleSignTx::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxRequest_descriptor_, &TxRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TxAck_descriptor_, &TxAck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirmwareErase_descriptor_, &FirmwareErase::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirmwareUpload_descriptor_, &FirmwareUpload::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TestScreen_descriptor_, &TestScreen::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkDecision_descriptor_, &DebugLinkDecision::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkGetState_descriptor_, &DebugLinkGetState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkState_descriptor_, &DebugLinkState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkStop_descriptor_, &DebugLinkStop::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DebugLinkLog_descriptor_, &DebugLinkLog::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete Initialize::default_instance_;
  delete Initialize_reflection_;
  delete Features::default_instance_;
  delete Features_reflection_;
  delete ClearSession::default_instance_;
  delete ClearSession_reflection_;
  delete ApplySettings::default_instance_;
  delete ApplySettings_reflection_;
  delete ChangePin::default_instance_;
  delete ChangePin_reflection_;
  delete Ping::default_instance_;
  delete Ping_reflection_;
  delete Success::default_instance_;
  delete Success_reflection_;
  delete Failure::default_instance_;
  delete Failure_reflection_;
  delete ButtonRequest::default_instance_;
  delete ButtonRequest_reflection_;
  delete ButtonAck::default_instance_;
  delete ButtonAck_reflection_;
  delete PinMatrixRequest::default_instance_;
  delete PinMatrixRequest_reflection_;
  delete PinMatrixAck::default_instance_;
  delete PinMatrixAck_reflection_;
  delete Cancel::default_instance_;
  delete Cancel_reflection_;
  delete PassphraseRequest::default_instance_;
  delete PassphraseRequest_reflection_;
  delete PassphraseAck::default_instance_;
  delete PassphraseAck_reflection_;
  delete GetEntropy::default_instance_;
  delete GetEntropy_reflection_;
  delete Entropy::default_instance_;
  delete Entropy_reflection_;
  delete GetPublicKey::default_instance_;
  delete GetPublicKey_reflection_;
  delete PublicKey::default_instance_;
  delete PublicKey_reflection_;
  delete GetAddress::default_instance_;
  delete GetAddress_reflection_;
  delete GetAddress::_default_coin_name_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete WipeDevice::default_instance_;
  delete WipeDevice_reflection_;
  delete LoadDevice::default_instance_;
  delete LoadDevice_reflection_;
  delete LoadDevice::_default_language_;
  delete ResetDevice::default_instance_;
  delete ResetDevice_reflection_;
  delete ResetDevice::_default_language_;
  delete EntropyRequest::default_instance_;
  delete EntropyRequest_reflection_;
  delete EntropyAck::default_instance_;
  delete EntropyAck_reflection_;
  delete RecoveryDevice::default_instance_;
  delete RecoveryDevice_reflection_;
  delete RecoveryDevice::_default_language_;
  delete WordRequest::default_instance_;
  delete WordRequest_reflection_;
  delete WordAck::default_instance_;
  delete WordAck_reflection_;
  delete SignMessage::default_instance_;
  delete SignMessage_reflection_;
  delete SignMessage::_default_coin_name_;
  delete VerifyMessage::default_instance_;
  delete VerifyMessage_reflection_;
  delete MessageSignature::default_instance_;
  delete MessageSignature_reflection_;
  delete EncryptMessage::default_instance_;
  delete EncryptMessage_reflection_;
  delete DecryptMessage::default_instance_;
  delete DecryptMessage_reflection_;
  delete CipherKeyValue::default_instance_;
  delete CipherKeyValue_reflection_;
  delete EstimateTxSize::default_instance_;
  delete EstimateTxSize_reflection_;
  delete EstimateTxSize::_default_coin_name_;
  delete TxSize::default_instance_;
  delete TxSize_reflection_;
  delete SignTx::default_instance_;
  delete SignTx_reflection_;
  delete SignTx::_default_coin_name_;
  delete SimpleSignTx::default_instance_;
  delete SimpleSignTx_reflection_;
  delete SimpleSignTx::_default_coin_name_;
  delete TxRequest::default_instance_;
  delete TxRequest_reflection_;
  delete TxAck::default_instance_;
  delete TxAck_reflection_;
  delete FirmwareErase::default_instance_;
  delete FirmwareErase_reflection_;
  delete FirmwareUpload::default_instance_;
  delete FirmwareUpload_reflection_;
  delete TestScreen::default_instance_;
  delete TestScreen_reflection_;
  delete DebugLinkDecision::default_instance_;
  delete DebugLinkDecision_reflection_;
  delete DebugLinkGetState::default_instance_;
  delete DebugLinkGetState_reflection_;
  delete DebugLinkState::default_instance_;
  delete DebugLinkState_reflection_;
  delete DebugLinkStop::default_instance_;
  delete DebugLinkStop_reflection_;
  delete DebugLinkLog::default_instance_;
  delete DebugLinkLog_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_types_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\032\013types.proto\"\014\n\nInitial"
    "ize\"\337\002\n\010Features\022\016\n\006vendor\030\001 \001(\t\022\025\n\rmajo"
    "r_version\030\002 \001(\r\022\025\n\rminor_version\030\003 \001(\r\022\025"
    "\n\rpatch_version\030\004 \001(\r\022\027\n\017bootloader_mode"
    "\030\005 \001(\010\022\021\n\tdevice_id\030\006 \001(\t\022\026\n\016pin_protect"
    "ion\030\007 \001(\010\022\035\n\025passphrase_protection\030\010 \001(\010"
    "\022\020\n\010language\030\t \001(\t\022\r\n\005label\030\n \001(\t\022\030\n\005coi"
    "ns\030\013 \003(\0132\t.CoinType\022\023\n\013initialized\030\014 \001(\010"
    "\022\020\n\010revision\030\r \001(\014\022\027\n\017bootloader_hash\030\016 "
    "\001(\014\022\020\n\010imported\030\017 \001(\010\022\016\n\006cpu_sn\030\020 \001(\t\"\016\n"
    "\014ClearSession\"0\n\rApplySettings\022\020\n\010langua"
    "ge\030\001 \001(\t\022\r\n\005label\030\002 \001(\t\"\033\n\tChangePin\022\016\n\006"
    "remove\030\001 \001(\010\"i\n\004Ping\022\017\n\007message\030\001 \001(\t\022\031\n"
    "\021button_protection\030\002 \001(\010\022\026\n\016pin_protecti"
    "on\030\003 \001(\010\022\035\n\025passphrase_protection\030\004 \001(\010\""
    "+\n\007Success\022\017\n\007message\030\001 \001(\t\022\017\n\007payload\030\002"
    " \001(\014\"6\n\007Failure\022\032\n\004code\030\001 \001(\0162\014.FailureT"
    "ype\022\017\n\007message\030\002 \001(\t\"\?\n\rButtonRequest\022 \n"
    "\004code\030\001 \001(\0162\022.ButtonRequestType\022\014\n\004data\030"
    "\002 \001(\t\"\013\n\tButtonAck\"7\n\020PinMatrixRequest\022#"
    "\n\004type\030\001 \001(\0162\025.PinMatrixRequestType\"\033\n\014P"
    "inMatrixAck\022\013\n\003pin\030\001 \002(\t\"\010\n\006Cancel\"\023\n\021Pa"
    "ssphraseRequest\"#\n\rPassphraseAck\022\022\n\npass"
    "phrase\030\001 \002(\t\"\032\n\nGetEntropy\022\014\n\004size\030\001 \002(\r"
    "\"\032\n\007Entropy\022\017\n\007entropy\030\001 \002(\014\"!\n\014GetPubli"
    "cKey\022\021\n\taddress_n\030\001 \003(\r\"4\n\tPublicKey\022\031\n\004"
    "node\030\001 \002(\0132\013.HDNodeType\022\014\n\004xpub\030\002 \001(\t\"Q\n"
    "\nGetAddress\022\021\n\taddress_n\030\001 \003(\r\022\032\n\tcoin_n"
    "ame\030\002 \001(\t:\007Bitcoin\022\024\n\014show_display\030\003 \001(\010"
    "\"\032\n\007Address\022\017\n\007address\030\001 \002(\t\"\014\n\nWipeDevi"
    "ce\"\246\001\n\nLoadDevice\022\020\n\010mnemonic\030\001 \001(\t\022\031\n\004n"
    "ode\030\002 \001(\0132\013.HDNodeType\022\013\n\003pin\030\003 \001(\t\022\035\n\025p"
    "assphrase_protection\030\004 \001(\010\022\031\n\010language\030\005"
    " \001(\t:\007english\022\r\n\005label\030\006 \001(\t\022\025\n\rskip_che"
    "cksum\030\007 \001(\010\"\235\001\n\013ResetDevice\022\026\n\016display_r"
    "andom\030\001 \001(\010\022\025\n\010strength\030\002 \001(\r:\003128\022\035\n\025pa"
    "ssphrase_protection\030\003 \001(\010\022\026\n\016pin_protect"
    "ion\030\004 \001(\010\022\031\n\010language\030\005 \001(\t:\007english\022\r\n\005"
    "label\030\006 \001(\t\"\020\n\016EntropyRequest\"\035\n\nEntropy"
    "Ack\022\017\n\007entropy\030\001 \001(\014\"\237\001\n\016RecoveryDevice\022"
    "\022\n\nword_count\030\001 \001(\r\022\035\n\025passphrase_protec"
    "tion\030\002 \001(\010\022\026\n\016pin_protection\030\003 \001(\010\022\031\n\010la"
    "nguage\030\004 \001(\t:\007english\022\r\n\005label\030\005 \001(\t\022\030\n\020"
    "enforce_wordlist\030\006 \001(\010\"\r\n\013WordRequest\"\027\n"
    "\007WordAck\022\014\n\004word\030\001 \002(\t\"M\n\013SignMessage\022\021\n"
    "\taddress_n\030\001 \003(\r\022\017\n\007message\030\002 \002(\014\022\032\n\tcoi"
    "n_name\030\003 \001(\t:\007Bitcoin\"D\n\rVerifyMessage\022\017"
    "\n\007address\030\001 \001(\t\022\021\n\tsignature\030\002 \001(\014\022\017\n\007me"
    "ssage\030\003 \001(\014\"6\n\020MessageSignature\022\017\n\007addre"
    "ss\030\001 \001(\t\022\021\n\tsignature\030\002 \001(\014\"Z\n\016EncryptMe"
    "ssage\022\016\n\006pubkey\030\001 \001(\014\022\017\n\007message\030\002 \001(\014\022\024"
    "\n\014display_only\030\003 \001(\010\022\021\n\taddress_n\030\004 \003(\r\""
    "4\n\016DecryptMessage\022\021\n\taddress_n\030\001 \003(\r\022\017\n\007"
    "message\030\002 \001(\014\"\200\001\n\016CipherKeyValue\022\021\n\taddr"
    "ess_n\030\001 \003(\r\022\013\n\003key\030\002 \001(\t\022\r\n\005value\030\003 \001(\014\022"
    "\017\n\007encrypt\030\004 \001(\010\022\026\n\016ask_on_encrypt\030\005 \001(\010"
    "\022\026\n\016ask_on_decrypt\030\006 \001(\010\"Y\n\016EstimateTxSi"
    "ze\022\025\n\routputs_count\030\001 \002(\r\022\024\n\014inputs_coun"
    "t\030\002 \002(\r\022\032\n\tcoin_name\030\003 \001(\t:\007Bitcoin\"\031\n\006T"
    "xSize\022\017\n\007tx_size\030\001 \001(\r\"Q\n\006SignTx\022\025\n\routp"
    "uts_count\030\001 \002(\r\022\024\n\014inputs_count\030\002 \002(\r\022\032\n"
    "\tcoin_name\030\003 \001(\t:\007Bitcoin\"\220\001\n\014SimpleSign"
    "Tx\022\034\n\006inputs\030\001 \003(\0132\014.TxInputType\022\036\n\007outp"
    "uts\030\002 \003(\0132\r.TxOutputType\022&\n\014transactions"
    "\030\003 \003(\0132\020.TransactionType\022\032\n\tcoin_name\030\004 "
    "\001(\t:\007Bitcoin\"\205\001\n\tTxRequest\022\"\n\014request_ty"
    "pe\030\001 \001(\0162\014.RequestType\022&\n\007details\030\002 \001(\0132"
    "\025.TxRequestDetailsType\022,\n\nserialized\030\003 \001"
    "(\0132\030.TxRequestSerializedType\"%\n\005TxAck\022\034\n"
    "\002tx\030\001 \001(\0132\020.TransactionType\"\017\n\rFirmwareE"
    "rase\"!\n\016FirmwareUpload\022\017\n\007payload\030\001 \002(\014\""
    "#\n\nTestScreen\022\025\n\ndelay_time\030\001 \002(\r:\0011\"#\n\021"
    "DebugLinkDecision\022\016\n\006yes_no\030\001 \002(\010\"\023\n\021Deb"
    "ugLinkGetState\"\353\001\n\016DebugLinkState\022\016\n\006lay"
    "out\030\001 \001(\014\022\013\n\003pin\030\002 \001(\t\022\016\n\006matrix\030\003 \001(\t\022\020"
    "\n\010mnemonic\030\004 \001(\t\022\031\n\004node\030\005 \001(\0132\013.HDNodeT"
    "ype\022\035\n\025passphrase_protection\030\006 \001(\010\022\022\n\nre"
    "set_word\030\007 \001(\t\022\025\n\rreset_entropy\030\010 \001(\014\022\032\n"
    "\022recovery_fake_word\030\t \001(\t\022\031\n\021recovery_wo"
    "rd_pos\030\n \001(\r\"\017\n\rDebugLinkStop\";\n\014DebugLi"
    "nkLog\022\r\n\005level\030\001 \001(\r\022\016\n\006bucket\030\002 \001(\t\022\014\n\004"
    "text\030\003 \001(\t*\303\r\n\013MessageType\022 \n\026MessageTyp"
    "e_Initialize\020\000\032\004\220\265\030\001\022\032\n\020MessageType_Ping"
    "\020\001\032\004\220\265\030\001\022\035\n\023MessageType_Success\020\002\032\004\230\265\030\001\022"
    "\035\n\023MessageType_Failure\020\003\032\004\230\265\030\001\022\037\n\025Messag"
    "eType_ChangePin\020\004\032\004\220\265\030\001\022 \n\026MessageType_W"
    "ipeDevice\020\005\032\004\220\265\030\001\022#\n\031MessageType_Firmwar"
    "eErase\020\006\032\004\220\265\030\001\022$\n\032MessageType_FirmwareUp"
    "load\020\007\032\004\220\265\030\001\022 \n\026MessageType_GetEntropy\020\t"
    "\032\004\220\265\030\001\022\035\n\023MessageType_Entropy\020\n\032\004\230\265\030\001\022\"\n"
    "\030MessageType_GetPublicKey\020\013\032\004\220\265\030\001\022\037\n\025Mes"
    "sageType_PublicKey\020\014\032\004\230\265\030\001\022 \n\026MessageTyp"
    "e_LoadDevice\020\r\032\004\220\265\030\001\022!\n\027MessageType_Rese"
    "tDevice\020\016\032\004\220\265\030\001\022\034\n\022MessageType_SignTx\020\017\032"
    "\004\220\265\030\001\022\"\n\030MessageType_SimpleSignTx\020\020\032\004\220\265\030"
    "\001\022\036\n\024MessageType_Features\020\021\032\004\230\265\030\001\022&\n\034Mes"
    "sageType_PinMatrixRequest\020\022\032\004\230\265\030\001\022\"\n\030Mes"
    "sageType_PinMatrixAck\020\023\032\004\220\265\030\001\022\034\n\022Message"
    "Type_Cancel\020\024\032\004\220\265\030\001\022\037\n\025MessageType_TxReq"
    "uest\020\025\032\004\230\265\030\001\022\033\n\021MessageType_TxAck\020\026\032\004\220\265\030"
    "\001\022$\n\032MessageType_CipherKeyValue\020\027\032\004\220\265\030\001\022"
    "\"\n\030MessageType_ClearSession\020\030\032\004\220\265\030\001\022#\n\031M"
    "essageType_ApplySettings\020\031\032\004\220\265\030\001\022#\n\031Mess"
    "ageType_ButtonRequest\020\032\032\004\230\265\030\001\022\037\n\025Message"
    "Type_ButtonAck\020\033\032\004\220\265\030\001\022 \n\026MessageType_Ge"
    "tAddress\020\035\032\004\220\265\030\001\022\035\n\023MessageType_Address\020"
    "\036\032\004\230\265\030\001\022$\n\032MessageType_EntropyRequest\020#\032"
    "\004\230\265\030\001\022 \n\026MessageType_EntropyAck\020$\032\004\220\265\030\001\022"
    "!\n\027MessageType_SignMessage\020&\032\004\220\265\030\001\022#\n\031Me"
    "ssageType_VerifyMessage\020\'\032\004\220\265\030\001\022&\n\034Messa"
    "geType_MessageSignature\020(\032\004\230\265\030\001\022$\n\032Messa"
    "geType_EncryptMessage\0200\032\004\220\265\030\001\022$\n\032Message"
    "Type_DecryptMessage\0201\032\004\220\265\030\001\022\'\n\035MessageTy"
    "pe_PassphraseRequest\020)\032\004\230\265\030\001\022#\n\031MessageT"
    "ype_PassphraseAck\020*\032\004\220\265\030\001\022$\n\032MessageType"
    "_EstimateTxSize\020+\032\004\220\265\030\001\022\034\n\022MessageType_T"
    "xSize\020,\032\004\230\265\030\001\022$\n\032MessageType_RecoveryDev"
    "ice\020-\032\004\220\265\030\001\022!\n\027MessageType_WordRequest\020."
    "\032\004\230\265\030\001\022\035\n\023MessageType_WordAck\020/\032\004\220\265\030\001\022 \n"
    "\026MessageType_TestScreen\0202\032\004\220\265\030\001\022\'\n\035Messa"
    "geType_DebugLinkDecision\020d\032\004\240\265\030\001\022\'\n\035Mess"
    "ageType_DebugLinkGetState\020e\032\004\240\265\030\001\022$\n\032Mes"
    "sageType_DebugLinkState\020f\032\004\250\265\030\001\022#\n\031Messa"
    "geType_DebugLinkStop\020g\032\004\240\265\030\001\022\"\n\030MessageT"
    "ype_DebugLinkLog\020h\032\004\250\265\030\001B0\n\037com.satoshil"
    "abs.trezor.protobufB\rTrezorMessage", 5034);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  Initialize::default_instance_ = new Initialize();
  Features::default_instance_ = new Features();
  ClearSession::default_instance_ = new ClearSession();
  ApplySettings::default_instance_ = new ApplySettings();
  ChangePin::default_instance_ = new ChangePin();
  Ping::default_instance_ = new Ping();
  Success::default_instance_ = new Success();
  Failure::default_instance_ = new Failure();
  ButtonRequest::default_instance_ = new ButtonRequest();
  ButtonAck::default_instance_ = new ButtonAck();
  PinMatrixRequest::default_instance_ = new PinMatrixRequest();
  PinMatrixAck::default_instance_ = new PinMatrixAck();
  Cancel::default_instance_ = new Cancel();
  PassphraseRequest::default_instance_ = new PassphraseRequest();
  PassphraseAck::default_instance_ = new PassphraseAck();
  GetEntropy::default_instance_ = new GetEntropy();
  Entropy::default_instance_ = new Entropy();
  GetPublicKey::default_instance_ = new GetPublicKey();
  PublicKey::default_instance_ = new PublicKey();
  GetAddress::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  GetAddress::default_instance_ = new GetAddress();
  Address::default_instance_ = new Address();
  WipeDevice::default_instance_ = new WipeDevice();
  LoadDevice::_default_language_ =
      new ::std::string("english", 7);
  LoadDevice::default_instance_ = new LoadDevice();
  ResetDevice::_default_language_ =
      new ::std::string("english", 7);
  ResetDevice::default_instance_ = new ResetDevice();
  EntropyRequest::default_instance_ = new EntropyRequest();
  EntropyAck::default_instance_ = new EntropyAck();
  RecoveryDevice::_default_language_ =
      new ::std::string("english", 7);
  RecoveryDevice::default_instance_ = new RecoveryDevice();
  WordRequest::default_instance_ = new WordRequest();
  WordAck::default_instance_ = new WordAck();
  SignMessage::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  SignMessage::default_instance_ = new SignMessage();
  VerifyMessage::default_instance_ = new VerifyMessage();
  MessageSignature::default_instance_ = new MessageSignature();
  EncryptMessage::default_instance_ = new EncryptMessage();
  DecryptMessage::default_instance_ = new DecryptMessage();
  CipherKeyValue::default_instance_ = new CipherKeyValue();
  EstimateTxSize::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  EstimateTxSize::default_instance_ = new EstimateTxSize();
  TxSize::default_instance_ = new TxSize();
  SignTx::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  SignTx::default_instance_ = new SignTx();
  SimpleSignTx::_default_coin_name_ =
      new ::std::string("Bitcoin", 7);
  SimpleSignTx::default_instance_ = new SimpleSignTx();
  TxRequest::default_instance_ = new TxRequest();
  TxAck::default_instance_ = new TxAck();
  FirmwareErase::default_instance_ = new FirmwareErase();
  FirmwareUpload::default_instance_ = new FirmwareUpload();
  TestScreen::default_instance_ = new TestScreen();
  DebugLinkDecision::default_instance_ = new DebugLinkDecision();
  DebugLinkGetState::default_instance_ = new DebugLinkGetState();
  DebugLinkState::default_instance_ = new DebugLinkState();
  DebugLinkStop::default_instance_ = new DebugLinkStop();
  DebugLinkLog::default_instance_ = new DebugLinkLog();
  Initialize::default_instance_->InitAsDefaultInstance();
  Features::default_instance_->InitAsDefaultInstance();
  ClearSession::default_instance_->InitAsDefaultInstance();
  ApplySettings::default_instance_->InitAsDefaultInstance();
  ChangePin::default_instance_->InitAsDefaultInstance();
  Ping::default_instance_->InitAsDefaultInstance();
  Success::default_instance_->InitAsDefaultInstance();
  Failure::default_instance_->InitAsDefaultInstance();
  ButtonRequest::default_instance_->InitAsDefaultInstance();
  ButtonAck::default_instance_->InitAsDefaultInstance();
  PinMatrixRequest::default_instance_->InitAsDefaultInstance();
  PinMatrixAck::default_instance_->InitAsDefaultInstance();
  Cancel::default_instance_->InitAsDefaultInstance();
  PassphraseRequest::default_instance_->InitAsDefaultInstance();
  PassphraseAck::default_instance_->InitAsDefaultInstance();
  GetEntropy::default_instance_->InitAsDefaultInstance();
  Entropy::default_instance_->InitAsDefaultInstance();
  GetPublicKey::default_instance_->InitAsDefaultInstance();
  PublicKey::default_instance_->InitAsDefaultInstance();
  GetAddress::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  WipeDevice::default_instance_->InitAsDefaultInstance();
  LoadDevice::default_instance_->InitAsDefaultInstance();
  ResetDevice::default_instance_->InitAsDefaultInstance();
  EntropyRequest::default_instance_->InitAsDefaultInstance();
  EntropyAck::default_instance_->InitAsDefaultInstance();
  RecoveryDevice::default_instance_->InitAsDefaultInstance();
  WordRequest::default_instance_->InitAsDefaultInstance();
  WordAck::default_instance_->InitAsDefaultInstance();
  SignMessage::default_instance_->InitAsDefaultInstance();
  VerifyMessage::default_instance_->InitAsDefaultInstance();
  MessageSignature::default_instance_->InitAsDefaultInstance();
  EncryptMessage::default_instance_->InitAsDefaultInstance();
  DecryptMessage::default_instance_->InitAsDefaultInstance();
  CipherKeyValue::default_instance_->InitAsDefaultInstance();
  EstimateTxSize::default_instance_->InitAsDefaultInstance();
  TxSize::default_instance_->InitAsDefaultInstance();
  SignTx::default_instance_->InitAsDefaultInstance();
  SimpleSignTx::default_instance_->InitAsDefaultInstance();
  TxRequest::default_instance_->InitAsDefaultInstance();
  TxAck::default_instance_->InitAsDefaultInstance();
  FirmwareErase::default_instance_->InitAsDefaultInstance();
  FirmwareUpload::default_instance_->InitAsDefaultInstance();
  TestScreen::default_instance_->InitAsDefaultInstance();
  DebugLinkDecision::default_instance_->InitAsDefaultInstance();
  DebugLinkGetState::default_instance_->InitAsDefaultInstance();
  DebugLinkState::default_instance_->InitAsDefaultInstance();
  DebugLinkStop::default_instance_->InitAsDefaultInstance();
  DebugLinkLog::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;
const ::google::protobuf::EnumDescriptor* MessageType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageType_descriptor_;
}
bool MessageType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 29:
    case 30:
    case 35:
    case 36:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Initialize::Initialize()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Initialize::InitAsDefaultInstance() {
}

Initialize::Initialize(const Initialize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Initialize::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Initialize::~Initialize() {
  SharedDtor();
}

void Initialize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Initialize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Initialize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Initialize_descriptor_;
}

const Initialize& Initialize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Initialize* Initialize::default_instance_ = NULL;

Initialize* Initialize::New() const {
  return new Initialize;
}

void Initialize::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Initialize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Initialize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Initialize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Initialize::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Initialize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Initialize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Initialize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Initialize::MergeFrom(const Initialize& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Initialize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Initialize::CopyFrom(const Initialize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Initialize::IsInitialized() const {

  return true;
}

void Initialize::Swap(Initialize* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Initialize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Initialize_descriptor_;
  metadata.reflection = Initialize_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Features::kVendorFieldNumber;
const int Features::kMajorVersionFieldNumber;
const int Features::kMinorVersionFieldNumber;
const int Features::kPatchVersionFieldNumber;
const int Features::kBootloaderModeFieldNumber;
const int Features::kDeviceIdFieldNumber;
const int Features::kPinProtectionFieldNumber;
const int Features::kPassphraseProtectionFieldNumber;
const int Features::kLanguageFieldNumber;
const int Features::kLabelFieldNumber;
const int Features::kCoinsFieldNumber;
const int Features::kInitializedFieldNumber;
const int Features::kRevisionFieldNumber;
const int Features::kBootloaderHashFieldNumber;
const int Features::kImportedFieldNumber;
const int Features::kCpuSnFieldNumber;
#endif  // !_MSC_VER

Features::Features()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Features::InitAsDefaultInstance() {
}

Features::Features(const Features& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Features::SharedCtor() {
  _cached_size_ = 0;
  vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  major_version_ = 0u;
  minor_version_ = 0u;
  patch_version_ = 0u;
  bootloader_mode_ = false;
  device_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pin_protection_ = false;
  passphrase_protection_ = false;
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  initialized_ = false;
  revision_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bootloader_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  imported_ = false;
  cpu_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Features::~Features() {
  SharedDtor();
}

void Features::SharedDtor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (device_id_ != &::google::protobuf::internal::kEmptyString) {
    delete device_id_;
  }
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (revision_ != &::google::protobuf::internal::kEmptyString) {
    delete revision_;
  }
  if (bootloader_hash_ != &::google::protobuf::internal::kEmptyString) {
    delete bootloader_hash_;
  }
  if (cpu_sn_ != &::google::protobuf::internal::kEmptyString) {
    delete cpu_sn_;
  }
  if (this != default_instance_) {
  }
}

void Features::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Features::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Features_descriptor_;
}

const Features& Features::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Features* Features::default_instance_ = NULL;

Features* Features::New() const {
  return new Features;
}

void Features::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_vendor()) {
      if (vendor_ != &::google::protobuf::internal::kEmptyString) {
        vendor_->clear();
      }
    }
    major_version_ = 0u;
    minor_version_ = 0u;
    patch_version_ = 0u;
    bootloader_mode_ = false;
    if (has_device_id()) {
      if (device_id_ != &::google::protobuf::internal::kEmptyString) {
        device_id_->clear();
      }
    }
    pin_protection_ = false;
    passphrase_protection_ = false;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
    initialized_ = false;
    if (has_revision()) {
      if (revision_ != &::google::protobuf::internal::kEmptyString) {
        revision_->clear();
      }
    }
    if (has_bootloader_hash()) {
      if (bootloader_hash_ != &::google::protobuf::internal::kEmptyString) {
        bootloader_hash_->clear();
      }
    }
    imported_ = false;
    if (has_cpu_sn()) {
      if (cpu_sn_ != &::google::protobuf::internal::kEmptyString) {
        cpu_sn_->clear();
      }
    }
  }
  coins_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Features::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string vendor = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vendor()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->vendor().data(), this->vendor().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_major_version;
        break;
      }

      // optional uint32 major_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_major_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &major_version_)));
          set_has_major_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_minor_version;
        break;
      }

      // optional uint32 minor_version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minor_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &minor_version_)));
          set_has_minor_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_patch_version;
        break;
      }

      // optional uint32 patch_version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_patch_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &patch_version_)));
          set_has_patch_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_bootloader_mode;
        break;
      }

      // optional bool bootloader_mode = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_bootloader_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bootloader_mode_)));
          set_has_bootloader_mode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_device_id;
        break;
      }

      // optional string device_id = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_device_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->device_id().data(), this->device_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_pin_protection;
        break;
      }

      // optional bool pin_protection = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
          set_has_pin_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_language;
        break;
      }

      // optional string language = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_label;
        break;
      }

      // optional string label = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_coins;
        break;
      }

      // repeated .CoinType coins = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coins:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_coins()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_coins;
        if (input->ExpectTag(96)) goto parse_initialized;
        break;
      }

      // optional bool initialized = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_initialized:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &initialized_)));
          set_has_initialized();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_revision;
        break;
      }

      // optional bytes revision = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_revision:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_revision()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_bootloader_hash;
        break;
      }

      // optional bytes bootloader_hash = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bootloader_hash:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_bootloader_hash()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_imported;
        break;
      }

      // optional bool imported = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_imported:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &imported_)));
          set_has_imported();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(130)) goto parse_cpu_sn;
        break;
      }

      // optional string cpu_sn = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cpu_sn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cpu_sn()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->cpu_sn().data(), this->cpu_sn().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Features::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string vendor = 1;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->vendor(), output);
  }

  // optional uint32 major_version = 2;
  if (has_major_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->major_version(), output);
  }

  // optional uint32 minor_version = 3;
  if (has_minor_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->minor_version(), output);
  }

  // optional uint32 patch_version = 4;
  if (has_patch_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->patch_version(), output);
  }

  // optional bool bootloader_mode = 5;
  if (has_bootloader_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->bootloader_mode(), output);
  }

  // optional string device_id = 6;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->device_id(), output);
  }

  // optional bool pin_protection = 7;
  if (has_pin_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->pin_protection(), output);
  }

  // optional bool passphrase_protection = 8;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->passphrase_protection(), output);
  }

  // optional string language = 9;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->language(), output);
  }

  // optional string label = 10;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->label(), output);
  }

  // repeated .CoinType coins = 11;
  for (int i = 0; i < this->coins_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->coins(i), output);
  }

  // optional bool initialized = 12;
  if (has_initialized()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->initialized(), output);
  }

  // optional bytes revision = 13;
  if (has_revision()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      13, this->revision(), output);
  }

  // optional bytes bootloader_hash = 14;
  if (has_bootloader_hash()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      14, this->bootloader_hash(), output);
  }

  // optional bool imported = 15;
  if (has_imported()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(15, this->imported(), output);
  }

  // optional string cpu_sn = 16;
  if (has_cpu_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cpu_sn().data(), this->cpu_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      16, this->cpu_sn(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Features::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string vendor = 1;
  if (has_vendor()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->vendor().data(), this->vendor().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->vendor(), target);
  }

  // optional uint32 major_version = 2;
  if (has_major_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->major_version(), target);
  }

  // optional uint32 minor_version = 3;
  if (has_minor_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->minor_version(), target);
  }

  // optional uint32 patch_version = 4;
  if (has_patch_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->patch_version(), target);
  }

  // optional bool bootloader_mode = 5;
  if (has_bootloader_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->bootloader_mode(), target);
  }

  // optional string device_id = 6;
  if (has_device_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->device_id().data(), this->device_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->device_id(), target);
  }

  // optional bool pin_protection = 7;
  if (has_pin_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->pin_protection(), target);
  }

  // optional bool passphrase_protection = 8;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->passphrase_protection(), target);
  }

  // optional string language = 9;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->language(), target);
  }

  // optional string label = 10;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->label(), target);
  }

  // repeated .CoinType coins = 11;
  for (int i = 0; i < this->coins_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->coins(i), target);
  }

  // optional bool initialized = 12;
  if (has_initialized()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->initialized(), target);
  }

  // optional bytes revision = 13;
  if (has_revision()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        13, this->revision(), target);
  }

  // optional bytes bootloader_hash = 14;
  if (has_bootloader_hash()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        14, this->bootloader_hash(), target);
  }

  // optional bool imported = 15;
  if (has_imported()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(15, this->imported(), target);
  }

  // optional string cpu_sn = 16;
  if (has_cpu_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->cpu_sn().data(), this->cpu_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        16, this->cpu_sn(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Features::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string vendor = 1;
    if (has_vendor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vendor());
    }

    // optional uint32 major_version = 2;
    if (has_major_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->major_version());
    }

    // optional uint32 minor_version = 3;
    if (has_minor_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->minor_version());
    }

    // optional uint32 patch_version = 4;
    if (has_patch_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->patch_version());
    }

    // optional bool bootloader_mode = 5;
    if (has_bootloader_mode()) {
      total_size += 1 + 1;
    }

    // optional string device_id = 6;
    if (has_device_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->device_id());
    }

    // optional bool pin_protection = 7;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 8;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string language = 9;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 10;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bool initialized = 12;
    if (has_initialized()) {
      total_size += 1 + 1;
    }

    // optional bytes revision = 13;
    if (has_revision()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->revision());
    }

    // optional bytes bootloader_hash = 14;
    if (has_bootloader_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->bootloader_hash());
    }

    // optional bool imported = 15;
    if (has_imported()) {
      total_size += 1 + 1;
    }

    // optional string cpu_sn = 16;
    if (has_cpu_sn()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cpu_sn());
    }

  }
  // repeated .CoinType coins = 11;
  total_size += 1 * this->coins_size();
  for (int i = 0; i < this->coins_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->coins(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Features::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Features* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Features*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Features::MergeFrom(const Features& from) {
  GOOGLE_CHECK_NE(&from, this);
  coins_.MergeFrom(from.coins_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_vendor()) {
      set_vendor(from.vendor());
    }
    if (from.has_major_version()) {
      set_major_version(from.major_version());
    }
    if (from.has_minor_version()) {
      set_minor_version(from.minor_version());
    }
    if (from.has_patch_version()) {
      set_patch_version(from.patch_version());
    }
    if (from.has_bootloader_mode()) {
      set_bootloader_mode(from.bootloader_mode());
    }
    if (from.has_device_id()) {
      set_device_id(from.device_id());
    }
    if (from.has_pin_protection()) {
      set_pin_protection(from.pin_protection());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_initialized()) {
      set_initialized(from.initialized());
    }
    if (from.has_revision()) {
      set_revision(from.revision());
    }
    if (from.has_bootloader_hash()) {
      set_bootloader_hash(from.bootloader_hash());
    }
    if (from.has_imported()) {
      set_imported(from.imported());
    }
    if (from.has_cpu_sn()) {
      set_cpu_sn(from.cpu_sn());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Features::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Features::CopyFrom(const Features& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Features::IsInitialized() const {

  return true;
}

void Features::Swap(Features* other) {
  if (other != this) {
    std::swap(vendor_, other->vendor_);
    std::swap(major_version_, other->major_version_);
    std::swap(minor_version_, other->minor_version_);
    std::swap(patch_version_, other->patch_version_);
    std::swap(bootloader_mode_, other->bootloader_mode_);
    std::swap(device_id_, other->device_id_);
    std::swap(pin_protection_, other->pin_protection_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(language_, other->language_);
    std::swap(label_, other->label_);
    coins_.Swap(&other->coins_);
    std::swap(initialized_, other->initialized_);
    std::swap(revision_, other->revision_);
    std::swap(bootloader_hash_, other->bootloader_hash_);
    std::swap(imported_, other->imported_);
    std::swap(cpu_sn_, other->cpu_sn_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Features::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Features_descriptor_;
  metadata.reflection = Features_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ClearSession::ClearSession()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ClearSession::InitAsDefaultInstance() {
}

ClearSession::ClearSession(const ClearSession& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ClearSession::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClearSession::~ClearSession() {
  SharedDtor();
}

void ClearSession::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ClearSession::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ClearSession::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ClearSession_descriptor_;
}

const ClearSession& ClearSession::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ClearSession* ClearSession::default_instance_ = NULL;

ClearSession* ClearSession::New() const {
  return new ClearSession;
}

void ClearSession::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ClearSession::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ClearSession::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ClearSession::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ClearSession::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClearSession::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ClearSession* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ClearSession*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ClearSession::MergeFrom(const ClearSession& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ClearSession::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ClearSession::CopyFrom(const ClearSession& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearSession::IsInitialized() const {

  return true;
}

void ClearSession::Swap(ClearSession* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ClearSession::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ClearSession_descriptor_;
  metadata.reflection = ClearSession_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ApplySettings::kLanguageFieldNumber;
const int ApplySettings::kLabelFieldNumber;
#endif  // !_MSC_VER

ApplySettings::ApplySettings()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ApplySettings::InitAsDefaultInstance() {
}

ApplySettings::ApplySettings(const ApplySettings& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ApplySettings::SharedCtor() {
  _cached_size_ = 0;
  language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ApplySettings::~ApplySettings() {
  SharedDtor();
}

void ApplySettings::SharedDtor() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void ApplySettings::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ApplySettings::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ApplySettings_descriptor_;
}

const ApplySettings& ApplySettings::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ApplySettings* ApplySettings::default_instance_ = NULL;

ApplySettings* ApplySettings::New() const {
  return new ApplySettings;
}

void ApplySettings::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_language()) {
      if (language_ != &::google::protobuf::internal::kEmptyString) {
        language_->clear();
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ApplySettings::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string language = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_label;
        break;
      }

      // optional string label = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ApplySettings::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string language = 1;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->language(), output);
  }

  // optional string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ApplySettings::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string language = 1;
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->language(), target);
  }

  // optional string label = 2;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ApplySettings::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string language = 1;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 2;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ApplySettings::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ApplySettings* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ApplySettings*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ApplySettings::MergeFrom(const ApplySettings& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ApplySettings::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ApplySettings::CopyFrom(const ApplySettings& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ApplySettings::IsInitialized() const {

  return true;
}

void ApplySettings::Swap(ApplySettings* other) {
  if (other != this) {
    std::swap(language_, other->language_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ApplySettings::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ApplySettings_descriptor_;
  metadata.reflection = ApplySettings_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ChangePin::kRemoveFieldNumber;
#endif  // !_MSC_VER

ChangePin::ChangePin()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ChangePin::InitAsDefaultInstance() {
}

ChangePin::ChangePin(const ChangePin& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ChangePin::SharedCtor() {
  _cached_size_ = 0;
  remove_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangePin::~ChangePin() {
  SharedDtor();
}

void ChangePin::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ChangePin::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ChangePin::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ChangePin_descriptor_;
}

const ChangePin& ChangePin::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ChangePin* ChangePin::default_instance_ = NULL;

ChangePin* ChangePin::New() const {
  return new ChangePin;
}

void ChangePin::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    remove_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ChangePin::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool remove = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remove_)));
          set_has_remove();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ChangePin::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool remove = 1;
  if (has_remove()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->remove(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ChangePin::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool remove = 1;
  if (has_remove()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->remove(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ChangePin::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool remove = 1;
    if (has_remove()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangePin::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ChangePin* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ChangePin*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ChangePin::MergeFrom(const ChangePin& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_remove()) {
      set_remove(from.remove());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ChangePin::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ChangePin::CopyFrom(const ChangePin& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangePin::IsInitialized() const {

  return true;
}

void ChangePin::Swap(ChangePin* other) {
  if (other != this) {
    std::swap(remove_, other->remove_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ChangePin::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ChangePin_descriptor_;
  metadata.reflection = ChangePin_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Ping::kMessageFieldNumber;
const int Ping::kButtonProtectionFieldNumber;
const int Ping::kPinProtectionFieldNumber;
const int Ping::kPassphraseProtectionFieldNumber;
#endif  // !_MSC_VER

Ping::Ping()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Ping::InitAsDefaultInstance() {
}

Ping::Ping(const Ping& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Ping::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  button_protection_ = false;
  pin_protection_ = false;
  passphrase_protection_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ping::~Ping() {
  SharedDtor();
}

void Ping::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Ping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ping_descriptor_;
}

const Ping& Ping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Ping* Ping::default_instance_ = NULL;

Ping* Ping::New() const {
  return new Ping;
}

void Ping::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
    button_protection_ = false;
    pin_protection_ = false;
    passphrase_protection_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Ping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_button_protection;
        break;
      }

      // optional bool button_protection = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_button_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &button_protection_)));
          set_has_button_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pin_protection;
        break;
      }

      // optional bool pin_protection = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
          set_has_pin_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Ping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }

  // optional bool button_protection = 2;
  if (has_button_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->button_protection(), output);
  }

  // optional bool pin_protection = 3;
  if (has_pin_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->pin_protection(), output);
  }

  // optional bool passphrase_protection = 4;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->passphrase_protection(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Ping::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  // optional bool button_protection = 2;
  if (has_button_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->button_protection(), target);
  }

  // optional bool pin_protection = 3;
  if (has_pin_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->pin_protection(), target);
  }

  // optional bool passphrase_protection = 4;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->passphrase_protection(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Ping::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional bool button_protection = 2;
    if (has_button_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 3;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional bool passphrase_protection = 4;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ping::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Ping* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Ping*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Ping::MergeFrom(const Ping& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_button_protection()) {
      set_button_protection(from.button_protection());
    }
    if (from.has_pin_protection()) {
      set_pin_protection(from.pin_protection());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Ping::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ping::CopyFrom(const Ping& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ping::IsInitialized() const {

  return true;
}

void Ping::Swap(Ping* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(button_protection_, other->button_protection_);
    std::swap(pin_protection_, other->pin_protection_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Ping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ping_descriptor_;
  metadata.reflection = Ping_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Success::kMessageFieldNumber;
const int Success::kPayloadFieldNumber;
#endif  // !_MSC_VER

Success::Success()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Success::InitAsDefaultInstance() {
}

Success::Success(const Success& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Success::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Success::~Success() {
  SharedDtor();
}

void Success::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (this != default_instance_) {
  }
}

void Success::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Success::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Success_descriptor_;
}

const Success& Success::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Success* Success::default_instance_ = NULL;

Success* Success::New() const {
  return new Success;
}

void Success::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Success::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string message = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_payload;
        break;
      }

      // optional bytes payload = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_payload:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Success::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->message(), output);
  }

  // optional bytes payload = 2;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->payload(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Success::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string message = 1;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->message(), target);
  }

  // optional bytes payload = 2;
  if (has_payload()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->payload(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Success::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string message = 1;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional bytes payload = 2;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Success::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Success* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Success*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Success::MergeFrom(const Success& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Success::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Success::CopyFrom(const Success& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Success::IsInitialized() const {

  return true;
}

void Success::Swap(Success* other) {
  if (other != this) {
    std::swap(message_, other->message_);
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Success::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Success_descriptor_;
  metadata.reflection = Success_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Failure::kCodeFieldNumber;
const int Failure::kMessageFieldNumber;
#endif  // !_MSC_VER

Failure::Failure()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Failure::InitAsDefaultInstance() {
}

Failure::Failure(const Failure& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Failure::SharedCtor() {
  _cached_size_ = 0;
  code_ = 1;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Failure::~Failure() {
  SharedDtor();
}

void Failure::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void Failure::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Failure::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Failure_descriptor_;
}

const Failure& Failure::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Failure* Failure::default_instance_ = NULL;

Failure* Failure::New() const {
  return new Failure;
}

void Failure::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 1;
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Failure::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .FailureType code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::FailureType_IsValid(value)) {
            set_code(static_cast< ::FailureType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional string message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Failure::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .FailureType code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Failure::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .FailureType code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Failure::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .FailureType code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

    // optional string message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Failure::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Failure* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Failure*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Failure::MergeFrom(const Failure& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Failure::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Failure::CopyFrom(const Failure& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Failure::IsInitialized() const {

  return true;
}

void Failure::Swap(Failure* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Failure::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Failure_descriptor_;
  metadata.reflection = Failure_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ButtonRequest::kCodeFieldNumber;
const int ButtonRequest::kDataFieldNumber;
#endif  // !_MSC_VER

ButtonRequest::ButtonRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ButtonRequest::InitAsDefaultInstance() {
}

ButtonRequest::ButtonRequest(const ButtonRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ButtonRequest::SharedCtor() {
  _cached_size_ = 0;
  code_ = 1;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ButtonRequest::~ButtonRequest() {
  SharedDtor();
}

void ButtonRequest::SharedDtor() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void ButtonRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonRequest_descriptor_;
}

const ButtonRequest& ButtonRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ButtonRequest* ButtonRequest::default_instance_ = NULL;

ButtonRequest* ButtonRequest::New() const {
  return new ButtonRequest;
}

void ButtonRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    code_ = 1;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::kEmptyString) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ButtonRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ButtonRequestType code = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ButtonRequestType_IsValid(value)) {
            set_code(static_cast< ::ButtonRequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // optional string data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->data().data(), this->data().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ButtonRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ButtonRequestType code = 1;
  if (has_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->code(), output);
  }

  // optional string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ButtonRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ButtonRequestType code = 1;
  if (has_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->code(), target);
  }

  // optional string data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->data().data(), this->data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ButtonRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ButtonRequestType code = 1;
    if (has_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->code());
    }

    // optional string data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ButtonRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ButtonRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ButtonRequest::MergeFrom(const ButtonRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_code()) {
      set_code(from.code());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ButtonRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonRequest::CopyFrom(const ButtonRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonRequest::IsInitialized() const {

  return true;
}

void ButtonRequest::Swap(ButtonRequest* other) {
  if (other != this) {
    std::swap(code_, other->code_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ButtonRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ButtonRequest_descriptor_;
  metadata.reflection = ButtonRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ButtonAck::ButtonAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ButtonAck::InitAsDefaultInstance() {
}

ButtonAck::ButtonAck(const ButtonAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ButtonAck::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ButtonAck::~ButtonAck() {
  SharedDtor();
}

void ButtonAck::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ButtonAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ButtonAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ButtonAck_descriptor_;
}

const ButtonAck& ButtonAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ButtonAck* ButtonAck::default_instance_ = NULL;

ButtonAck* ButtonAck::New() const {
  return new ButtonAck;
}

void ButtonAck::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ButtonAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void ButtonAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ButtonAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ButtonAck::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ButtonAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ButtonAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ButtonAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ButtonAck::MergeFrom(const ButtonAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ButtonAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ButtonAck::CopyFrom(const ButtonAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ButtonAck::IsInitialized() const {

  return true;
}

void ButtonAck::Swap(ButtonAck* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ButtonAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ButtonAck_descriptor_;
  metadata.reflection = ButtonAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PinMatrixRequest::kTypeFieldNumber;
#endif  // !_MSC_VER

PinMatrixRequest::PinMatrixRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PinMatrixRequest::InitAsDefaultInstance() {
}

PinMatrixRequest::PinMatrixRequest(const PinMatrixRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PinMatrixRequest::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PinMatrixRequest::~PinMatrixRequest() {
  SharedDtor();
}

void PinMatrixRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PinMatrixRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixRequest_descriptor_;
}

const PinMatrixRequest& PinMatrixRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PinMatrixRequest* PinMatrixRequest::default_instance_ = NULL;

PinMatrixRequest* PinMatrixRequest::New() const {
  return new PinMatrixRequest;
}

void PinMatrixRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PinMatrixRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .PinMatrixRequestType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::PinMatrixRequestType_IsValid(value)) {
            set_type(static_cast< ::PinMatrixRequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PinMatrixRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .PinMatrixRequestType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PinMatrixRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .PinMatrixRequestType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PinMatrixRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .PinMatrixRequestType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PinMatrixRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PinMatrixRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PinMatrixRequest::MergeFrom(const PinMatrixRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PinMatrixRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixRequest::CopyFrom(const PinMatrixRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixRequest::IsInitialized() const {

  return true;
}

void PinMatrixRequest::Swap(PinMatrixRequest* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PinMatrixRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PinMatrixRequest_descriptor_;
  metadata.reflection = PinMatrixRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PinMatrixAck::kPinFieldNumber;
#endif  // !_MSC_VER

PinMatrixAck::PinMatrixAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PinMatrixAck::InitAsDefaultInstance() {
}

PinMatrixAck::PinMatrixAck(const PinMatrixAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PinMatrixAck::SharedCtor() {
  _cached_size_ = 0;
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PinMatrixAck::~PinMatrixAck() {
  SharedDtor();
}

void PinMatrixAck::SharedDtor() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (this != default_instance_) {
  }
}

void PinMatrixAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PinMatrixAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PinMatrixAck_descriptor_;
}

const PinMatrixAck& PinMatrixAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PinMatrixAck* PinMatrixAck::default_instance_ = NULL;

PinMatrixAck* PinMatrixAck::New() const {
  return new PinMatrixAck;
}

void PinMatrixAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PinMatrixAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string pin = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PinMatrixAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string pin = 1;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->pin(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PinMatrixAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string pin = 1;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->pin(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PinMatrixAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string pin = 1;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PinMatrixAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PinMatrixAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PinMatrixAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PinMatrixAck::MergeFrom(const PinMatrixAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pin()) {
      set_pin(from.pin());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PinMatrixAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PinMatrixAck::CopyFrom(const PinMatrixAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PinMatrixAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PinMatrixAck::Swap(PinMatrixAck* other) {
  if (other != this) {
    std::swap(pin_, other->pin_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PinMatrixAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PinMatrixAck_descriptor_;
  metadata.reflection = PinMatrixAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Cancel::Cancel()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Cancel::InitAsDefaultInstance() {
}

Cancel::Cancel(const Cancel& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Cancel::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Cancel::~Cancel() {
  SharedDtor();
}

void Cancel::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Cancel::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Cancel::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Cancel_descriptor_;
}

const Cancel& Cancel::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Cancel* Cancel::default_instance_ = NULL;

Cancel* Cancel::New() const {
  return new Cancel;
}

void Cancel::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Cancel::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void Cancel::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Cancel::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Cancel::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Cancel::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Cancel* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Cancel*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Cancel::MergeFrom(const Cancel& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Cancel::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Cancel::CopyFrom(const Cancel& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Cancel::IsInitialized() const {

  return true;
}

void Cancel::Swap(Cancel* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Cancel::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Cancel_descriptor_;
  metadata.reflection = Cancel_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

PassphraseRequest::PassphraseRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PassphraseRequest::InitAsDefaultInstance() {
}

PassphraseRequest::PassphraseRequest(const PassphraseRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PassphraseRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PassphraseRequest::~PassphraseRequest() {
  SharedDtor();
}

void PassphraseRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PassphraseRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PassphraseRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PassphraseRequest_descriptor_;
}

const PassphraseRequest& PassphraseRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PassphraseRequest* PassphraseRequest::default_instance_ = NULL;

PassphraseRequest* PassphraseRequest::New() const {
  return new PassphraseRequest;
}

void PassphraseRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PassphraseRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void PassphraseRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PassphraseRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PassphraseRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PassphraseRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PassphraseRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PassphraseRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PassphraseRequest::MergeFrom(const PassphraseRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PassphraseRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassphraseRequest::CopyFrom(const PassphraseRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassphraseRequest::IsInitialized() const {

  return true;
}

void PassphraseRequest::Swap(PassphraseRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PassphraseRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PassphraseRequest_descriptor_;
  metadata.reflection = PassphraseRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PassphraseAck::kPassphraseFieldNumber;
#endif  // !_MSC_VER

PassphraseAck::PassphraseAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PassphraseAck::InitAsDefaultInstance() {
}

PassphraseAck::PassphraseAck(const PassphraseAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PassphraseAck::SharedCtor() {
  _cached_size_ = 0;
  passphrase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PassphraseAck::~PassphraseAck() {
  SharedDtor();
}

void PassphraseAck::SharedDtor() {
  if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
    delete passphrase_;
  }
  if (this != default_instance_) {
  }
}

void PassphraseAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PassphraseAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PassphraseAck_descriptor_;
}

const PassphraseAck& PassphraseAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PassphraseAck* PassphraseAck::default_instance_ = NULL;

PassphraseAck* PassphraseAck::New() const {
  return new PassphraseAck;
}

void PassphraseAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_passphrase()) {
      if (passphrase_ != &::google::protobuf::internal::kEmptyString) {
        passphrase_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PassphraseAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string passphrase = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_passphrase()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->passphrase().data(), this->passphrase().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PassphraseAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string passphrase = 1;
  if (has_passphrase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passphrase().data(), this->passphrase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->passphrase(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PassphraseAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string passphrase = 1;
  if (has_passphrase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->passphrase().data(), this->passphrase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->passphrase(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PassphraseAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string passphrase = 1;
    if (has_passphrase()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->passphrase());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PassphraseAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PassphraseAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PassphraseAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PassphraseAck::MergeFrom(const PassphraseAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_passphrase()) {
      set_passphrase(from.passphrase());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PassphraseAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PassphraseAck::CopyFrom(const PassphraseAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PassphraseAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PassphraseAck::Swap(PassphraseAck* other) {
  if (other != this) {
    std::swap(passphrase_, other->passphrase_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PassphraseAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PassphraseAck_descriptor_;
  metadata.reflection = PassphraseAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetEntropy::kSizeFieldNumber;
#endif  // !_MSC_VER

GetEntropy::GetEntropy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetEntropy::InitAsDefaultInstance() {
}

GetEntropy::GetEntropy(const GetEntropy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetEntropy::SharedCtor() {
  _cached_size_ = 0;
  size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetEntropy::~GetEntropy() {
  SharedDtor();
}

void GetEntropy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetEntropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetEntropy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetEntropy_descriptor_;
}

const GetEntropy& GetEntropy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

GetEntropy* GetEntropy::default_instance_ = NULL;

GetEntropy* GetEntropy::New() const {
  return new GetEntropy;
}

void GetEntropy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetEntropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetEntropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 size = 1;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetEntropy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 size = 1;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetEntropy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 size = 1;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetEntropy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetEntropy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetEntropy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetEntropy::MergeFrom(const GetEntropy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size()) {
      set_size(from.size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetEntropy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetEntropy::CopyFrom(const GetEntropy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetEntropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetEntropy::Swap(GetEntropy* other) {
  if (other != this) {
    std::swap(size_, other->size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetEntropy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetEntropy_descriptor_;
  metadata.reflection = GetEntropy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Entropy::kEntropyFieldNumber;
#endif  // !_MSC_VER

Entropy::Entropy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Entropy::InitAsDefaultInstance() {
}

Entropy::Entropy(const Entropy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Entropy::SharedCtor() {
  _cached_size_ = 0;
  entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Entropy::~Entropy() {
  SharedDtor();
}

void Entropy::SharedDtor() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (this != default_instance_) {
  }
}

void Entropy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Entropy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Entropy_descriptor_;
}

const Entropy& Entropy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Entropy* Entropy::default_instance_ = NULL;

Entropy* Entropy::New() const {
  return new Entropy;
}

void Entropy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_entropy()) {
      if (entropy_ != &::google::protobuf::internal::kEmptyString) {
        entropy_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Entropy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes entropy = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Entropy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes entropy = 1;
  if (has_entropy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entropy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Entropy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes entropy = 1;
  if (has_entropy()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Entropy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes entropy = 1;
    if (has_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->entropy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Entropy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Entropy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Entropy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Entropy::MergeFrom(const Entropy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entropy()) {
      set_entropy(from.entropy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Entropy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Entropy::CopyFrom(const Entropy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Entropy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Entropy::Swap(Entropy* other) {
  if (other != this) {
    std::swap(entropy_, other->entropy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Entropy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Entropy_descriptor_;
  metadata.reflection = Entropy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetPublicKey::kAddressNFieldNumber;
#endif  // !_MSC_VER

GetPublicKey::GetPublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetPublicKey::InitAsDefaultInstance() {
}

GetPublicKey::GetPublicKey(const GetPublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetPublicKey::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetPublicKey::~GetPublicKey() {
  SharedDtor();
}

void GetPublicKey::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetPublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetPublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetPublicKey_descriptor_;
}

const GetPublicKey& GetPublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

GetPublicKey* GetPublicKey::default_instance_ = NULL;

GetPublicKey* GetPublicKey::New() const {
  return new GetPublicKey;
}

void GetPublicKey::Clear() {
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetPublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetPublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetPublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetPublicKey::ByteSize() const {
  int total_size = 0;

  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetPublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetPublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetPublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetPublicKey::MergeFrom(const GetPublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetPublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetPublicKey::CopyFrom(const GetPublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetPublicKey::IsInitialized() const {

  return true;
}

void GetPublicKey::Swap(GetPublicKey* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetPublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetPublicKey_descriptor_;
  metadata.reflection = GetPublicKey_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PublicKey::kNodeFieldNumber;
const int PublicKey::kXpubFieldNumber;
#endif  // !_MSC_VER

PublicKey::PublicKey()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PublicKey::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

PublicKey::PublicKey(const PublicKey& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PublicKey::SharedCtor() {
  _cached_size_ = 0;
  node_ = NULL;
  xpub_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PublicKey::~PublicKey() {
  SharedDtor();
}

void PublicKey::SharedDtor() {
  if (xpub_ != &::google::protobuf::internal::kEmptyString) {
    delete xpub_;
  }
  if (this != default_instance_) {
    delete node_;
  }
}

void PublicKey::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PublicKey::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PublicKey_descriptor_;
}

const PublicKey& PublicKey::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PublicKey* PublicKey::default_instance_ = NULL;

PublicKey* PublicKey::New() const {
  return new PublicKey;
}

void PublicKey::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_node()) {
      if (node_ != NULL) node_->::HDNodeType::Clear();
    }
    if (has_xpub()) {
      if (xpub_ != &::google::protobuf::internal::kEmptyString) {
        xpub_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PublicKey::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HDNodeType node = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_xpub;
        break;
      }

      // optional string xpub = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_xpub:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_xpub()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->xpub().data(), this->xpub().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PublicKey::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HDNodeType node = 1;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->node(), output);
  }

  // optional string xpub = 2;
  if (has_xpub()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->xpub(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PublicKey::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HDNodeType node = 1;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->node(), target);
  }

  // optional string xpub = 2;
  if (has_xpub()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->xpub().data(), this->xpub().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->xpub(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PublicKey::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HDNodeType node = 1;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

    // optional string xpub = 2;
    if (has_xpub()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->xpub());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PublicKey::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PublicKey* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PublicKey*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PublicKey::MergeFrom(const PublicKey& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
    if (from.has_xpub()) {
      set_xpub(from.xpub());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PublicKey::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicKey::CopyFrom(const PublicKey& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PublicKey::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void PublicKey::Swap(PublicKey* other) {
  if (other != this) {
    std::swap(node_, other->node_);
    std::swap(xpub_, other->xpub_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PublicKey::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PublicKey_descriptor_;
  metadata.reflection = PublicKey_reflection_;
  return metadata;
}


// ===================================================================

::std::string* GetAddress::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int GetAddress::kAddressNFieldNumber;
const int GetAddress::kCoinNameFieldNumber;
const int GetAddress::kShowDisplayFieldNumber;
#endif  // !_MSC_VER

GetAddress::GetAddress()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void GetAddress::InitAsDefaultInstance() {
}

GetAddress::GetAddress(const GetAddress& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void GetAddress::SharedCtor() {
  _cached_size_ = 0;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  show_display_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAddress::~GetAddress() {
  SharedDtor();
}

void GetAddress::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void GetAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetAddress_descriptor_;
}

const GetAddress& GetAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

GetAddress* GetAddress::default_instance_ = NULL;

GetAddress* GetAddress::New() const {
  return new GetAddress;
}

void GetAddress::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
    show_display_ = false;
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 2 [default = "Bitcoin"];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_show_display;
        break;
      }

      // optional bool show_display = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_show_display:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &show_display_)));
          set_has_show_display();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void GetAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // optional string coin_name = 2 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->coin_name(), output);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->show_display(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* GetAddress::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // optional string coin_name = 2 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->coin_name(), target);
  }

  // optional bool show_display = 3;
  if (has_show_display()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->show_display(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int GetAddress::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string coin_name = 2 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

    // optional bool show_display = 3;
    if (has_show_display()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAddress::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetAddress* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetAddress*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetAddress::MergeFrom(const GetAddress& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
    if (from.has_show_display()) {
      set_show_display(from.show_display());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetAddress::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetAddress::CopyFrom(const GetAddress& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAddress::IsInitialized() const {

  return true;
}

void GetAddress::Swap(GetAddress* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(show_display_, other->show_display_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetAddress_descriptor_;
  metadata.reflection = GetAddress_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Address::kAddressFieldNumber;
#endif  // !_MSC_VER

Address::Address()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Address::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  SharedDtor();
}

void Address::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (this != default_instance_) {
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New() const {
  return new Address;
}

void Address::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->address(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Address::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Address::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Address* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Address*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Address::Swap(Address* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

WipeDevice::WipeDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WipeDevice::InitAsDefaultInstance() {
}

WipeDevice::WipeDevice(const WipeDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WipeDevice::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WipeDevice::~WipeDevice() {
  SharedDtor();
}

void WipeDevice::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WipeDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WipeDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WipeDevice_descriptor_;
}

const WipeDevice& WipeDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WipeDevice* WipeDevice::default_instance_ = NULL;

WipeDevice* WipeDevice::New() const {
  return new WipeDevice;
}

void WipeDevice::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WipeDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void WipeDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WipeDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WipeDevice::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WipeDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WipeDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WipeDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WipeDevice::MergeFrom(const WipeDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WipeDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WipeDevice::CopyFrom(const WipeDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WipeDevice::IsInitialized() const {

  return true;
}

void WipeDevice::Swap(WipeDevice* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WipeDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WipeDevice_descriptor_;
  metadata.reflection = WipeDevice_reflection_;
  return metadata;
}


// ===================================================================

::std::string* LoadDevice::_default_language_ = NULL;
#ifndef _MSC_VER
const int LoadDevice::kMnemonicFieldNumber;
const int LoadDevice::kNodeFieldNumber;
const int LoadDevice::kPinFieldNumber;
const int LoadDevice::kPassphraseProtectionFieldNumber;
const int LoadDevice::kLanguageFieldNumber;
const int LoadDevice::kLabelFieldNumber;
const int LoadDevice::kSkipChecksumFieldNumber;
#endif  // !_MSC_VER

LoadDevice::LoadDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LoadDevice::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

LoadDevice::LoadDevice(const LoadDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LoadDevice::SharedCtor() {
  _cached_size_ = 0;
  mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  node_ = NULL;
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  passphrase_protection_ = false;
  language_ = const_cast< ::std::string*>(_default_language_);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  skip_checksum_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoadDevice::~LoadDevice() {
  SharedDtor();
}

void LoadDevice::SharedDtor() {
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    delete mnemonic_;
  }
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (language_ != _default_language_) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
    delete node_;
  }
}

void LoadDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoadDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoadDevice_descriptor_;
}

const LoadDevice& LoadDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

LoadDevice* LoadDevice::default_instance_ = NULL;

LoadDevice* LoadDevice::New() const {
  return new LoadDevice;
}

void LoadDevice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mnemonic()) {
      if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
        mnemonic_->clear();
      }
    }
    if (has_node()) {
      if (node_ != NULL) node_->::HDNodeType::Clear();
    }
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
    passphrase_protection_ = false;
    if (has_language()) {
      if (language_ != _default_language_) {
        language_->assign(*_default_language_);
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
    skip_checksum_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoadDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mnemonic = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mnemonic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mnemonic().data(), this->mnemonic().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_node;
        break;
      }

      // optional .HDNodeType node = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_pin;
        break;
      }

      // optional string pin = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_language;
        break;
      }

      // optional string language = 5 [default = "english"];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_label;
        break;
      }

      // optional string label = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_skip_checksum;
        break;
      }

      // optional bool skip_checksum = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_skip_checksum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &skip_checksum_)));
          set_has_skip_checksum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LoadDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string mnemonic = 1;
  if (has_mnemonic()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->mnemonic(), output);
  }

  // optional .HDNodeType node = 2;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->node(), output);
  }

  // optional string pin = 3;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->pin(), output);
  }

  // optional bool passphrase_protection = 4;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->passphrase_protection(), output);
  }

  // optional string language = 5 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->language(), output);
  }

  // optional string label = 6;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->label(), output);
  }

  // optional bool skip_checksum = 7;
  if (has_skip_checksum()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->skip_checksum(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LoadDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string mnemonic = 1;
  if (has_mnemonic()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mnemonic(), target);
  }

  // optional .HDNodeType node = 2;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->node(), target);
  }

  // optional string pin = 3;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->pin(), target);
  }

  // optional bool passphrase_protection = 4;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->passphrase_protection(), target);
  }

  // optional string language = 5 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->language(), target);
  }

  // optional string label = 6;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->label(), target);
  }

  // optional bool skip_checksum = 7;
  if (has_skip_checksum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->skip_checksum(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LoadDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string mnemonic = 1;
    if (has_mnemonic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mnemonic());
    }

    // optional .HDNodeType node = 2;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

    // optional string pin = 3;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin());
    }

    // optional bool passphrase_protection = 4;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional string language = 5 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 6;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bool skip_checksum = 7;
    if (has_skip_checksum()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoadDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoadDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoadDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoadDevice::MergeFrom(const LoadDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mnemonic()) {
      set_mnemonic(from.mnemonic());
    }
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
    if (from.has_pin()) {
      set_pin(from.pin());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_skip_checksum()) {
      set_skip_checksum(from.skip_checksum());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoadDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoadDevice::CopyFrom(const LoadDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoadDevice::IsInitialized() const {

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void LoadDevice::Swap(LoadDevice* other) {
  if (other != this) {
    std::swap(mnemonic_, other->mnemonic_);
    std::swap(node_, other->node_);
    std::swap(pin_, other->pin_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(language_, other->language_);
    std::swap(label_, other->label_);
    std::swap(skip_checksum_, other->skip_checksum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoadDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoadDevice_descriptor_;
  metadata.reflection = LoadDevice_reflection_;
  return metadata;
}


// ===================================================================

::std::string* ResetDevice::_default_language_ = NULL;
#ifndef _MSC_VER
const int ResetDevice::kDisplayRandomFieldNumber;
const int ResetDevice::kStrengthFieldNumber;
const int ResetDevice::kPassphraseProtectionFieldNumber;
const int ResetDevice::kPinProtectionFieldNumber;
const int ResetDevice::kLanguageFieldNumber;
const int ResetDevice::kLabelFieldNumber;
#endif  // !_MSC_VER

ResetDevice::ResetDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResetDevice::InitAsDefaultInstance() {
}

ResetDevice::ResetDevice(const ResetDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResetDevice::SharedCtor() {
  _cached_size_ = 0;
  display_random_ = false;
  strength_ = 128u;
  passphrase_protection_ = false;
  pin_protection_ = false;
  language_ = const_cast< ::std::string*>(_default_language_);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResetDevice::~ResetDevice() {
  SharedDtor();
}

void ResetDevice::SharedDtor() {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void ResetDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResetDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResetDevice_descriptor_;
}

const ResetDevice& ResetDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ResetDevice* ResetDevice::default_instance_ = NULL;

ResetDevice* ResetDevice::New() const {
  return new ResetDevice;
}

void ResetDevice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    display_random_ = false;
    strength_ = 128u;
    passphrase_protection_ = false;
    pin_protection_ = false;
    if (has_language()) {
      if (language_ != _default_language_) {
        language_->assign(*_default_language_);
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResetDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool display_random = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &display_random_)));
          set_has_display_random();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_strength;
        break;
      }

      // optional uint32 strength = 2 [default = 128];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_strength:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &strength_)));
          set_has_strength();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_pin_protection;
        break;
      }

      // optional bool pin_protection = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
          set_has_pin_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_language;
        break;
      }

      // optional string language = 5 [default = "english"];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_label;
        break;
      }

      // optional string label = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResetDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool display_random = 1;
  if (has_display_random()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->display_random(), output);
  }

  // optional uint32 strength = 2 [default = 128];
  if (has_strength()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->strength(), output);
  }

  // optional bool passphrase_protection = 3;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->passphrase_protection(), output);
  }

  // optional bool pin_protection = 4;
  if (has_pin_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->pin_protection(), output);
  }

  // optional string language = 5 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->language(), output);
  }

  // optional string label = 6;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->label(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResetDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool display_random = 1;
  if (has_display_random()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->display_random(), target);
  }

  // optional uint32 strength = 2 [default = 128];
  if (has_strength()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->strength(), target);
  }

  // optional bool passphrase_protection = 3;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->passphrase_protection(), target);
  }

  // optional bool pin_protection = 4;
  if (has_pin_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->pin_protection(), target);
  }

  // optional string language = 5 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->language(), target);
  }

  // optional string label = 6;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->label(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResetDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool display_random = 1;
    if (has_display_random()) {
      total_size += 1 + 1;
    }

    // optional uint32 strength = 2 [default = 128];
    if (has_strength()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->strength());
    }

    // optional bool passphrase_protection = 3;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 4;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional string language = 5 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 6;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResetDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResetDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResetDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResetDevice::MergeFrom(const ResetDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_display_random()) {
      set_display_random(from.display_random());
    }
    if (from.has_strength()) {
      set_strength(from.strength());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
    if (from.has_pin_protection()) {
      set_pin_protection(from.pin_protection());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResetDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResetDevice::CopyFrom(const ResetDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResetDevice::IsInitialized() const {

  return true;
}

void ResetDevice::Swap(ResetDevice* other) {
  if (other != this) {
    std::swap(display_random_, other->display_random_);
    std::swap(strength_, other->strength_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(pin_protection_, other->pin_protection_);
    std::swap(language_, other->language_);
    std::swap(label_, other->label_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResetDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResetDevice_descriptor_;
  metadata.reflection = ResetDevice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

EntropyRequest::EntropyRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntropyRequest::InitAsDefaultInstance() {
}

EntropyRequest::EntropyRequest(const EntropyRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntropyRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntropyRequest::~EntropyRequest() {
  SharedDtor();
}

void EntropyRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EntropyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntropyRequest_descriptor_;
}

const EntropyRequest& EntropyRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

EntropyRequest* EntropyRequest::default_instance_ = NULL;

EntropyRequest* EntropyRequest::New() const {
  return new EntropyRequest;
}

void EntropyRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntropyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void EntropyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntropyRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntropyRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntropyRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntropyRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntropyRequest::MergeFrom(const EntropyRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntropyRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyRequest::CopyFrom(const EntropyRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyRequest::IsInitialized() const {

  return true;
}

void EntropyRequest::Swap(EntropyRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntropyRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntropyRequest_descriptor_;
  metadata.reflection = EntropyRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EntropyAck::kEntropyFieldNumber;
#endif  // !_MSC_VER

EntropyAck::EntropyAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EntropyAck::InitAsDefaultInstance() {
}

EntropyAck::EntropyAck(const EntropyAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EntropyAck::SharedCtor() {
  _cached_size_ = 0;
  entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EntropyAck::~EntropyAck() {
  SharedDtor();
}

void EntropyAck::SharedDtor() {
  if (entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete entropy_;
  }
  if (this != default_instance_) {
  }
}

void EntropyAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EntropyAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EntropyAck_descriptor_;
}

const EntropyAck& EntropyAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

EntropyAck* EntropyAck::default_instance_ = NULL;

EntropyAck* EntropyAck::New() const {
  return new EntropyAck;
}

void EntropyAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_entropy()) {
      if (entropy_ != &::google::protobuf::internal::kEmptyString) {
        entropy_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EntropyAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes entropy = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_entropy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EntropyAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes entropy = 1;
  if (has_entropy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entropy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EntropyAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes entropy = 1;
  if (has_entropy()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->entropy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EntropyAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes entropy = 1;
    if (has_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->entropy());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EntropyAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EntropyAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EntropyAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EntropyAck::MergeFrom(const EntropyAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_entropy()) {
      set_entropy(from.entropy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EntropyAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EntropyAck::CopyFrom(const EntropyAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntropyAck::IsInitialized() const {

  return true;
}

void EntropyAck::Swap(EntropyAck* other) {
  if (other != this) {
    std::swap(entropy_, other->entropy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EntropyAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EntropyAck_descriptor_;
  metadata.reflection = EntropyAck_reflection_;
  return metadata;
}


// ===================================================================

::std::string* RecoveryDevice::_default_language_ = NULL;
#ifndef _MSC_VER
const int RecoveryDevice::kWordCountFieldNumber;
const int RecoveryDevice::kPassphraseProtectionFieldNumber;
const int RecoveryDevice::kPinProtectionFieldNumber;
const int RecoveryDevice::kLanguageFieldNumber;
const int RecoveryDevice::kLabelFieldNumber;
const int RecoveryDevice::kEnforceWordlistFieldNumber;
#endif  // !_MSC_VER

RecoveryDevice::RecoveryDevice()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RecoveryDevice::InitAsDefaultInstance() {
}

RecoveryDevice::RecoveryDevice(const RecoveryDevice& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RecoveryDevice::SharedCtor() {
  _cached_size_ = 0;
  word_count_ = 0u;
  passphrase_protection_ = false;
  pin_protection_ = false;
  language_ = const_cast< ::std::string*>(_default_language_);
  label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  enforce_wordlist_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RecoveryDevice::~RecoveryDevice() {
  SharedDtor();
}

void RecoveryDevice::SharedDtor() {
  if (language_ != _default_language_) {
    delete language_;
  }
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (this != default_instance_) {
  }
}

void RecoveryDevice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RecoveryDevice::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RecoveryDevice_descriptor_;
}

const RecoveryDevice& RecoveryDevice::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RecoveryDevice* RecoveryDevice::default_instance_ = NULL;

RecoveryDevice* RecoveryDevice::New() const {
  return new RecoveryDevice;
}

void RecoveryDevice::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    word_count_ = 0u;
    passphrase_protection_ = false;
    pin_protection_ = false;
    if (has_language()) {
      if (language_ != _default_language_) {
        language_->assign(*_default_language_);
      }
    }
    if (has_label()) {
      if (label_ != &::google::protobuf::internal::kEmptyString) {
        label_->clear();
      }
    }
    enforce_wordlist_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RecoveryDevice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 word_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &word_count_)));
          set_has_word_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_pin_protection;
        break;
      }

      // optional bool pin_protection = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pin_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pin_protection_)));
          set_has_pin_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_language;
        break;
      }

      // optional string language = 4 [default = "english"];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_label;
        break;
      }

      // optional string label = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_label:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_label()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->label().data(), this->label().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_enforce_wordlist;
        break;
      }

      // optional bool enforce_wordlist = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_enforce_wordlist:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enforce_wordlist_)));
          set_has_enforce_wordlist();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RecoveryDevice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 word_count = 1;
  if (has_word_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->word_count(), output);
  }

  // optional bool passphrase_protection = 2;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->passphrase_protection(), output);
  }

  // optional bool pin_protection = 3;
  if (has_pin_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->pin_protection(), output);
  }

  // optional string language = 4 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->language(), output);
  }

  // optional string label = 5;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->label(), output);
  }

  // optional bool enforce_wordlist = 6;
  if (has_enforce_wordlist()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->enforce_wordlist(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RecoveryDevice::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 word_count = 1;
  if (has_word_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->word_count(), target);
  }

  // optional bool passphrase_protection = 2;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->passphrase_protection(), target);
  }

  // optional bool pin_protection = 3;
  if (has_pin_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->pin_protection(), target);
  }

  // optional string language = 4 [default = "english"];
  if (has_language()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->language(), target);
  }

  // optional string label = 5;
  if (has_label()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->label().data(), this->label().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->label(), target);
  }

  // optional bool enforce_wordlist = 6;
  if (has_enforce_wordlist()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->enforce_wordlist(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RecoveryDevice::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 word_count = 1;
    if (has_word_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->word_count());
    }

    // optional bool passphrase_protection = 2;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional bool pin_protection = 3;
    if (has_pin_protection()) {
      total_size += 1 + 1;
    }

    // optional string language = 4 [default = "english"];
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->language());
    }

    // optional string label = 5;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->label());
    }

    // optional bool enforce_wordlist = 6;
    if (has_enforce_wordlist()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RecoveryDevice::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RecoveryDevice* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RecoveryDevice*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RecoveryDevice::MergeFrom(const RecoveryDevice& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word_count()) {
      set_word_count(from.word_count());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
    if (from.has_pin_protection()) {
      set_pin_protection(from.pin_protection());
    }
    if (from.has_language()) {
      set_language(from.language());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_enforce_wordlist()) {
      set_enforce_wordlist(from.enforce_wordlist());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RecoveryDevice::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RecoveryDevice::CopyFrom(const RecoveryDevice& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RecoveryDevice::IsInitialized() const {

  return true;
}

void RecoveryDevice::Swap(RecoveryDevice* other) {
  if (other != this) {
    std::swap(word_count_, other->word_count_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(pin_protection_, other->pin_protection_);
    std::swap(language_, other->language_);
    std::swap(label_, other->label_);
    std::swap(enforce_wordlist_, other->enforce_wordlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RecoveryDevice::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RecoveryDevice_descriptor_;
  metadata.reflection = RecoveryDevice_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

WordRequest::WordRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WordRequest::InitAsDefaultInstance() {
}

WordRequest::WordRequest(const WordRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WordRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WordRequest::~WordRequest() {
  SharedDtor();
}

void WordRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WordRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WordRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WordRequest_descriptor_;
}

const WordRequest& WordRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WordRequest* WordRequest::default_instance_ = NULL;

WordRequest* WordRequest::New() const {
  return new WordRequest;
}

void WordRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WordRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void WordRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WordRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WordRequest::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WordRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WordRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WordRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WordRequest::MergeFrom(const WordRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WordRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WordRequest::CopyFrom(const WordRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordRequest::IsInitialized() const {

  return true;
}

void WordRequest::Swap(WordRequest* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WordRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WordRequest_descriptor_;
  metadata.reflection = WordRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WordAck::kWordFieldNumber;
#endif  // !_MSC_VER

WordAck::WordAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void WordAck::InitAsDefaultInstance() {
}

WordAck::WordAck(const WordAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void WordAck::SharedCtor() {
  _cached_size_ = 0;
  word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WordAck::~WordAck() {
  SharedDtor();
}

void WordAck::SharedDtor() {
  if (word_ != &::google::protobuf::internal::kEmptyString) {
    delete word_;
  }
  if (this != default_instance_) {
  }
}

void WordAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WordAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WordAck_descriptor_;
}

const WordAck& WordAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WordAck* WordAck::default_instance_ = NULL;

WordAck* WordAck::New() const {
  return new WordAck;
}

void WordAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_word()) {
      if (word_ != &::google::protobuf::internal::kEmptyString) {
        word_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WordAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string word = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->word().data(), this->word().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void WordAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->word(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* WordAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string word = 1;
  if (has_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->word().data(), this->word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->word(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int WordAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string word = 1;
    if (has_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->word());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WordAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WordAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WordAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WordAck::MergeFrom(const WordAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_word()) {
      set_word(from.word());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WordAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WordAck::CopyFrom(const WordAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WordAck::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WordAck::Swap(WordAck* other) {
  if (other != this) {
    std::swap(word_, other->word_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WordAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WordAck_descriptor_;
  metadata.reflection = WordAck_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SignMessage::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int SignMessage::kAddressNFieldNumber;
const int SignMessage::kMessageFieldNumber;
const int SignMessage::kCoinNameFieldNumber;
#endif  // !_MSC_VER

SignMessage::SignMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignMessage::InitAsDefaultInstance() {
}

SignMessage::SignMessage(const SignMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignMessage::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignMessage::~SignMessage() {
  SharedDtor();
}

void SignMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void SignMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignMessage_descriptor_;
}

const SignMessage& SignMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SignMessage* SignMessage::default_instance_ = NULL;

SignMessage* SignMessage::New() const {
  return new SignMessage;
}

void SignMessage::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // required bytes message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // required bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->message(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // required bytes message = 2;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional string coin_name = 3 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignMessage::MergeFrom(const SignMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignMessage::CopyFrom(const SignMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignMessage::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void SignMessage::Swap(SignMessage* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(message_, other->message_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignMessage_descriptor_;
  metadata.reflection = SignMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VerifyMessage::kAddressFieldNumber;
const int VerifyMessage::kSignatureFieldNumber;
const int VerifyMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

VerifyMessage::VerifyMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VerifyMessage::InitAsDefaultInstance() {
}

VerifyMessage::VerifyMessage(const VerifyMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VerifyMessage::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VerifyMessage::~VerifyMessage() {
  SharedDtor();
}

void VerifyMessage::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void VerifyMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VerifyMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VerifyMessage_descriptor_;
}

const VerifyMessage& VerifyMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

VerifyMessage* VerifyMessage::default_instance_ = NULL;

VerifyMessage* VerifyMessage::New() const {
  return new VerifyMessage;
}

void VerifyMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VerifyMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_message;
        break;
      }

      // optional bytes message = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VerifyMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signature(), output);
  }

  // optional bytes message = 3;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VerifyMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  // optional bytes message = 3;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VerifyMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

    // optional bytes message = 3;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VerifyMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VerifyMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VerifyMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VerifyMessage::MergeFrom(const VerifyMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VerifyMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VerifyMessage::CopyFrom(const VerifyMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyMessage::IsInitialized() const {

  return true;
}

void VerifyMessage::Swap(VerifyMessage* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(signature_, other->signature_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VerifyMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VerifyMessage_descriptor_;
  metadata.reflection = VerifyMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MessageSignature::kAddressFieldNumber;
const int MessageSignature::kSignatureFieldNumber;
#endif  // !_MSC_VER

MessageSignature::MessageSignature()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MessageSignature::InitAsDefaultInstance() {
}

MessageSignature::MessageSignature(const MessageSignature& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MessageSignature::SharedCtor() {
  _cached_size_ = 0;
  address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MessageSignature::~MessageSignature() {
  SharedDtor();
}

void MessageSignature::SharedDtor() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (this != default_instance_) {
  }
}

void MessageSignature::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MessageSignature::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MessageSignature_descriptor_;
}

const MessageSignature& MessageSignature::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

MessageSignature* MessageSignature::default_instance_ = NULL;

MessageSignature* MessageSignature::New() const {
  return new MessageSignature;
}

void MessageSignature::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_address()) {
      if (address_ != &::google::protobuf::internal::kEmptyString) {
        address_->clear();
      }
    }
    if (has_signature()) {
      if (signature_ != &::google::protobuf::internal::kEmptyString) {
        signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MessageSignature::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string address = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->address().data(), this->address().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_signature;
        break;
      }

      // optional bytes signature = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_signature()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MessageSignature::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->address(), output);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->signature(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MessageSignature::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string address = 1;
  if (has_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->address().data(), this->address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->address(), target);
  }

  // optional bytes signature = 2;
  if (has_signature()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->signature(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MessageSignature::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string address = 1;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->address());
    }

    // optional bytes signature = 2;
    if (has_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->signature());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MessageSignature::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MessageSignature* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MessageSignature*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MessageSignature::MergeFrom(const MessageSignature& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_address()) {
      set_address(from.address());
    }
    if (from.has_signature()) {
      set_signature(from.signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MessageSignature::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MessageSignature::CopyFrom(const MessageSignature& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MessageSignature::IsInitialized() const {

  return true;
}

void MessageSignature::Swap(MessageSignature* other) {
  if (other != this) {
    std::swap(address_, other->address_);
    std::swap(signature_, other->signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MessageSignature::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MessageSignature_descriptor_;
  metadata.reflection = MessageSignature_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EncryptMessage::kPubkeyFieldNumber;
const int EncryptMessage::kMessageFieldNumber;
const int EncryptMessage::kDisplayOnlyFieldNumber;
const int EncryptMessage::kAddressNFieldNumber;
#endif  // !_MSC_VER

EncryptMessage::EncryptMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EncryptMessage::InitAsDefaultInstance() {
}

EncryptMessage::EncryptMessage(const EncryptMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EncryptMessage::SharedCtor() {
  _cached_size_ = 0;
  pubkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  display_only_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EncryptMessage::~EncryptMessage() {
  SharedDtor();
}

void EncryptMessage::SharedDtor() {
  if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
    delete pubkey_;
  }
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void EncryptMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EncryptMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EncryptMessage_descriptor_;
}

const EncryptMessage& EncryptMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

EncryptMessage* EncryptMessage::default_instance_ = NULL;

EncryptMessage* EncryptMessage::New() const {
  return new EncryptMessage;
}

void EncryptMessage::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pubkey()) {
      if (pubkey_ != &::google::protobuf::internal::kEmptyString) {
        pubkey_->clear();
      }
    }
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
    display_only_ = false;
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EncryptMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes pubkey = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_pubkey()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_display_only;
        break;
      }

      // optional bool display_only = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_display_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &display_only_)));
          set_has_display_only();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_address_n;
        break;
      }

      // repeated uint32 address_n = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_address_n;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EncryptMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->pubkey(), output);
  }

  // optional bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->message(), output);
  }

  // optional bool display_only = 3;
  if (has_display_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->display_only(), output);
  }

  // repeated uint32 address_n = 4;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->address_n(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EncryptMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes pubkey = 1;
  if (has_pubkey()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->pubkey(), target);
  }

  // optional bytes message = 2;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  // optional bool display_only = 3;
  if (has_display_only()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->display_only(), target);
  }

  // repeated uint32 address_n = 4;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->address_n(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EncryptMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes pubkey = 1;
    if (has_pubkey()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->pubkey());
    }

    // optional bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

    // optional bool display_only = 3;
    if (has_display_only()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 address_n = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EncryptMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EncryptMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EncryptMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EncryptMessage::MergeFrom(const EncryptMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pubkey()) {
      set_pubkey(from.pubkey());
    }
    if (from.has_message()) {
      set_message(from.message());
    }
    if (from.has_display_only()) {
      set_display_only(from.display_only());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EncryptMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EncryptMessage::CopyFrom(const EncryptMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptMessage::IsInitialized() const {

  return true;
}

void EncryptMessage::Swap(EncryptMessage* other) {
  if (other != this) {
    std::swap(pubkey_, other->pubkey_);
    std::swap(message_, other->message_);
    std::swap(display_only_, other->display_only_);
    address_n_.Swap(&other->address_n_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EncryptMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EncryptMessage_descriptor_;
  metadata.reflection = EncryptMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DecryptMessage::kAddressNFieldNumber;
const int DecryptMessage::kMessageFieldNumber;
#endif  // !_MSC_VER

DecryptMessage::DecryptMessage()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DecryptMessage::InitAsDefaultInstance() {
}

DecryptMessage::DecryptMessage(const DecryptMessage& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DecryptMessage::SharedCtor() {
  _cached_size_ = 0;
  message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DecryptMessage::~DecryptMessage() {
  SharedDtor();
}

void DecryptMessage::SharedDtor() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (this != default_instance_) {
  }
}

void DecryptMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DecryptMessage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DecryptMessage_descriptor_;
}

const DecryptMessage& DecryptMessage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DecryptMessage* DecryptMessage::default_instance_ = NULL;

DecryptMessage* DecryptMessage::New() const {
  return new DecryptMessage;
}

void DecryptMessage::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_message()) {
      if (message_ != &::google::protobuf::internal::kEmptyString) {
        message_->clear();
      }
    }
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DecryptMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_message;
        break;
      }

      // optional bytes message = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_message()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DecryptMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // optional bytes message = 2;
  if (has_message()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->message(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DecryptMessage::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // optional bytes message = 2;
  if (has_message()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->message(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DecryptMessage::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional bytes message = 2;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->message());
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DecryptMessage::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DecryptMessage* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DecryptMessage*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DecryptMessage::MergeFrom(const DecryptMessage& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_message()) {
      set_message(from.message());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DecryptMessage::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DecryptMessage::CopyFrom(const DecryptMessage& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptMessage::IsInitialized() const {

  return true;
}

void DecryptMessage::Swap(DecryptMessage* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(message_, other->message_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DecryptMessage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DecryptMessage_descriptor_;
  metadata.reflection = DecryptMessage_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CipherKeyValue::kAddressNFieldNumber;
const int CipherKeyValue::kKeyFieldNumber;
const int CipherKeyValue::kValueFieldNumber;
const int CipherKeyValue::kEncryptFieldNumber;
const int CipherKeyValue::kAskOnEncryptFieldNumber;
const int CipherKeyValue::kAskOnDecryptFieldNumber;
#endif  // !_MSC_VER

CipherKeyValue::CipherKeyValue()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CipherKeyValue::InitAsDefaultInstance() {
}

CipherKeyValue::CipherKeyValue(const CipherKeyValue& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CipherKeyValue::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  encrypt_ = false;
  ask_on_encrypt_ = false;
  ask_on_decrypt_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CipherKeyValue::~CipherKeyValue() {
  SharedDtor();
}

void CipherKeyValue::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void CipherKeyValue::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CipherKeyValue::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CipherKeyValue_descriptor_;
}

const CipherKeyValue& CipherKeyValue::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

CipherKeyValue* CipherKeyValue::default_instance_ = NULL;

CipherKeyValue* CipherKeyValue::New() const {
  return new CipherKeyValue;
}

void CipherKeyValue::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
    encrypt_ = false;
    ask_on_encrypt_ = false;
    ask_on_decrypt_ = false;
  }
  address_n_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CipherKeyValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 address_n = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_address_n:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_address_n())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_address_n())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_address_n;
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional bytes value = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_value()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_encrypt;
        break;
      }

      // optional bool encrypt = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_encrypt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &encrypt_)));
          set_has_encrypt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ask_on_encrypt;
        break;
      }

      // optional bool ask_on_encrypt = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ask_on_encrypt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ask_on_encrypt_)));
          set_has_ask_on_encrypt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ask_on_decrypt;
        break;
      }

      // optional bool ask_on_decrypt = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ask_on_decrypt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ask_on_decrypt_)));
          set_has_ask_on_decrypt();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CipherKeyValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->address_n(i), output);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->key(), output);
  }

  // optional bytes value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      3, this->value(), output);
  }

  // optional bool encrypt = 4;
  if (has_encrypt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->encrypt(), output);
  }

  // optional bool ask_on_encrypt = 5;
  if (has_ask_on_encrypt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->ask_on_encrypt(), output);
  }

  // optional bool ask_on_decrypt = 6;
  if (has_ask_on_decrypt()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->ask_on_decrypt(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CipherKeyValue::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated uint32 address_n = 1;
  for (int i = 0; i < this->address_n_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->address_n(i), target);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  // optional bytes value = 3;
  if (has_value()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->value(), target);
  }

  // optional bool encrypt = 4;
  if (has_encrypt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->encrypt(), target);
  }

  // optional bool ask_on_encrypt = 5;
  if (has_ask_on_encrypt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->ask_on_encrypt(), target);
  }

  // optional bool ask_on_decrypt = 6;
  if (has_ask_on_decrypt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->ask_on_decrypt(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CipherKeyValue::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // optional string key = 2;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional bytes value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->value());
    }

    // optional bool encrypt = 4;
    if (has_encrypt()) {
      total_size += 1 + 1;
    }

    // optional bool ask_on_encrypt = 5;
    if (has_ask_on_encrypt()) {
      total_size += 1 + 1;
    }

    // optional bool ask_on_decrypt = 6;
    if (has_ask_on_decrypt()) {
      total_size += 1 + 1;
    }

  }
  // repeated uint32 address_n = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->address_n_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->address_n(i));
    }
    total_size += 1 * this->address_n_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CipherKeyValue::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CipherKeyValue* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CipherKeyValue*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CipherKeyValue::MergeFrom(const CipherKeyValue& from) {
  GOOGLE_CHECK_NE(&from, this);
  address_n_.MergeFrom(from.address_n_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
    if (from.has_encrypt()) {
      set_encrypt(from.encrypt());
    }
    if (from.has_ask_on_encrypt()) {
      set_ask_on_encrypt(from.ask_on_encrypt());
    }
    if (from.has_ask_on_decrypt()) {
      set_ask_on_decrypt(from.ask_on_decrypt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CipherKeyValue::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CipherKeyValue::CopyFrom(const CipherKeyValue& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CipherKeyValue::IsInitialized() const {

  return true;
}

void CipherKeyValue::Swap(CipherKeyValue* other) {
  if (other != this) {
    address_n_.Swap(&other->address_n_);
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(encrypt_, other->encrypt_);
    std::swap(ask_on_encrypt_, other->ask_on_encrypt_);
    std::swap(ask_on_decrypt_, other->ask_on_decrypt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CipherKeyValue::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CipherKeyValue_descriptor_;
  metadata.reflection = CipherKeyValue_reflection_;
  return metadata;
}


// ===================================================================

::std::string* EstimateTxSize::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int EstimateTxSize::kOutputsCountFieldNumber;
const int EstimateTxSize::kInputsCountFieldNumber;
const int EstimateTxSize::kCoinNameFieldNumber;
#endif  // !_MSC_VER

EstimateTxSize::EstimateTxSize()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void EstimateTxSize::InitAsDefaultInstance() {
}

EstimateTxSize::EstimateTxSize(const EstimateTxSize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void EstimateTxSize::SharedCtor() {
  _cached_size_ = 0;
  outputs_count_ = 0u;
  inputs_count_ = 0u;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EstimateTxSize::~EstimateTxSize() {
  SharedDtor();
}

void EstimateTxSize::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void EstimateTxSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EstimateTxSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EstimateTxSize_descriptor_;
}

const EstimateTxSize& EstimateTxSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

EstimateTxSize* EstimateTxSize::default_instance_ = NULL;

EstimateTxSize* EstimateTxSize::New() const {
  return new EstimateTxSize;
}

void EstimateTxSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    outputs_count_ = 0u;
    inputs_count_ = 0u;
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EstimateTxSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
          set_has_outputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_inputs_count;
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inputs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
          set_has_inputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void EstimateTxSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* EstimateTxSize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int EstimateTxSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 outputs_count = 1;
    if (has_outputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_count());
    }

    // required uint32 inputs_count = 2;
    if (has_inputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_count());
    }

    // optional string coin_name = 3 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EstimateTxSize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EstimateTxSize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EstimateTxSize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EstimateTxSize::MergeFrom(const EstimateTxSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_outputs_count()) {
      set_outputs_count(from.outputs_count());
    }
    if (from.has_inputs_count()) {
      set_inputs_count(from.inputs_count());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EstimateTxSize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EstimateTxSize::CopyFrom(const EstimateTxSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EstimateTxSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void EstimateTxSize::Swap(EstimateTxSize* other) {
  if (other != this) {
    std::swap(outputs_count_, other->outputs_count_);
    std::swap(inputs_count_, other->inputs_count_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EstimateTxSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EstimateTxSize_descriptor_;
  metadata.reflection = EstimateTxSize_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxSize::kTxSizeFieldNumber;
#endif  // !_MSC_VER

TxSize::TxSize()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxSize::InitAsDefaultInstance() {
}

TxSize::TxSize(const TxSize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxSize::SharedCtor() {
  _cached_size_ = 0;
  tx_size_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxSize::~TxSize() {
  SharedDtor();
}

void TxSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TxSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxSize_descriptor_;
}

const TxSize& TxSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TxSize* TxSize::default_instance_ = NULL;

TxSize* TxSize::New() const {
  return new TxSize;
}

void TxSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tx_size_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 tx_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tx_size_)));
          set_has_tx_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 tx_size = 1;
  if (has_tx_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tx_size(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxSize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 tx_size = 1;
  if (has_tx_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tx_size(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 tx_size = 1;
    if (has_tx_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tx_size());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxSize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxSize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxSize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxSize::MergeFrom(const TxSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tx_size()) {
      set_tx_size(from.tx_size());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxSize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxSize::CopyFrom(const TxSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxSize::IsInitialized() const {

  return true;
}

void TxSize::Swap(TxSize* other) {
  if (other != this) {
    std::swap(tx_size_, other->tx_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxSize_descriptor_;
  metadata.reflection = TxSize_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SignTx::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int SignTx::kOutputsCountFieldNumber;
const int SignTx::kInputsCountFieldNumber;
const int SignTx::kCoinNameFieldNumber;
#endif  // !_MSC_VER

SignTx::SignTx()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SignTx::InitAsDefaultInstance() {
}

SignTx::SignTx(const SignTx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SignTx::SharedCtor() {
  _cached_size_ = 0;
  outputs_count_ = 0u;
  inputs_count_ = 0u;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SignTx::~SignTx() {
  SharedDtor();
}

void SignTx::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void SignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SignTx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SignTx_descriptor_;
}

const SignTx& SignTx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SignTx* SignTx::default_instance_ = NULL;

SignTx* SignTx::New() const {
  return new SignTx;
}

void SignTx::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    outputs_count_ = 0u;
    inputs_count_ = 0u;
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 outputs_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &outputs_count_)));
          set_has_outputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_inputs_count;
        break;
      }

      // required uint32 inputs_count = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_inputs_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &inputs_count_)));
          set_has_inputs_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 3 [default = "Bitcoin"];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->outputs_count(), output);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->inputs_count(), output);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SignTx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 outputs_count = 1;
  if (has_outputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->outputs_count(), target);
  }

  // required uint32 inputs_count = 2;
  if (has_inputs_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->inputs_count(), target);
  }

  // optional string coin_name = 3 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SignTx::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 outputs_count = 1;
    if (has_outputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->outputs_count());
    }

    // required uint32 inputs_count = 2;
    if (has_inputs_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->inputs_count());
    }

    // optional string coin_name = 3 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SignTx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SignTx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SignTx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SignTx::MergeFrom(const SignTx& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_outputs_count()) {
      set_outputs_count(from.outputs_count());
    }
    if (from.has_inputs_count()) {
      set_inputs_count(from.inputs_count());
    }
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SignTx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SignTx::CopyFrom(const SignTx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignTx::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SignTx::Swap(SignTx* other) {
  if (other != this) {
    std::swap(outputs_count_, other->outputs_count_);
    std::swap(inputs_count_, other->inputs_count_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SignTx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SignTx_descriptor_;
  metadata.reflection = SignTx_reflection_;
  return metadata;
}


// ===================================================================

::std::string* SimpleSignTx::_default_coin_name_ = NULL;
#ifndef _MSC_VER
const int SimpleSignTx::kInputsFieldNumber;
const int SimpleSignTx::kOutputsFieldNumber;
const int SimpleSignTx::kTransactionsFieldNumber;
const int SimpleSignTx::kCoinNameFieldNumber;
#endif  // !_MSC_VER

SimpleSignTx::SimpleSignTx()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SimpleSignTx::InitAsDefaultInstance() {
}

SimpleSignTx::SimpleSignTx(const SimpleSignTx& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SimpleSignTx::SharedCtor() {
  _cached_size_ = 0;
  coin_name_ = const_cast< ::std::string*>(_default_coin_name_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SimpleSignTx::~SimpleSignTx() {
  SharedDtor();
}

void SimpleSignTx::SharedDtor() {
  if (coin_name_ != _default_coin_name_) {
    delete coin_name_;
  }
  if (this != default_instance_) {
  }
}

void SimpleSignTx::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SimpleSignTx::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SimpleSignTx_descriptor_;
}

const SimpleSignTx& SimpleSignTx::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

SimpleSignTx* SimpleSignTx::default_instance_ = NULL;

SimpleSignTx* SimpleSignTx::New() const {
  return new SimpleSignTx;
}

void SimpleSignTx::Clear() {
  if (_has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    if (has_coin_name()) {
      if (coin_name_ != _default_coin_name_) {
        coin_name_->assign(*_default_coin_name_);
      }
    }
  }
  inputs_.Clear();
  outputs_.Clear();
  transactions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SimpleSignTx::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .TxInputType inputs = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_inputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_inputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_inputs;
        if (input->ExpectTag(18)) goto parse_outputs;
        break;
      }

      // repeated .TxOutputType outputs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_outputs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_outputs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_outputs;
        if (input->ExpectTag(26)) goto parse_transactions;
        break;
      }

      // repeated .TransactionType transactions = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_transactions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_transactions()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_transactions;
        if (input->ExpectTag(34)) goto parse_coin_name;
        break;
      }

      // optional string coin_name = 4 [default = "Bitcoin"];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_coin_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_coin_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->coin_name().data(), this->coin_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SimpleSignTx::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .TxInputType inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->inputs(i), output);
  }

  // repeated .TxOutputType outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->outputs(i), output);
  }

  // repeated .TransactionType transactions = 3;
  for (int i = 0; i < this->transactions_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->transactions(i), output);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->coin_name(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SimpleSignTx::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .TxInputType inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->inputs(i), target);
  }

  // repeated .TxOutputType outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->outputs(i), target);
  }

  // repeated .TransactionType transactions = 3;
  for (int i = 0; i < this->transactions_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->transactions(i), target);
  }

  // optional string coin_name = 4 [default = "Bitcoin"];
  if (has_coin_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->coin_name().data(), this->coin_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->coin_name(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SimpleSignTx::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    // optional string coin_name = 4 [default = "Bitcoin"];
    if (has_coin_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->coin_name());
    }

  }
  // repeated .TxInputType inputs = 1;
  total_size += 1 * this->inputs_size();
  for (int i = 0; i < this->inputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->inputs(i));
  }

  // repeated .TxOutputType outputs = 2;
  total_size += 1 * this->outputs_size();
  for (int i = 0; i < this->outputs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->outputs(i));
  }

  // repeated .TransactionType transactions = 3;
  total_size += 1 * this->transactions_size();
  for (int i = 0; i < this->transactions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->transactions(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SimpleSignTx::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SimpleSignTx* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SimpleSignTx*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SimpleSignTx::MergeFrom(const SimpleSignTx& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  transactions_.MergeFrom(from.transactions_);
  if (from._has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    if (from.has_coin_name()) {
      set_coin_name(from.coin_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SimpleSignTx::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimpleSignTx::CopyFrom(const SimpleSignTx& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimpleSignTx::IsInitialized() const {

  for (int i = 0; i < inputs_size(); i++) {
    if (!this->inputs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < outputs_size(); i++) {
    if (!this->outputs(i).IsInitialized()) return false;
  }
  for (int i = 0; i < transactions_size(); i++) {
    if (!this->transactions(i).IsInitialized()) return false;
  }
  return true;
}

void SimpleSignTx::Swap(SimpleSignTx* other) {
  if (other != this) {
    inputs_.Swap(&other->inputs_);
    outputs_.Swap(&other->outputs_);
    transactions_.Swap(&other->transactions_);
    std::swap(coin_name_, other->coin_name_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SimpleSignTx::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SimpleSignTx_descriptor_;
  metadata.reflection = SimpleSignTx_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxRequest::kRequestTypeFieldNumber;
const int TxRequest::kDetailsFieldNumber;
const int TxRequest::kSerializedFieldNumber;
#endif  // !_MSC_VER

TxRequest::TxRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxRequest::InitAsDefaultInstance() {
  details_ = const_cast< ::TxRequestDetailsType*>(&::TxRequestDetailsType::default_instance());
  serialized_ = const_cast< ::TxRequestSerializedType*>(&::TxRequestSerializedType::default_instance());
}

TxRequest::TxRequest(const TxRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxRequest::SharedCtor() {
  _cached_size_ = 0;
  request_type_ = 0;
  details_ = NULL;
  serialized_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxRequest::~TxRequest() {
  SharedDtor();
}

void TxRequest::SharedDtor() {
  if (this != default_instance_) {
    delete details_;
    delete serialized_;
  }
}

void TxRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxRequest_descriptor_;
}

const TxRequest& TxRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TxRequest* TxRequest::default_instance_ = NULL;

TxRequest* TxRequest::New() const {
  return new TxRequest;
}

void TxRequest::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    request_type_ = 0;
    if (has_details()) {
      if (details_ != NULL) details_->::TxRequestDetailsType::Clear();
    }
    if (has_serialized()) {
      if (serialized_ != NULL) serialized_->::TxRequestSerializedType::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .RequestType request_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::RequestType_IsValid(value)) {
            set_request_type(static_cast< ::RequestType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_details;
        break;
      }

      // optional .TxRequestDetailsType details = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_details:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_details()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_serialized;
        break;
      }

      // optional .TxRequestSerializedType serialized = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serialized:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_serialized()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .RequestType request_type = 1;
  if (has_request_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->request_type(), output);
  }

  // optional .TxRequestDetailsType details = 2;
  if (has_details()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->details(), output);
  }

  // optional .TxRequestSerializedType serialized = 3;
  if (has_serialized()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->serialized(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .RequestType request_type = 1;
  if (has_request_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->request_type(), target);
  }

  // optional .TxRequestDetailsType details = 2;
  if (has_details()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->details(), target);
  }

  // optional .TxRequestSerializedType serialized = 3;
  if (has_serialized()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->serialized(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .RequestType request_type = 1;
    if (has_request_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->request_type());
    }

    // optional .TxRequestDetailsType details = 2;
    if (has_details()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->details());
    }

    // optional .TxRequestSerializedType serialized = 3;
    if (has_serialized()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->serialized());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxRequest::MergeFrom(const TxRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_type()) {
      set_request_type(from.request_type());
    }
    if (from.has_details()) {
      mutable_details()->::TxRequestDetailsType::MergeFrom(from.details());
    }
    if (from.has_serialized()) {
      mutable_serialized()->::TxRequestSerializedType::MergeFrom(from.serialized());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxRequest::CopyFrom(const TxRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxRequest::IsInitialized() const {

  return true;
}

void TxRequest::Swap(TxRequest* other) {
  if (other != this) {
    std::swap(request_type_, other->request_type_);
    std::swap(details_, other->details_);
    std::swap(serialized_, other->serialized_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxRequest_descriptor_;
  metadata.reflection = TxRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TxAck::kTxFieldNumber;
#endif  // !_MSC_VER

TxAck::TxAck()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TxAck::InitAsDefaultInstance() {
  tx_ = const_cast< ::TransactionType*>(&::TransactionType::default_instance());
}

TxAck::TxAck(const TxAck& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TxAck::SharedCtor() {
  _cached_size_ = 0;
  tx_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TxAck::~TxAck() {
  SharedDtor();
}

void TxAck::SharedDtor() {
  if (this != default_instance_) {
    delete tx_;
  }
}

void TxAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TxAck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TxAck_descriptor_;
}

const TxAck& TxAck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TxAck* TxAck::default_instance_ = NULL;

TxAck* TxAck::New() const {
  return new TxAck;
}

void TxAck::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_tx()) {
      if (tx_ != NULL) tx_->::TransactionType::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TxAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .TransactionType tx = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tx()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TxAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .TransactionType tx = 1;
  if (has_tx()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tx(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TxAck::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .TransactionType tx = 1;
  if (has_tx()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->tx(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TxAck::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .TransactionType tx = 1;
    if (has_tx()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tx());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TxAck::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TxAck* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TxAck*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TxAck::MergeFrom(const TxAck& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tx()) {
      mutable_tx()->::TransactionType::MergeFrom(from.tx());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TxAck::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TxAck::CopyFrom(const TxAck& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TxAck::IsInitialized() const {

  if (has_tx()) {
    if (!this->tx().IsInitialized()) return false;
  }
  return true;
}

void TxAck::Swap(TxAck* other) {
  if (other != this) {
    std::swap(tx_, other->tx_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TxAck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TxAck_descriptor_;
  metadata.reflection = TxAck_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

FirmwareErase::FirmwareErase()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirmwareErase::InitAsDefaultInstance() {
}

FirmwareErase::FirmwareErase(const FirmwareErase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirmwareErase::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirmwareErase::~FirmwareErase() {
  SharedDtor();
}

void FirmwareErase::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FirmwareErase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirmwareErase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirmwareErase_descriptor_;
}

const FirmwareErase& FirmwareErase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FirmwareErase* FirmwareErase::default_instance_ = NULL;

FirmwareErase* FirmwareErase::New() const {
  return new FirmwareErase;
}

void FirmwareErase::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirmwareErase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void FirmwareErase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirmwareErase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirmwareErase::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareErase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirmwareErase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirmwareErase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirmwareErase::MergeFrom(const FirmwareErase& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirmwareErase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirmwareErase::CopyFrom(const FirmwareErase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareErase::IsInitialized() const {

  return true;
}

void FirmwareErase::Swap(FirmwareErase* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirmwareErase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirmwareErase_descriptor_;
  metadata.reflection = FirmwareErase_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FirmwareUpload::kPayloadFieldNumber;
#endif  // !_MSC_VER

FirmwareUpload::FirmwareUpload()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FirmwareUpload::InitAsDefaultInstance() {
}

FirmwareUpload::FirmwareUpload(const FirmwareUpload& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FirmwareUpload::SharedCtor() {
  _cached_size_ = 0;
  payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirmwareUpload::~FirmwareUpload() {
  SharedDtor();
}

void FirmwareUpload::SharedDtor() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    delete payload_;
  }
  if (this != default_instance_) {
  }
}

void FirmwareUpload::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirmwareUpload::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirmwareUpload_descriptor_;
}

const FirmwareUpload& FirmwareUpload::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

FirmwareUpload* FirmwareUpload::default_instance_ = NULL;

FirmwareUpload* FirmwareUpload::New() const {
  return new FirmwareUpload;
}

void FirmwareUpload::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_payload()) {
      if (payload_ != &::google::protobuf::internal::kEmptyString) {
        payload_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirmwareUpload::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes payload = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_payload()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FirmwareUpload::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bytes payload = 1;
  if (has_payload()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->payload(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FirmwareUpload::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes payload = 1;
  if (has_payload()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->payload(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FirmwareUpload::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes payload = 1;
    if (has_payload()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->payload());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirmwareUpload::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirmwareUpload* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirmwareUpload*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirmwareUpload::MergeFrom(const FirmwareUpload& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_payload()) {
      set_payload(from.payload());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirmwareUpload::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirmwareUpload::CopyFrom(const FirmwareUpload& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirmwareUpload::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FirmwareUpload::Swap(FirmwareUpload* other) {
  if (other != this) {
    std::swap(payload_, other->payload_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirmwareUpload::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirmwareUpload_descriptor_;
  metadata.reflection = FirmwareUpload_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TestScreen::kDelayTimeFieldNumber;
#endif  // !_MSC_VER

TestScreen::TestScreen()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TestScreen::InitAsDefaultInstance() {
}

TestScreen::TestScreen(const TestScreen& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TestScreen::SharedCtor() {
  _cached_size_ = 0;
  delay_time_ = 1u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestScreen::~TestScreen() {
  SharedDtor();
}

void TestScreen::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TestScreen::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TestScreen::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TestScreen_descriptor_;
}

const TestScreen& TestScreen::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TestScreen* TestScreen::default_instance_ = NULL;

TestScreen* TestScreen::New() const {
  return new TestScreen;
}

void TestScreen::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    delay_time_ = 1u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TestScreen::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 delay_time = 1 [default = 1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &delay_time_)));
          set_has_delay_time();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TestScreen::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 delay_time = 1 [default = 1];
  if (has_delay_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->delay_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TestScreen::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 delay_time = 1 [default = 1];
  if (has_delay_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->delay_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TestScreen::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 delay_time = 1 [default = 1];
    if (has_delay_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->delay_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestScreen::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TestScreen* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TestScreen*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TestScreen::MergeFrom(const TestScreen& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_delay_time()) {
      set_delay_time(from.delay_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TestScreen::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TestScreen::CopyFrom(const TestScreen& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestScreen::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TestScreen::Swap(TestScreen* other) {
  if (other != this) {
    std::swap(delay_time_, other->delay_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TestScreen::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TestScreen_descriptor_;
  metadata.reflection = TestScreen_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkDecision::kYesNoFieldNumber;
#endif  // !_MSC_VER

DebugLinkDecision::DebugLinkDecision()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkDecision::InitAsDefaultInstance() {
}

DebugLinkDecision::DebugLinkDecision(const DebugLinkDecision& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkDecision::SharedCtor() {
  _cached_size_ = 0;
  yes_no_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkDecision::~DebugLinkDecision() {
  SharedDtor();
}

void DebugLinkDecision::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkDecision::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkDecision::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkDecision_descriptor_;
}

const DebugLinkDecision& DebugLinkDecision::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DebugLinkDecision* DebugLinkDecision::default_instance_ = NULL;

DebugLinkDecision* DebugLinkDecision::New() const {
  return new DebugLinkDecision;
}

void DebugLinkDecision::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    yes_no_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkDecision::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool yes_no = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &yes_no_)));
          set_has_yes_no();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkDecision::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool yes_no = 1;
  if (has_yes_no()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->yes_no(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkDecision::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool yes_no = 1;
  if (has_yes_no()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->yes_no(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkDecision::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool yes_no = 1;
    if (has_yes_no()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkDecision::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkDecision* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkDecision*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkDecision::MergeFrom(const DebugLinkDecision& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_yes_no()) {
      set_yes_no(from.yes_no());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkDecision::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkDecision::CopyFrom(const DebugLinkDecision& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkDecision::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DebugLinkDecision::Swap(DebugLinkDecision* other) {
  if (other != this) {
    std::swap(yes_no_, other->yes_no_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkDecision::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkDecision_descriptor_;
  metadata.reflection = DebugLinkDecision_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

DebugLinkGetState::DebugLinkGetState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkGetState::InitAsDefaultInstance() {
}

DebugLinkGetState::DebugLinkGetState(const DebugLinkGetState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkGetState::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkGetState::~DebugLinkGetState() {
  SharedDtor();
}

void DebugLinkGetState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkGetState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkGetState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkGetState_descriptor_;
}

const DebugLinkGetState& DebugLinkGetState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DebugLinkGetState* DebugLinkGetState::default_instance_ = NULL;

DebugLinkGetState* DebugLinkGetState::New() const {
  return new DebugLinkGetState;
}

void DebugLinkGetState::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkGetState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void DebugLinkGetState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkGetState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkGetState::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkGetState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkGetState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkGetState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkGetState::MergeFrom(const DebugLinkGetState& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkGetState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkGetState::CopyFrom(const DebugLinkGetState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkGetState::IsInitialized() const {

  return true;
}

void DebugLinkGetState::Swap(DebugLinkGetState* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkGetState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkGetState_descriptor_;
  metadata.reflection = DebugLinkGetState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkState::kLayoutFieldNumber;
const int DebugLinkState::kPinFieldNumber;
const int DebugLinkState::kMatrixFieldNumber;
const int DebugLinkState::kMnemonicFieldNumber;
const int DebugLinkState::kNodeFieldNumber;
const int DebugLinkState::kPassphraseProtectionFieldNumber;
const int DebugLinkState::kResetWordFieldNumber;
const int DebugLinkState::kResetEntropyFieldNumber;
const int DebugLinkState::kRecoveryFakeWordFieldNumber;
const int DebugLinkState::kRecoveryWordPosFieldNumber;
#endif  // !_MSC_VER

DebugLinkState::DebugLinkState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkState::InitAsDefaultInstance() {
  node_ = const_cast< ::HDNodeType*>(&::HDNodeType::default_instance());
}

DebugLinkState::DebugLinkState(const DebugLinkState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkState::SharedCtor() {
  _cached_size_ = 0;
  layout_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  matrix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  mnemonic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  node_ = NULL;
  passphrase_protection_ = false;
  reset_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  reset_entropy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  recovery_fake_word_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  recovery_word_pos_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkState::~DebugLinkState() {
  SharedDtor();
}

void DebugLinkState::SharedDtor() {
  if (layout_ != &::google::protobuf::internal::kEmptyString) {
    delete layout_;
  }
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (matrix_ != &::google::protobuf::internal::kEmptyString) {
    delete matrix_;
  }
  if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
    delete mnemonic_;
  }
  if (reset_word_ != &::google::protobuf::internal::kEmptyString) {
    delete reset_word_;
  }
  if (reset_entropy_ != &::google::protobuf::internal::kEmptyString) {
    delete reset_entropy_;
  }
  if (recovery_fake_word_ != &::google::protobuf::internal::kEmptyString) {
    delete recovery_fake_word_;
  }
  if (this != default_instance_) {
    delete node_;
  }
}

void DebugLinkState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkState_descriptor_;
}

const DebugLinkState& DebugLinkState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DebugLinkState* DebugLinkState::default_instance_ = NULL;

DebugLinkState* DebugLinkState::New() const {
  return new DebugLinkState;
}

void DebugLinkState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_layout()) {
      if (layout_ != &::google::protobuf::internal::kEmptyString) {
        layout_->clear();
      }
    }
    if (has_pin()) {
      if (pin_ != &::google::protobuf::internal::kEmptyString) {
        pin_->clear();
      }
    }
    if (has_matrix()) {
      if (matrix_ != &::google::protobuf::internal::kEmptyString) {
        matrix_->clear();
      }
    }
    if (has_mnemonic()) {
      if (mnemonic_ != &::google::protobuf::internal::kEmptyString) {
        mnemonic_->clear();
      }
    }
    if (has_node()) {
      if (node_ != NULL) node_->::HDNodeType::Clear();
    }
    passphrase_protection_ = false;
    if (has_reset_word()) {
      if (reset_word_ != &::google::protobuf::internal::kEmptyString) {
        reset_word_->clear();
      }
    }
    if (has_reset_entropy()) {
      if (reset_entropy_ != &::google::protobuf::internal::kEmptyString) {
        reset_entropy_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_recovery_fake_word()) {
      if (recovery_fake_word_ != &::google::protobuf::internal::kEmptyString) {
        recovery_fake_word_->clear();
      }
    }
    recovery_word_pos_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes layout = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_layout()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_pin;
        break;
      }

      // optional string pin = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->pin().data(), this->pin().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_matrix;
        break;
      }

      // optional string matrix = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_matrix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_matrix()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->matrix().data(), this->matrix().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_mnemonic;
        break;
      }

      // optional string mnemonic = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_mnemonic:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mnemonic()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->mnemonic().data(), this->mnemonic().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_node;
        break;
      }

      // optional .HDNodeType node = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_node:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_node()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_passphrase_protection;
        break;
      }

      // optional bool passphrase_protection = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_passphrase_protection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &passphrase_protection_)));
          set_has_passphrase_protection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_reset_word;
        break;
      }

      // optional string reset_word = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reset_word:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_reset_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->reset_word().data(), this->reset_word().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_reset_entropy;
        break;
      }

      // optional bytes reset_entropy = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_reset_entropy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reset_entropy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_recovery_fake_word;
        break;
      }

      // optional string recovery_fake_word = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_recovery_fake_word:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_recovery_fake_word()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->recovery_fake_word().data(), this->recovery_fake_word().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_recovery_word_pos;
        break;
      }

      // optional uint32 recovery_word_pos = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_recovery_word_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recovery_word_pos_)));
          set_has_recovery_word_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bytes layout = 1;
  if (has_layout()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->layout(), output);
  }

  // optional string pin = 2;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->pin(), output);
  }

  // optional string matrix = 3;
  if (has_matrix()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->matrix().data(), this->matrix().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->matrix(), output);
  }

  // optional string mnemonic = 4;
  if (has_mnemonic()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->mnemonic(), output);
  }

  // optional .HDNodeType node = 5;
  if (has_node()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->node(), output);
  }

  // optional bool passphrase_protection = 6;
  if (has_passphrase_protection()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->passphrase_protection(), output);
  }

  // optional string reset_word = 7;
  if (has_reset_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->reset_word().data(), this->reset_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->reset_word(), output);
  }

  // optional bytes reset_entropy = 8;
  if (has_reset_entropy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      8, this->reset_entropy(), output);
  }

  // optional string recovery_fake_word = 9;
  if (has_recovery_fake_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->recovery_fake_word().data(), this->recovery_fake_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->recovery_fake_word(), output);
  }

  // optional uint32 recovery_word_pos = 10;
  if (has_recovery_word_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->recovery_word_pos(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes layout = 1;
  if (has_layout()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->layout(), target);
  }

  // optional string pin = 2;
  if (has_pin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->pin().data(), this->pin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->pin(), target);
  }

  // optional string matrix = 3;
  if (has_matrix()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->matrix().data(), this->matrix().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->matrix(), target);
  }

  // optional string mnemonic = 4;
  if (has_mnemonic()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->mnemonic().data(), this->mnemonic().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->mnemonic(), target);
  }

  // optional .HDNodeType node = 5;
  if (has_node()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->node(), target);
  }

  // optional bool passphrase_protection = 6;
  if (has_passphrase_protection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->passphrase_protection(), target);
  }

  // optional string reset_word = 7;
  if (has_reset_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->reset_word().data(), this->reset_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->reset_word(), target);
  }

  // optional bytes reset_entropy = 8;
  if (has_reset_entropy()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->reset_entropy(), target);
  }

  // optional string recovery_fake_word = 9;
  if (has_recovery_fake_word()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->recovery_fake_word().data(), this->recovery_fake_word().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->recovery_fake_word(), target);
  }

  // optional uint32 recovery_word_pos = 10;
  if (has_recovery_word_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->recovery_word_pos(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes layout = 1;
    if (has_layout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->layout());
    }

    // optional string pin = 2;
    if (has_pin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pin());
    }

    // optional string matrix = 3;
    if (has_matrix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->matrix());
    }

    // optional string mnemonic = 4;
    if (has_mnemonic()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->mnemonic());
    }

    // optional .HDNodeType node = 5;
    if (has_node()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->node());
    }

    // optional bool passphrase_protection = 6;
    if (has_passphrase_protection()) {
      total_size += 1 + 1;
    }

    // optional string reset_word = 7;
    if (has_reset_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->reset_word());
    }

    // optional bytes reset_entropy = 8;
    if (has_reset_entropy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reset_entropy());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string recovery_fake_word = 9;
    if (has_recovery_fake_word()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->recovery_fake_word());
    }

    // optional uint32 recovery_word_pos = 10;
    if (has_recovery_word_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recovery_word_pos());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkState::MergeFrom(const DebugLinkState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layout()) {
      set_layout(from.layout());
    }
    if (from.has_pin()) {
      set_pin(from.pin());
    }
    if (from.has_matrix()) {
      set_matrix(from.matrix());
    }
    if (from.has_mnemonic()) {
      set_mnemonic(from.mnemonic());
    }
    if (from.has_node()) {
      mutable_node()->::HDNodeType::MergeFrom(from.node());
    }
    if (from.has_passphrase_protection()) {
      set_passphrase_protection(from.passphrase_protection());
    }
    if (from.has_reset_word()) {
      set_reset_word(from.reset_word());
    }
    if (from.has_reset_entropy()) {
      set_reset_entropy(from.reset_entropy());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_recovery_fake_word()) {
      set_recovery_fake_word(from.recovery_fake_word());
    }
    if (from.has_recovery_word_pos()) {
      set_recovery_word_pos(from.recovery_word_pos());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkState::CopyFrom(const DebugLinkState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkState::IsInitialized() const {

  if (has_node()) {
    if (!this->node().IsInitialized()) return false;
  }
  return true;
}

void DebugLinkState::Swap(DebugLinkState* other) {
  if (other != this) {
    std::swap(layout_, other->layout_);
    std::swap(pin_, other->pin_);
    std::swap(matrix_, other->matrix_);
    std::swap(mnemonic_, other->mnemonic_);
    std::swap(node_, other->node_);
    std::swap(passphrase_protection_, other->passphrase_protection_);
    std::swap(reset_word_, other->reset_word_);
    std::swap(reset_entropy_, other->reset_entropy_);
    std::swap(recovery_fake_word_, other->recovery_fake_word_);
    std::swap(recovery_word_pos_, other->recovery_word_pos_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkState_descriptor_;
  metadata.reflection = DebugLinkState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

DebugLinkStop::DebugLinkStop()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkStop::InitAsDefaultInstance() {
}

DebugLinkStop::DebugLinkStop(const DebugLinkStop& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkStop::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkStop::~DebugLinkStop() {
  SharedDtor();
}

void DebugLinkStop::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DebugLinkStop::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkStop::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkStop_descriptor_;
}

const DebugLinkStop& DebugLinkStop::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DebugLinkStop* DebugLinkStop::default_instance_ = NULL;

DebugLinkStop* DebugLinkStop::New() const {
  return new DebugLinkStop;
}

void DebugLinkStop::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkStop::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void DebugLinkStop::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkStop::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkStop::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkStop::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkStop* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkStop*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkStop::MergeFrom(const DebugLinkStop& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkStop::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkStop::CopyFrom(const DebugLinkStop& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkStop::IsInitialized() const {

  return true;
}

void DebugLinkStop::Swap(DebugLinkStop* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkStop::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkStop_descriptor_;
  metadata.reflection = DebugLinkStop_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DebugLinkLog::kLevelFieldNumber;
const int DebugLinkLog::kBucketFieldNumber;
const int DebugLinkLog::kTextFieldNumber;
#endif  // !_MSC_VER

DebugLinkLog::DebugLinkLog()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DebugLinkLog::InitAsDefaultInstance() {
}

DebugLinkLog::DebugLinkLog(const DebugLinkLog& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DebugLinkLog::SharedCtor() {
  _cached_size_ = 0;
  level_ = 0u;
  bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DebugLinkLog::~DebugLinkLog() {
  SharedDtor();
}

void DebugLinkLog::SharedDtor() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    delete bucket_;
  }
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (this != default_instance_) {
  }
}

void DebugLinkLog::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DebugLinkLog::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DebugLinkLog_descriptor_;
}

const DebugLinkLog& DebugLinkLog::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

DebugLinkLog* DebugLinkLog::default_instance_ = NULL;

DebugLinkLog* DebugLinkLog::New() const {
  return new DebugLinkLog;
}

void DebugLinkLog::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    level_ = 0u;
    if (has_bucket()) {
      if (bucket_ != &::google::protobuf::internal::kEmptyString) {
        bucket_->clear();
      }
    }
    if (has_text()) {
      if (text_ != &::google::protobuf::internal::kEmptyString) {
        text_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DebugLinkLog::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 level = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &level_)));
          set_has_level();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_bucket;
        break;
      }

      // optional string bucket = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bucket:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bucket()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bucket().data(), this->bucket().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_text;
        break;
      }

      // optional string text = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DebugLinkLog::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional uint32 level = 1;
  if (has_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->level(), output);
  }

  // optional string bucket = 2;
  if (has_bucket()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bucket().data(), this->bucket().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->bucket(), output);
  }

  // optional string text = 3;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->text(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DebugLinkLog::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional uint32 level = 1;
  if (has_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->level(), target);
  }

  // optional string bucket = 2;
  if (has_bucket()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bucket().data(), this->bucket().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->bucket(), target);
  }

  // optional string text = 3;
  if (has_text()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->text(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DebugLinkLog::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 level = 1;
    if (has_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->level());
    }

    // optional string bucket = 2;
    if (has_bucket()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bucket());
    }

    // optional string text = 3;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->text());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DebugLinkLog::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DebugLinkLog* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DebugLinkLog*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DebugLinkLog::MergeFrom(const DebugLinkLog& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_level()) {
      set_level(from.level());
    }
    if (from.has_bucket()) {
      set_bucket(from.bucket());
    }
    if (from.has_text()) {
      set_text(from.text());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DebugLinkLog::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DebugLinkLog::CopyFrom(const DebugLinkLog& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DebugLinkLog::IsInitialized() const {

  return true;
}

void DebugLinkLog::Swap(DebugLinkLog* other) {
  if (other != this) {
    std::swap(level_, other->level_);
    std::swap(bucket_, other->bucket_);
    std::swap(text_, other->text_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DebugLinkLog::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DebugLinkLog_descriptor_;
  metadata.reflection = DebugLinkLog_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
